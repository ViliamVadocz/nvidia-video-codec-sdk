/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const CUDA_VERSION: u32 = 12000;
pub const CU_IPC_HANDLE_SIZE: u32 = 64;
pub const CU_COMPUTE_ACCELERATED_TARGET_BASE: u32 = 65536;
pub const CU_MEMHOSTALLOC_PORTABLE: u32 = 1;
pub const CU_MEMHOSTALLOC_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTALLOC_WRITECOMBINED: u32 = 4;
pub const CU_MEMHOSTREGISTER_PORTABLE: u32 = 1;
pub const CU_MEMHOSTREGISTER_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTREGISTER_IOMEMORY: u32 = 4;
pub const CU_MEMHOSTREGISTER_READ_ONLY: u32 = 8;
pub const CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL: u32 = 1;
pub const CU_TENSOR_MAP_NUM_QWORDS: u32 = 16;
pub const CUDA_EXTERNAL_MEMORY_DEDICATED: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC: u32 = 2;
pub const CUDA_NVSCISYNC_ATTR_SIGNAL: u32 = 1;
pub const CUDA_NVSCISYNC_ATTR_WAIT: u32 = 2;
pub const CU_MEM_CREATE_USAGE_TILE_POOL: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC: u32 = 2;
pub const CUDA_ARRAY3D_LAYERED: u32 = 1;
pub const CUDA_ARRAY3D_2DARRAY: u32 = 1;
pub const CUDA_ARRAY3D_SURFACE_LDST: u32 = 2;
pub const CUDA_ARRAY3D_CUBEMAP: u32 = 4;
pub const CUDA_ARRAY3D_TEXTURE_GATHER: u32 = 8;
pub const CUDA_ARRAY3D_DEPTH_TEXTURE: u32 = 16;
pub const CUDA_ARRAY3D_COLOR_ATTACHMENT: u32 = 32;
pub const CUDA_ARRAY3D_SPARSE: u32 = 64;
pub const CUDA_ARRAY3D_DEFERRED_MAPPING: u32 = 128;
pub const CU_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const CU_TRSF_READ_AS_INTEGER: u32 = 1;
pub const CU_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const CU_TRSF_SRGB: u32 = 16;
pub const CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION: u32 = 32;
pub const CU_TRSF_SEAMLESS_CUBEMAP: u32 = 64;
pub const CU_LAUNCH_PARAM_END_AS_INT: u32 = 0;
pub const CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT: u32 = 1;
pub const CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT: u32 = 2;
pub const CU_PARAM_TR_DEFAULT: i32 = -1;
pub const I_VOP: u32 = 0;
pub const P_VOP: u32 = 1;
pub const B_VOP: u32 = 2;
pub const S_VOP: u32 = 3;
pub const MAX_CLOCK_TS: u32 = 3;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type max_align_t = f64;
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
pub type cuuint32_t = ::std::os::raw::c_uint;
pub type cuuint64_t = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr_v2 = ::std::os::raw::c_ulonglong;
pub type CUdeviceptr = CUdeviceptr_v2;
pub type CUdevice_v1 = ::std::os::raw::c_int;
pub type CUdevice = CUdevice_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlib_st {
    _unused: [u8; 0],
}
pub type CUlibrary = *mut CUlib_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUkern_st {
    _unused: [u8; 0],
}
pub type CUkernel = *mut CUkern_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUtexref_st {
    _unused: [u8; 0],
}
pub type CUtexref = *mut CUtexref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUsurfref_st {
    _unused: [u8; 0],
}
pub type CUsurfref = *mut CUsurfref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
pub type CUtexObject_v1 = ::std::os::raw::c_ulonglong;
pub type CUtexObject = CUtexObject_v1;
pub type CUsurfObject_v1 = ::std::os::raw::c_ulonglong;
pub type CUsurfObject = CUsurfObject_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
pub type CUmemoryPool = *mut CUmemPoolHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
pub type CUuserObject = *mut CUuserObject_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUuuid_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUuuid_st),
            "::",
            stringify!(bytes)
        )
    );
}
pub type CUuuid = CUuuid_st;
#[doc = " CUDA IPC event handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUipcEventHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcEventHandle_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUipcEventHandle_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUipcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA IPC event handle"]
pub type CUipcEventHandle_v1 = CUipcEventHandle_st;
#[doc = " CUDA IPC event handle"]
pub type CUipcEventHandle = CUipcEventHandle_v1;
#[doc = " CUDA IPC mem handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUipcMemHandle_st {
    pub reserved: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcMemHandle_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUipcMemHandle_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUipcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUipcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA IPC mem handle"]
pub type CUipcMemHandle_v1 = CUipcMemHandle_st;
#[doc = " CUDA IPC mem handle"]
pub type CUipcMemHandle = CUipcMemHandle_v1;
#[doc = "< Automatically enable peer access between remote devices as needed"]
pub const CUipcMem_flags_enum_CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS: CUipcMem_flags_enum = 1;
#[doc = " CUDA Ipc Mem Flags"]
pub type CUipcMem_flags_enum = ::std::os::raw::c_int;
#[doc = " CUDA Ipc Mem Flags"]
pub use self::CUipcMem_flags_enum as CUipcMem_flags;
#[doc = "< Memory can be accessed by any stream on any device"]
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_GLOBAL: CUmemAttach_flags_enum = 1;
#[doc = "< Memory cannot be accessed by any stream on any device"]
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_HOST: CUmemAttach_flags_enum = 2;
#[doc = "< Memory can only be accessed by a single stream on the associated device"]
pub const CUmemAttach_flags_enum_CU_MEM_ATTACH_SINGLE: CUmemAttach_flags_enum = 4;
#[doc = " CUDA Mem Attach Flags"]
pub type CUmemAttach_flags_enum = ::std::os::raw::c_int;
#[doc = " CUDA Mem Attach Flags"]
pub use self::CUmemAttach_flags_enum as CUmemAttach_flags;
#[doc = "< Automatic scheduling"]
pub const CUctx_flags_enum_CU_CTX_SCHED_AUTO: CUctx_flags_enum = 0;
#[doc = "< Set spin as default scheduling"]
pub const CUctx_flags_enum_CU_CTX_SCHED_SPIN: CUctx_flags_enum = 1;
#[doc = "< Set yield as default scheduling"]
pub const CUctx_flags_enum_CU_CTX_SCHED_YIELD: CUctx_flags_enum = 2;
#[doc = "< Set blocking synchronization as default scheduling"]
pub const CUctx_flags_enum_CU_CTX_SCHED_BLOCKING_SYNC: CUctx_flags_enum = 4;
#[doc = "< Set blocking synchronization as default scheduling\n  \\deprecated This flag was deprecated as of CUDA 4.0\n  and was replaced with ::CU_CTX_SCHED_BLOCKING_SYNC."]
pub const CUctx_flags_enum_CU_CTX_BLOCKING_SYNC: CUctx_flags_enum = 4;
pub const CUctx_flags_enum_CU_CTX_SCHED_MASK: CUctx_flags_enum = 7;
#[doc = "< \\deprecated This flag was deprecated as of CUDA 11.0\n  and it no longer has any effect. All contexts\n  as of CUDA 3.2 behave as though the flag is enabled."]
pub const CUctx_flags_enum_CU_CTX_MAP_HOST: CUctx_flags_enum = 8;
#[doc = "< Keep local memory allocation after launch"]
pub const CUctx_flags_enum_CU_CTX_LMEM_RESIZE_TO_MAX: CUctx_flags_enum = 16;
pub const CUctx_flags_enum_CU_CTX_FLAGS_MASK: CUctx_flags_enum = 31;
#[doc = " Context creation flags"]
pub type CUctx_flags_enum = ::std::os::raw::c_int;
#[doc = " Context creation flags"]
pub use self::CUctx_flags_enum as CUctx_flags;
#[doc = "< Automatic scheduling"]
pub const CUevent_sched_flags_enum_CU_EVENT_SCHED_AUTO: CUevent_sched_flags_enum = 0;
#[doc = "< Set spin as default scheduling"]
pub const CUevent_sched_flags_enum_CU_EVENT_SCHED_SPIN: CUevent_sched_flags_enum = 1;
#[doc = "< Set yield as default scheduling"]
pub const CUevent_sched_flags_enum_CU_EVENT_SCHED_YIELD: CUevent_sched_flags_enum = 2;
#[doc = "< Set blocking synchronization as default scheduling"]
pub const CUevent_sched_flags_enum_CU_EVENT_SCHED_BLOCKING_SYNC: CUevent_sched_flags_enum = 4;
#[doc = " Event sched flags"]
pub type CUevent_sched_flags_enum = ::std::os::raw::c_int;
#[doc = " Event sched flags"]
pub use self::CUevent_sched_flags_enum as CUevent_sched_flags;
#[doc = "< Automatic scheduling"]
pub const cl_event_flags_enum_NVCL_EVENT_SCHED_AUTO: cl_event_flags_enum = 0;
#[doc = "< Set spin as default scheduling"]
pub const cl_event_flags_enum_NVCL_EVENT_SCHED_SPIN: cl_event_flags_enum = 1;
#[doc = "< Set yield as default scheduling"]
pub const cl_event_flags_enum_NVCL_EVENT_SCHED_YIELD: cl_event_flags_enum = 2;
#[doc = "< Set blocking synchronization as default scheduling"]
pub const cl_event_flags_enum_NVCL_EVENT_SCHED_BLOCKING_SYNC: cl_event_flags_enum = 4;
#[doc = " NVCL event scheduling flags"]
pub type cl_event_flags_enum = ::std::os::raw::c_int;
#[doc = " NVCL event scheduling flags"]
pub use self::cl_event_flags_enum as cl_event_flags;
#[doc = "< Automatic scheduling"]
pub const cl_context_flags_enum_NVCL_CTX_SCHED_AUTO: cl_context_flags_enum = 0;
#[doc = "< Set spin as default scheduling"]
pub const cl_context_flags_enum_NVCL_CTX_SCHED_SPIN: cl_context_flags_enum = 1;
#[doc = "< Set yield as default scheduling"]
pub const cl_context_flags_enum_NVCL_CTX_SCHED_YIELD: cl_context_flags_enum = 2;
#[doc = "< Set blocking synchronization as default scheduling"]
pub const cl_context_flags_enum_NVCL_CTX_SCHED_BLOCKING_SYNC: cl_context_flags_enum = 4;
#[doc = " NVCL context scheduling flags"]
pub type cl_context_flags_enum = ::std::os::raw::c_int;
#[doc = " NVCL context scheduling flags"]
pub use self::cl_context_flags_enum as cl_context_flags;
#[doc = "< Default stream flag"]
pub const CUstream_flags_enum_CU_STREAM_DEFAULT: CUstream_flags_enum = 0;
#[doc = "< Stream does not synchronize with stream 0 (the NULL stream)"]
pub const CUstream_flags_enum_CU_STREAM_NON_BLOCKING: CUstream_flags_enum = 1;
#[doc = " Stream creation flags"]
pub type CUstream_flags_enum = ::std::os::raw::c_int;
#[doc = " Stream creation flags"]
pub use self::CUstream_flags_enum as CUstream_flags;
#[doc = "< Default event flag"]
pub const CUevent_flags_enum_CU_EVENT_DEFAULT: CUevent_flags_enum = 0;
#[doc = "< Event uses blocking synchronization"]
pub const CUevent_flags_enum_CU_EVENT_BLOCKING_SYNC: CUevent_flags_enum = 1;
#[doc = "< Event will not record timing data"]
pub const CUevent_flags_enum_CU_EVENT_DISABLE_TIMING: CUevent_flags_enum = 2;
#[doc = "< Event is suitable for interprocess use. CU_EVENT_DISABLE_TIMING must be set"]
pub const CUevent_flags_enum_CU_EVENT_INTERPROCESS: CUevent_flags_enum = 4;
#[doc = " Event creation flags"]
pub type CUevent_flags_enum = ::std::os::raw::c_int;
#[doc = " Event creation flags"]
pub use self::CUevent_flags_enum as CUevent_flags;
#[doc = "< Default event record flag"]
pub const CUevent_record_flags_enum_CU_EVENT_RECORD_DEFAULT: CUevent_record_flags_enum = 0;
#[doc = "< When using stream capture, create an event record node\n  instead of the default behavior.  This flag is invalid\n  when used outside of capture."]
pub const CUevent_record_flags_enum_CU_EVENT_RECORD_EXTERNAL: CUevent_record_flags_enum = 1;
#[doc = " Event record flags"]
pub type CUevent_record_flags_enum = ::std::os::raw::c_int;
#[doc = " Event record flags"]
pub use self::CUevent_record_flags_enum as CUevent_record_flags;
#[doc = "< Default event wait flag"]
pub const CUevent_wait_flags_enum_CU_EVENT_WAIT_DEFAULT: CUevent_wait_flags_enum = 0;
#[doc = "< When using stream capture, create an event wait node\n  instead of the default behavior.  This flag is invalid\n  when used outside of capture."]
pub const CUevent_wait_flags_enum_CU_EVENT_WAIT_EXTERNAL: CUevent_wait_flags_enum = 1;
#[doc = " Event wait flags"]
pub type CUevent_wait_flags_enum = ::std::os::raw::c_int;
#[doc = " Event wait flags"]
pub use self::CUevent_wait_flags_enum as CUevent_wait_flags;
#[doc = "< Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit\nvalues). Note this is a cyclic comparison which ignores wraparound.\n(Default behavior.)"]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_GEQ: CUstreamWaitValue_flags_enum = 0;
#[doc = "< Wait until *addr == value."]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_EQ: CUstreamWaitValue_flags_enum = 1;
#[doc = "< Wait until (*addr & value) != 0."]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_AND: CUstreamWaitValue_flags_enum = 2;
#[doc = "< Wait until ~(*addr | value) != 0. Support for this operation can be\nqueried with ::cuDeviceGetAttribute() and\n::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR."]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_NOR: CUstreamWaitValue_flags_enum = 3;
#[doc = "< Follow the wait operation with a flush of outstanding remote writes. This\nmeans that, if a remote write operation is guaranteed to have reached the\ndevice before the wait can be satisfied, that write is guaranteed to be\nvisible to downstream device work. The device is permitted to reorder\nremote writes internally. For example, this flag would be required if\ntwo remote writes arrive in a defined order, the wait is satisfied by the\nsecond write, and downstream work needs to observe the first write.\nSupport for this operation is restricted to selected platforms and can be\nqueried with ::CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES."]
pub const CUstreamWaitValue_flags_enum_CU_STREAM_WAIT_VALUE_FLUSH: CUstreamWaitValue_flags_enum =
    1073741824;
#[doc = " Flags for ::cuStreamWaitValue32 and ::cuStreamWaitValue64"]
pub type CUstreamWaitValue_flags_enum = ::std::os::raw::c_int;
#[doc = " Flags for ::cuStreamWaitValue32 and ::cuStreamWaitValue64"]
pub use self::CUstreamWaitValue_flags_enum as CUstreamWaitValue_flags;
#[doc = "< Default behavior"]
pub const CUstreamWriteValue_flags_enum_CU_STREAM_WRITE_VALUE_DEFAULT:
    CUstreamWriteValue_flags_enum = 0;
#[doc = "< Permits the write to be reordered with writes which were issued\nbefore it, as a performance optimization. Normally,\n::cuStreamWriteValue32 will provide a memory fence before the\nwrite, which has similar semantics to\n__threadfence_system() but is scoped to the stream\nrather than a CUDA thread.\nThis flag is not supported in the v2 API."]
pub const CUstreamWriteValue_flags_enum_CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER:
    CUstreamWriteValue_flags_enum = 1;
#[doc = " Flags for ::cuStreamWriteValue32"]
pub type CUstreamWriteValue_flags_enum = ::std::os::raw::c_int;
#[doc = " Flags for ::cuStreamWriteValue32"]
pub use self::CUstreamWriteValue_flags_enum as CUstreamWriteValue_flags;
#[doc = "< Represents a ::cuStreamWaitValue32 operation"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WAIT_VALUE_32: CUstreamBatchMemOpType_enum =
    1;
#[doc = "< Represents a ::cuStreamWriteValue32 operation"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WRITE_VALUE_32: CUstreamBatchMemOpType_enum =
    2;
#[doc = "< Represents a ::cuStreamWaitValue64 operation"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WAIT_VALUE_64: CUstreamBatchMemOpType_enum =
    4;
#[doc = "< Represents a ::cuStreamWriteValue64 operation"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_WRITE_VALUE_64: CUstreamBatchMemOpType_enum =
    5;
#[doc = "< Insert a memory barrier of the specified type"]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_BARRIER: CUstreamBatchMemOpType_enum = 6;
#[doc = "< This has the same effect as ::CU_STREAM_WAIT_VALUE_FLUSH, but as a\nstandalone operation."]
pub const CUstreamBatchMemOpType_enum_CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES:
    CUstreamBatchMemOpType_enum = 3;
#[doc = " Operations for ::cuStreamBatchMemOp"]
pub type CUstreamBatchMemOpType_enum = ::std::os::raw::c_int;
#[doc = " Operations for ::cuStreamBatchMemOp"]
pub use self::CUstreamBatchMemOpType_enum as CUstreamBatchMemOpType;
#[doc = "< System-wide memory barrier."]
pub const CUstreamMemoryBarrier_flags_enum_CU_STREAM_MEMORY_BARRIER_TYPE_SYS:
    CUstreamMemoryBarrier_flags_enum = 0;
#[doc = "< Limit memory barrier scope to the GPU."]
pub const CUstreamMemoryBarrier_flags_enum_CU_STREAM_MEMORY_BARRIER_TYPE_GPU:
    CUstreamMemoryBarrier_flags_enum = 1;
#[doc = " Flags for ::cuStreamMemoryBarrier"]
pub type CUstreamMemoryBarrier_flags_enum = ::std::os::raw::c_int;
#[doc = " Flags for ::cuStreamMemoryBarrier"]
pub use self::CUstreamMemoryBarrier_flags_enum as CUstreamMemoryBarrier_flags;
#[doc = " Per-operation parameters for ::cuStreamBatchMemOp"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union {
    pub operation: CUstreamBatchMemOpType,
    pub waitValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
    pub writeValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
    pub flushRemoteWrites: CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
    pub memoryBarrier: CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st,
    pub pad: [cuuint64_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< For driver internal use. Initial value is unimportant."]
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< For driver internal use. Initial value is unimportant."]
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union() {
    const UNINIT: ::std::mem::MaybeUninit<CUstreamBatchMemOpParams_union> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUstreamBatchMemOpParams_union>(),
        48usize,
        concat!("Size of: ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUstreamBatchMemOpParams_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).waitValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(waitValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writeValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(writeValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushRemoteWrites) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(flushRemoteWrites)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryBarrier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(memoryBarrier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(pad)
        )
    );
}
#[doc = " Per-operation parameters for ::cuStreamBatchMemOp"]
pub type CUstreamBatchMemOpParams_v1 = CUstreamBatchMemOpParams_union;
#[doc = " Per-operation parameters for ::cuStreamBatchMemOp"]
pub type CUstreamBatchMemOpParams = CUstreamBatchMemOpParams_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_BATCH_MEM_OP_NODE_PARAMS_st {
    pub ctx: CUcontext,
    pub count: ::std::os::raw::c_uint,
    pub paramArray: *mut CUstreamBatchMemOpParams,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_BATCH_MEM_OP_NODE_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_BATCH_MEM_OP_NODE_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_BATCH_MEM_OP_NODE_PARAMS_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_BATCH_MEM_OP_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramArray) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st),
            "::",
            stringify!(paramArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type CUDA_BATCH_MEM_OP_NODE_PARAMS = CUDA_BATCH_MEM_OP_NODE_PARAMS_st;
#[doc = "< Default behavior"]
pub const CUoccupancy_flags_enum_CU_OCCUPANCY_DEFAULT: CUoccupancy_flags_enum = 0;
#[doc = "< Assume global caching is enabled and cannot be automatically turned off"]
pub const CUoccupancy_flags_enum_CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE: CUoccupancy_flags_enum = 1;
#[doc = " Occupancy calculator flag"]
pub type CUoccupancy_flags_enum = ::std::os::raw::c_int;
#[doc = " Occupancy calculator flag"]
pub use self::CUoccupancy_flags_enum as CUoccupancy_flags;
#[doc = "< Add new nodes to the dependency set"]
pub const CUstreamUpdateCaptureDependencies_flags_enum_CU_STREAM_ADD_CAPTURE_DEPENDENCIES:
    CUstreamUpdateCaptureDependencies_flags_enum = 0;
#[doc = "< Replace the dependency set with the new nodes"]
pub const CUstreamUpdateCaptureDependencies_flags_enum_CU_STREAM_SET_CAPTURE_DEPENDENCIES:
    CUstreamUpdateCaptureDependencies_flags_enum = 1;
#[doc = " Flags for ::cuStreamUpdateCaptureDependencies"]
pub type CUstreamUpdateCaptureDependencies_flags_enum = ::std::os::raw::c_int;
#[doc = " Flags for ::cuStreamUpdateCaptureDependencies"]
pub use self::CUstreamUpdateCaptureDependencies_flags_enum as CUstreamUpdateCaptureDependencies_flags;
#[doc = "< Unsigned 8-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT8: CUarray_format_enum = 1;
#[doc = "< Unsigned 16-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT16: CUarray_format_enum = 2;
#[doc = "< Unsigned 32-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNSIGNED_INT32: CUarray_format_enum = 3;
#[doc = "< Signed 8-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT8: CUarray_format_enum = 8;
#[doc = "< Signed 16-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT16: CUarray_format_enum = 9;
#[doc = "< Signed 32-bit integers"]
pub const CUarray_format_enum_CU_AD_FORMAT_SIGNED_INT32: CUarray_format_enum = 10;
#[doc = "< 16-bit floating point"]
pub const CUarray_format_enum_CU_AD_FORMAT_HALF: CUarray_format_enum = 16;
#[doc = "< 32-bit floating point"]
pub const CUarray_format_enum_CU_AD_FORMAT_FLOAT: CUarray_format_enum = 32;
#[doc = "< 8-bit YUV planar format, with 4:2:0 sampling"]
pub const CUarray_format_enum_CU_AD_FORMAT_NV12: CUarray_format_enum = 176;
#[doc = "< 1 channel unsigned 8-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT8X1: CUarray_format_enum = 192;
#[doc = "< 2 channel unsigned 8-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT8X2: CUarray_format_enum = 193;
#[doc = "< 4 channel unsigned 8-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT8X4: CUarray_format_enum = 194;
#[doc = "< 1 channel unsigned 16-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT16X1: CUarray_format_enum = 195;
#[doc = "< 2 channel unsigned 16-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT16X2: CUarray_format_enum = 196;
#[doc = "< 4 channel unsigned 16-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_UNORM_INT16X4: CUarray_format_enum = 197;
#[doc = "< 1 channel signed 8-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT8X1: CUarray_format_enum = 198;
#[doc = "< 2 channel signed 8-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT8X2: CUarray_format_enum = 199;
#[doc = "< 4 channel signed 8-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT8X4: CUarray_format_enum = 200;
#[doc = "< 1 channel signed 16-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT16X1: CUarray_format_enum = 201;
#[doc = "< 2 channel signed 16-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT16X2: CUarray_format_enum = 202;
#[doc = "< 4 channel signed 16-bit normalized integer"]
pub const CUarray_format_enum_CU_AD_FORMAT_SNORM_INT16X4: CUarray_format_enum = 203;
#[doc = "< 4 channel unsigned normalized block-compressed (BC1 compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC1_UNORM: CUarray_format_enum = 145;
#[doc = "< 4 channel unsigned normalized block-compressed (BC1 compression) format with sRGB encoding"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC1_UNORM_SRGB: CUarray_format_enum = 146;
#[doc = "< 4 channel unsigned normalized block-compressed (BC2 compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC2_UNORM: CUarray_format_enum = 147;
#[doc = "< 4 channel unsigned normalized block-compressed (BC2 compression) format with sRGB encoding"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC2_UNORM_SRGB: CUarray_format_enum = 148;
#[doc = "< 4 channel unsigned normalized block-compressed (BC3 compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC3_UNORM: CUarray_format_enum = 149;
#[doc = "< 4 channel unsigned normalized block-compressed (BC3 compression) format with sRGB encoding"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC3_UNORM_SRGB: CUarray_format_enum = 150;
#[doc = "< 1 channel unsigned normalized block-compressed (BC4 compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC4_UNORM: CUarray_format_enum = 151;
#[doc = "< 1 channel signed normalized block-compressed (BC4 compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC4_SNORM: CUarray_format_enum = 152;
#[doc = "< 2 channel unsigned normalized block-compressed (BC5 compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC5_UNORM: CUarray_format_enum = 153;
#[doc = "< 2 channel signed normalized block-compressed (BC5 compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC5_SNORM: CUarray_format_enum = 154;
#[doc = "< 3 channel unsigned half-float block-compressed (BC6H compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC6H_UF16: CUarray_format_enum = 155;
#[doc = "< 3 channel signed half-float block-compressed (BC6H compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC6H_SF16: CUarray_format_enum = 156;
#[doc = "< 4 channel unsigned normalized block-compressed (BC7 compression) format"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC7_UNORM: CUarray_format_enum = 157;
#[doc = "< 4 channel unsigned normalized block-compressed (BC7 compression) format with sRGB encoding"]
pub const CUarray_format_enum_CU_AD_FORMAT_BC7_UNORM_SRGB: CUarray_format_enum = 158;
#[doc = " Array formats"]
pub type CUarray_format_enum = ::std::os::raw::c_int;
#[doc = " Array formats"]
pub use self::CUarray_format_enum as CUarray_format;
#[doc = "< Wrapping address mode"]
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_WRAP: CUaddress_mode_enum = 0;
#[doc = "< Clamp to edge address mode"]
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_CLAMP: CUaddress_mode_enum = 1;
#[doc = "< Mirror address mode"]
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_MIRROR: CUaddress_mode_enum = 2;
#[doc = "< Border address mode"]
pub const CUaddress_mode_enum_CU_TR_ADDRESS_MODE_BORDER: CUaddress_mode_enum = 3;
#[doc = " Texture reference addressing modes"]
pub type CUaddress_mode_enum = ::std::os::raw::c_int;
#[doc = " Texture reference addressing modes"]
pub use self::CUaddress_mode_enum as CUaddress_mode;
#[doc = "< Point filter mode"]
pub const CUfilter_mode_enum_CU_TR_FILTER_MODE_POINT: CUfilter_mode_enum = 0;
#[doc = "< Linear filter mode"]
pub const CUfilter_mode_enum_CU_TR_FILTER_MODE_LINEAR: CUfilter_mode_enum = 1;
#[doc = " Texture reference filtering modes"]
pub type CUfilter_mode_enum = ::std::os::raw::c_int;
#[doc = " Texture reference filtering modes"]
pub use self::CUfilter_mode_enum as CUfilter_mode;
#[doc = "< Maximum number of threads per block"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
    CUdevice_attribute_enum = 1;
#[doc = "< Maximum block dimension X"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: CUdevice_attribute_enum = 2;
#[doc = "< Maximum block dimension Y"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: CUdevice_attribute_enum = 3;
#[doc = "< Maximum block dimension Z"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: CUdevice_attribute_enum = 4;
#[doc = "< Maximum grid dimension X"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: CUdevice_attribute_enum = 5;
#[doc = "< Maximum grid dimension Y"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: CUdevice_attribute_enum = 6;
#[doc = "< Maximum grid dimension Z"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: CUdevice_attribute_enum = 7;
#[doc = "< Maximum shared memory available per block in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 8;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 8;
#[doc = "< Memory available on device for __constant__ variables in a CUDA C kernel in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY:
    CUdevice_attribute_enum = 9;
#[doc = "< Warp size in threads"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_WARP_SIZE: CUdevice_attribute_enum = 10;
#[doc = "< Maximum pitch in bytes allowed by memory copies"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_PITCH: CUdevice_attribute_enum = 11;
#[doc = "< Maximum number of 32-bit registers available per block"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK:
    CUdevice_attribute_enum = 12;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum =
    12;
#[doc = "< Typical clock frequency in kilohertz"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CLOCK_RATE: CUdevice_attribute_enum = 13;
#[doc = "< Alignment requirement for textures"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: CUdevice_attribute_enum =
    14;
#[doc = "< Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: CUdevice_attribute_enum = 15;
#[doc = "< Number of multiprocessors on device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT:
    CUdevice_attribute_enum = 16;
#[doc = "< Specifies whether there is a run time limit on kernels"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: CUdevice_attribute_enum =
    17;
#[doc = "< Device is integrated with host memory"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_INTEGRATED: CUdevice_attribute_enum = 18;
#[doc = "< Device can map host memory into CUDA address space"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: CUdevice_attribute_enum =
    19;
#[doc = "< Compute mode (See ::CUcomputemode for details)"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: CUdevice_attribute_enum = 20;
#[doc = "< Maximum 1D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH:
    CUdevice_attribute_enum = 21;
#[doc = "< Maximum 2D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH:
    CUdevice_attribute_enum = 22;
#[doc = "< Maximum 2D texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT:
    CUdevice_attribute_enum = 23;
#[doc = "< Maximum 3D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH:
    CUdevice_attribute_enum = 24;
#[doc = "< Maximum 3D texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT:
    CUdevice_attribute_enum = 25;
#[doc = "< Maximum 3D texture depth"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH:
    CUdevice_attribute_enum = 26;
#[doc = "< Maximum 2D layered texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 27;
#[doc = "< Maximum 2D layered texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT:
    CUdevice_attribute_enum = 28;
#[doc = "< Maximum layers in a 2D layered texture"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 29;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH:
    CUdevice_attribute_enum = 27;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT:
    CUdevice_attribute_enum = 28;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES:
    CUdevice_attribute_enum = 29;
#[doc = "< Alignment requirement for surfaces"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT: CUdevice_attribute_enum =
    30;
#[doc = "< Device can possibly execute multiple kernels concurrently"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS: CUdevice_attribute_enum =
    31;
#[doc = "< Device has ECC support enabled"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_ECC_ENABLED: CUdevice_attribute_enum = 32;
#[doc = "< PCI bus ID of the device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: CUdevice_attribute_enum = 33;
#[doc = "< PCI device ID of the device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: CUdevice_attribute_enum = 34;
#[doc = "< Device is using TCC driver model"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TCC_DRIVER: CUdevice_attribute_enum = 35;
#[doc = "< Peak memory clock frequency in kilohertz"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: CUdevice_attribute_enum =
    36;
#[doc = "< Global memory bus width in bits"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH:
    CUdevice_attribute_enum = 37;
#[doc = "< Size of L2 cache in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: CUdevice_attribute_enum = 38;
#[doc = "< Maximum resident threads per multiprocessor"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 39;
#[doc = "< Number of asynchronous engines"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT: CUdevice_attribute_enum =
    40;
#[doc = "< Device shares a unified address space with the host"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: CUdevice_attribute_enum =
    41;
#[doc = "< Maximum 1D layered texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 42;
#[doc = "< Maximum layers in a 1D layered texture"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 43;
#[doc = "< Deprecated, do not use."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER: CUdevice_attribute_enum =
    44;
#[doc = "< Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH:
    CUdevice_attribute_enum = 45;
#[doc = "< Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT:
    CUdevice_attribute_enum = 46;
#[doc = "< Alternate maximum 3D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE:
    CUdevice_attribute_enum = 47;
#[doc = "< Alternate maximum 3D texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE:
    CUdevice_attribute_enum = 48;
#[doc = "< Alternate maximum 3D texture depth"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE:
    CUdevice_attribute_enum = 49;
#[doc = "< PCI domain ID of the device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: CUdevice_attribute_enum = 50;
#[doc = "< Pitch alignment requirement for textures"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT:
    CUdevice_attribute_enum = 51;
#[doc = "< Maximum cubemap texture width/height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH:
    CUdevice_attribute_enum = 52;
#[doc = "< Maximum cubemap layered texture width/height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH:
    CUdevice_attribute_enum = 53;
#[doc = "< Maximum layers in a cubemap layered texture"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS:
    CUdevice_attribute_enum = 54;
#[doc = "< Maximum 1D surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH:
    CUdevice_attribute_enum = 55;
#[doc = "< Maximum 2D surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH:
    CUdevice_attribute_enum = 56;
#[doc = "< Maximum 2D surface height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT:
    CUdevice_attribute_enum = 57;
#[doc = "< Maximum 3D surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH:
    CUdevice_attribute_enum = 58;
#[doc = "< Maximum 3D surface height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT:
    CUdevice_attribute_enum = 59;
#[doc = "< Maximum 3D surface depth"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH:
    CUdevice_attribute_enum = 60;
#[doc = "< Maximum 1D layered surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 61;
#[doc = "< Maximum layers in a 1D layered surface"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 62;
#[doc = "< Maximum 2D layered surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH:
    CUdevice_attribute_enum = 63;
#[doc = "< Maximum 2D layered surface height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT:
    CUdevice_attribute_enum = 64;
#[doc = "< Maximum layers in a 2D layered surface"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS:
    CUdevice_attribute_enum = 65;
#[doc = "< Maximum cubemap surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH:
    CUdevice_attribute_enum = 66;
#[doc = "< Maximum cubemap layered surface width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH:
    CUdevice_attribute_enum = 67;
#[doc = "< Maximum layers in a cubemap layered surface"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS:
    CUdevice_attribute_enum = 68;
#[doc = "< Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth() or cuDeviceGetTexture1DLinearMaxWidth() instead."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH:
    CUdevice_attribute_enum = 69;
#[doc = "< Maximum 2D linear texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH:
    CUdevice_attribute_enum = 70;
#[doc = "< Maximum 2D linear texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT:
    CUdevice_attribute_enum = 71;
#[doc = "< Maximum 2D linear texture pitch in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH:
    CUdevice_attribute_enum = 72;
#[doc = "< Maximum mipmapped 2D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH:
    CUdevice_attribute_enum = 73;
#[doc = "< Maximum mipmapped 2D texture height"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT:
    CUdevice_attribute_enum = 74;
#[doc = "< Major compute capability version number"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR:
    CUdevice_attribute_enum = 75;
#[doc = "< Minor compute capability version number"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR:
    CUdevice_attribute_enum = 76;
#[doc = "< Maximum mipmapped 1D texture width"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH:
    CUdevice_attribute_enum = 77;
#[doc = "< Device supports stream priorities"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED:
    CUdevice_attribute_enum = 78;
#[doc = "< Device supports caching globals in L1"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED:
    CUdevice_attribute_enum = 79;
#[doc = "< Device supports caching locals in L1"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED:
    CUdevice_attribute_enum = 80;
#[doc = "< Maximum shared memory available per multiprocessor in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 81;
#[doc = "< Maximum number of 32-bit registers available per multiprocessor"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 82;
#[doc = "< Device can allocate managed memory on this system"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: CUdevice_attribute_enum = 83;
#[doc = "< Device is on a multi-GPU board"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: CUdevice_attribute_enum = 84;
#[doc = "< Unique id for a group of devices on the same multi-GPU board"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID:
    CUdevice_attribute_enum = 85;
#[doc = "< Link between the device and the host supports native atomic operations (this is a placeholder attribute, and is not supported on any current hardware)"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED:
    CUdevice_attribute_enum = 86;
#[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO:
    CUdevice_attribute_enum = 87;
#[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS:
    CUdevice_attribute_enum = 88;
#[doc = "< Device can coherently access managed memory concurrently with the CPU"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS:
    CUdevice_attribute_enum = 89;
#[doc = "< Device supports compute preemption."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED:
    CUdevice_attribute_enum = 90;
#[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM:
    CUdevice_attribute_enum = 91;
#[doc = "< Deprecated, along with v1 MemOps API, ::cuStreamBatchMemOp and related APIs are supported."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1:
    CUdevice_attribute_enum = 92;
#[doc = "< Deprecated, along with v1 MemOps API, 64-bit operations are supported in ::cuStreamBatchMemOp and related APIs."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1:
    CUdevice_attribute_enum = 93;
#[doc = "< Deprecated, along with v1 MemOps API, ::CU_STREAM_WAIT_VALUE_NOR is supported."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1:
    CUdevice_attribute_enum = 94;
#[doc = "< Device supports launching cooperative kernels via ::cuLaunchCooperativeKernel"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH: CUdevice_attribute_enum =
    95;
#[doc = "< Deprecated, ::cuLaunchCooperativeKernelMultiDevice is deprecated."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH:
    CUdevice_attribute_enum = 96;
#[doc = "< Maximum optin shared memory per block"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN:
    CUdevice_attribute_enum = 97;
#[doc = "< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device. See \\ref CUDA_MEMOP for additional details."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES:
    CUdevice_attribute_enum = 98;
#[doc = "< Device supports host memory registration via ::cudaHostRegister."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED:
    CUdevice_attribute_enum = 99;
#[doc = "< Device accesses pageable memory via the host's page tables."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES : CUdevice_attribute_enum = 100 ;
#[doc = "< The host can directly access managed memory on the device without migration."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST:
    CUdevice_attribute_enum = 101;
#[doc = "< Deprecated, Use CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED:
    CUdevice_attribute_enum = 102;
#[doc = "< Device supports virtual memory management APIs like ::cuMemAddressReserve, ::cuMemCreate, ::cuMemMap and related APIs"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED:
    CUdevice_attribute_enum = 102;
#[doc = "< Device supports exporting memory to a posix file descriptor with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED : CUdevice_attribute_enum = 103 ;
#[doc = "< Device supports exporting memory to a Win32 NT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED:
    CUdevice_attribute_enum = 104;
#[doc = "< Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED:
    CUdevice_attribute_enum = 105;
#[doc = "< Maximum number of blocks per multiprocessor"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR:
    CUdevice_attribute_enum = 106;
#[doc = "< Device supports compression of memory"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED:
    CUdevice_attribute_enum = 107;
#[doc = "< Maximum L2 persisting lines capacity setting in bytes."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE:
    CUdevice_attribute_enum = 108;
#[doc = "< Maximum value of CUaccessPolicyWindow::num_bytes."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE:
    CUdevice_attribute_enum = 109;
#[doc = "< Device supports specifying the GPUDirect RDMA flag with ::cuMemCreate"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED:
    CUdevice_attribute_enum = 110;
#[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK:
    CUdevice_attribute_enum = 111;
#[doc = "< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED:
    CUdevice_attribute_enum = 112;
#[doc = "< Device supports using the ::cuMemHostRegister flag ::CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED:
    CUdevice_attribute_enum = 113;
#[doc = "< External timeline semaphore interop is supported on the device"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED:
    CUdevice_attribute_enum = 114;
#[doc = "< Device supports using the ::cuMemAllocAsync and ::cuMemPool family of APIs"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED:
    CUdevice_attribute_enum = 115;
#[doc = "< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED:
    CUdevice_attribute_enum = 116;
#[doc = "< The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the ::CUflushGPUDirectRDMAWritesOptions enum"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS:
    CUdevice_attribute_enum = 117;
#[doc = "< GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::CUGPUDirectRDMAWritesOrdering for the numerical values returned here."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING:
    CUdevice_attribute_enum = 118;
#[doc = "< Handle types supported with mempool based IPC"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES:
    CUdevice_attribute_enum = 119;
#[doc = "< Indicates device supports cluster launch"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH: CUdevice_attribute_enum = 120;
#[doc = "< Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays"]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED:
    CUdevice_attribute_enum = 121;
#[doc = "< 64-bit operations are supported in ::cuStreamBatchMemOp and related MemOp APIs."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS:
    CUdevice_attribute_enum = 122;
#[doc = "< ::CU_STREAM_WAIT_VALUE_NOR is supported by MemOp APIs."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR:
    CUdevice_attribute_enum = 123;
#[doc = "< Device supports buffer sharing with dma_buf mechanism."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED: CUdevice_attribute_enum =
    124;
#[doc = "< Device supports IPC Events."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED: CUdevice_attribute_enum =
    125;
#[doc = "< Number of memory domains the device supports."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT:
    CUdevice_attribute_enum = 126;
#[doc = "< Device supports accessing memory using Tensor Map."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED:
    CUdevice_attribute_enum = 127;
#[doc = "< Device supports unified function pointers."]
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS:
    CUdevice_attribute_enum = 129;
pub const CUdevice_attribute_enum_CU_DEVICE_ATTRIBUTE_MAX: CUdevice_attribute_enum = 130;
#[doc = " Device properties"]
pub type CUdevice_attribute_enum = ::std::os::raw::c_int;
#[doc = " Device properties"]
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[doc = " Legacy device properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUdevprop_st {
    #[doc = "< Maximum number of threads per block"]
    pub maxThreadsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Maximum size of each dimension of a block"]
    pub maxThreadsDim: [::std::os::raw::c_int; 3usize],
    #[doc = "< Maximum size of each dimension of a grid"]
    pub maxGridSize: [::std::os::raw::c_int; 3usize],
    #[doc = "< Shared memory available per block in bytes"]
    pub sharedMemPerBlock: ::std::os::raw::c_int,
    #[doc = "< Constant memory available on device in bytes"]
    pub totalConstantMemory: ::std::os::raw::c_int,
    #[doc = "< Warp size in threads"]
    pub SIMDWidth: ::std::os::raw::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: ::std::os::raw::c_int,
    #[doc = "< 32-bit registers available per block"]
    pub regsPerBlock: ::std::os::raw::c_int,
    #[doc = "< Clock frequency in kilohertz"]
    pub clockRate: ::std::os::raw::c_int,
    #[doc = "< Alignment requirement for textures"]
    pub textureAlign: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUdevprop_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUdevprop_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUdevprop_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUdevprop_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsDim) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxGridSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemPerBlock) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalConstantMemory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(totalConstantMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SIMDWidth) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(SIMDWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memPitch) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regsPerBlock) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockRate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).textureAlign) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(textureAlign)
        )
    );
}
#[doc = " Legacy device properties"]
pub type CUdevprop_v1 = CUdevprop_st;
#[doc = " Legacy device properties"]
pub type CUdevprop = CUdevprop_v1;
#[doc = "< The ::CUcontext on which a pointer was allocated or registered"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_CONTEXT: CUpointer_attribute_enum = 1;
#[doc = "< The ::CUmemorytype describing the physical location of a pointer"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MEMORY_TYPE: CUpointer_attribute_enum = 2;
#[doc = "< The address at which a pointer's memory may be accessed on the device"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_DEVICE_POINTER: CUpointer_attribute_enum =
    3;
#[doc = "< The address at which a pointer's memory may be accessed on the host"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_HOST_POINTER: CUpointer_attribute_enum = 4;
#[doc = "< A pair of tokens for use with the nv-p2p.h Linux kernel interface"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_P2P_TOKENS: CUpointer_attribute_enum = 5;
#[doc = "< Synchronize every synchronous memory operation initiated on this region"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_SYNC_MEMOPS: CUpointer_attribute_enum = 6;
#[doc = "< A process-wide unique ID for an allocated memory region"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_BUFFER_ID: CUpointer_attribute_enum = 7;
#[doc = "< Indicates if the pointer points to managed memory"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_MANAGED: CUpointer_attribute_enum = 8;
#[doc = "< A device ordinal of a device on which a pointer was allocated or registered"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL: CUpointer_attribute_enum =
    9;
#[doc = "< 1 if this pointer maps to an allocation that is suitable for ::cudaIpcGetMemHandle, 0 otherwise"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE:
    CUpointer_attribute_enum = 10;
#[doc = "< Starting address for this requested pointer"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_RANGE_START_ADDR: CUpointer_attribute_enum =
    11;
#[doc = "< Size of the address range for this requested pointer"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_RANGE_SIZE: CUpointer_attribute_enum = 12;
#[doc = "< 1 if this pointer is in a valid address range that is mapped to a backing allocation, 0 otherwise"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MAPPED: CUpointer_attribute_enum = 13;
#[doc = "< Bitmask of allowed ::CUmemAllocationHandleType for this allocation"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES:
    CUpointer_attribute_enum = 14;
#[doc = "< 1 if the memory this pointer is referencing can be used with the GPUDirect RDMA API"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE:
    CUpointer_attribute_enum = 15;
#[doc = "< Returns the access flags the device associated with the current context has on the corresponding memory referenced by the pointer given"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAGS: CUpointer_attribute_enum = 16;
#[doc = "< Returns the mempool handle for the allocation if it was allocated from a mempool. Otherwise returns NULL."]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE: CUpointer_attribute_enum =
    17;
#[doc = "< Size of the actual underlying mapping that the pointer belongs to"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MAPPING_SIZE: CUpointer_attribute_enum = 18;
#[doc = "< The start address of the mapping that the pointer belongs to"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR:
    CUpointer_attribute_enum = 19;
#[doc = "< A process-wide unique id corresponding to the physical allocation the pointer belongs to"]
pub const CUpointer_attribute_enum_CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID: CUpointer_attribute_enum =
    20;
#[doc = " Pointer information"]
pub type CUpointer_attribute_enum = ::std::os::raw::c_int;
#[doc = " Pointer information"]
pub use self::CUpointer_attribute_enum as CUpointer_attribute;
#[doc = " The maximum number of threads per block, beyond which a launch of the\n function would fail. This number depends on both the function and the\n device on which the function is currently loaded."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK:
    CUfunction_attribute_enum = 0;
#[doc = " The size in bytes of statically-allocated shared memory required by\n this function. This does not include dynamically-allocated shared\n memory requested by the user at runtime."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: CUfunction_attribute_enum =
    1;
#[doc = " The size in bytes of user-allocated constant memory required by this\n function."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: CUfunction_attribute_enum =
    2;
#[doc = " The size in bytes of local memory used by each thread of this function."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: CUfunction_attribute_enum =
    3;
#[doc = " The number of registers used by each thread of this function."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_NUM_REGS: CUfunction_attribute_enum = 4;
#[doc = " The PTX virtual architecture version for which the function was\n compiled. This value is the major PTX version * 10 + the minor PTX\n version, so a PTX version 1.3 function would return the value 13.\n Note that this may return the undefined value of 0 for cubins\n compiled prior to CUDA 3.0."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_PTX_VERSION: CUfunction_attribute_enum = 5;
#[doc = " The binary architecture version for which the function was compiled.\n This value is the major binary version * 10 + the minor binary version,\n so a binary version 1.3 function would return the value 13. Note that\n this will return a value of 10 for legacy cubins that do not have a\n properly-encoded binary architecture version."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_BINARY_VERSION: CUfunction_attribute_enum = 6;
#[doc = " The attribute to indicate whether the function has been compiled with\n user specified option \"-Xptxas --dlcm=ca\" set ."]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_CACHE_MODE_CA: CUfunction_attribute_enum = 7;
#[doc = " The maximum size in bytes of dynamically-allocated shared memory that can be used by\n this function. If the user-specified dynamic shared memory size is larger than this\n value, the launch will fail.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES:
    CUfunction_attribute_enum = 8;
#[doc = " On devices where the L1 cache and shared memory use the same hardware resources,\n this sets the shared memory carveout preference, in percent of the total shared memory.\n Refer to ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR.\n This is only a hint, and the driver can choose a different ratio if required to execute the function.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT:
    CUfunction_attribute_enum = 9;
#[doc = " If this attribute is set, the kernel must launch with a valid cluster\n size specified.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET:
    CUfunction_attribute_enum = 10;
#[doc = " The required cluster width in blocks. The values must either all be 0 or\n all be positive. The validity of the cluster dimensions is otherwise\n checked at launch time.\n\n If the value is set during compile time, it cannot be set at runtime.\n Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH:
    CUfunction_attribute_enum = 11;
#[doc = " The required cluster height in blocks. The values must either all be 0 or\n all be positive. The validity of the cluster dimensions is otherwise\n checked at launch time.\n\n If the value is set during compile time, it cannot be set at runtime.\n Setting it at runtime should return CUDA_ERROR_NOT_PERMITTED.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT:
    CUfunction_attribute_enum = 12;
#[doc = " The required cluster depth in blocks. The values must either all be 0 or\n all be positive. The validity of the cluster dimensions is otherwise\n checked at launch time.\n\n If the value is set during compile time, it cannot be set at runtime.\n Setting it at runtime should return CUDA_ERROR_NOT_PERMITTED.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH:
    CUfunction_attribute_enum = 13;
#[doc = " Whether the function can be launched with non-portable cluster size. 1 is\n allowed, 0 is disallowed. A non-portable cluster size may only function\n on the specific SKUs the program is tested on. The launch might fail if\n the program is run on a different hardware platform.\n\n CUDA API provides cudaOccupancyMaxActiveClusters to assist with checking\n whether the desired size can be launched on the current device.\n\n Portable Cluster Size\n\n A portable cluster size is guaranteed to be functional on all compute\n capabilities higher than the target compute capability. The portable\n cluster size for sm_90 is 8 blocks per cluster. This value may increase\n for future compute capabilities.\n\n The specific hardware unit may support higher cluster sizes thats not\n guaranteed to be portable.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED:
    CUfunction_attribute_enum = 14;
#[doc = " The block scheduling policy of a function. The value type is\n CUclusterSchedulingPolicy / cudaClusterSchedulingPolicy.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE:
    CUfunction_attribute_enum = 15;
#[doc = " The block scheduling policy of a function. The value type is\n CUclusterSchedulingPolicy / cudaClusterSchedulingPolicy.\n See ::cuFuncSetAttribute, ::cuKernelSetAttribute"]
pub const CUfunction_attribute_enum_CU_FUNC_ATTRIBUTE_MAX: CUfunction_attribute_enum = 16;
#[doc = " Function properties"]
pub type CUfunction_attribute_enum = ::std::os::raw::c_int;
#[doc = " Function properties"]
pub use self::CUfunction_attribute_enum as CUfunction_attribute;
#[doc = "< no preference for shared memory or L1 (default)"]
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_NONE: CUfunc_cache_enum = 0;
#[doc = "< prefer larger shared memory and smaller L1 cache"]
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_SHARED: CUfunc_cache_enum = 1;
#[doc = "< prefer larger L1 cache and smaller shared memory"]
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_L1: CUfunc_cache_enum = 2;
#[doc = "< prefer equal sized L1 cache and shared memory"]
pub const CUfunc_cache_enum_CU_FUNC_CACHE_PREFER_EQUAL: CUfunc_cache_enum = 3;
#[doc = " Function cache configurations"]
pub type CUfunc_cache_enum = ::std::os::raw::c_int;
#[doc = " Function cache configurations"]
pub use self::CUfunc_cache_enum as CUfunc_cache;
#[doc = "< set default shared memory bank size"]
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE: CUsharedconfig_enum = 0;
#[doc = "< set shared memory bank width to four bytes"]
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: CUsharedconfig_enum = 1;
#[doc = "< set shared memory bank width to eight bytes"]
pub const CUsharedconfig_enum_CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: CUsharedconfig_enum = 2;
#[doc = " Shared memory configurations"]
pub type CUsharedconfig_enum = ::std::os::raw::c_int;
#[doc = " Shared memory configurations"]
pub use self::CUsharedconfig_enum as CUsharedconfig;
#[doc = "< No preference for shared memory or L1 (default)"]
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_DEFAULT: CUshared_carveout_enum = -1;
#[doc = "< Prefer maximum available shared memory, minimum L1 cache"]
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_MAX_SHARED: CUshared_carveout_enum = 100;
#[doc = "< Prefer maximum available L1 cache, minimum shared memory"]
pub const CUshared_carveout_enum_CU_SHAREDMEM_CARVEOUT_MAX_L1: CUshared_carveout_enum = 0;
#[doc = " Shared memory carveout configurations. These may be passed to ::cuFuncSetAttribute or ::cuKernelSetAttribute"]
pub type CUshared_carveout_enum = ::std::os::raw::c_int;
#[doc = " Shared memory carveout configurations. These may be passed to ::cuFuncSetAttribute or ::cuKernelSetAttribute"]
pub use self::CUshared_carveout_enum as CUshared_carveout;
#[doc = "< Host memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_HOST: CUmemorytype_enum = 1;
#[doc = "< Device memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_DEVICE: CUmemorytype_enum = 2;
#[doc = "< Array memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_ARRAY: CUmemorytype_enum = 3;
#[doc = "< Unified device or host memory"]
pub const CUmemorytype_enum_CU_MEMORYTYPE_UNIFIED: CUmemorytype_enum = 4;
#[doc = " Memory types"]
pub type CUmemorytype_enum = ::std::os::raw::c_int;
#[doc = " Memory types"]
pub use self::CUmemorytype_enum as CUmemorytype;
#[doc = "< Default compute mode (Multiple contexts allowed per device)"]
pub const CUcomputemode_enum_CU_COMPUTEMODE_DEFAULT: CUcomputemode_enum = 0;
#[doc = "< Compute-prohibited mode (No contexts can be created on this device at this time)"]
pub const CUcomputemode_enum_CU_COMPUTEMODE_PROHIBITED: CUcomputemode_enum = 2;
#[doc = "< Compute-exclusive-process mode (Only one context used by a single process can be present on this device at a time)"]
pub const CUcomputemode_enum_CU_COMPUTEMODE_EXCLUSIVE_PROCESS: CUcomputemode_enum = 3;
#[doc = " Compute Modes"]
pub type CUcomputemode_enum = ::std::os::raw::c_int;
#[doc = " Compute Modes"]
pub use self::CUcomputemode_enum as CUcomputemode;
#[doc = "< Data will mostly be read and only occassionally be written to"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_READ_MOSTLY: CUmem_advise_enum = 1;
#[doc = "< Undo the effect of ::CU_MEM_ADVISE_SET_READ_MOSTLY"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_READ_MOSTLY: CUmem_advise_enum = 2;
#[doc = "< Set the preferred location for the data as the specified device"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_PREFERRED_LOCATION: CUmem_advise_enum = 3;
#[doc = "< Clear the preferred location for the data"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION: CUmem_advise_enum = 4;
#[doc = "< Data will be accessed by the specified device, so prevent page faults as much as possible"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_SET_ACCESSED_BY: CUmem_advise_enum = 5;
#[doc = "< Let the Unified Memory subsystem decide on the page faulting policy for the specified device"]
pub const CUmem_advise_enum_CU_MEM_ADVISE_UNSET_ACCESSED_BY: CUmem_advise_enum = 6;
#[doc = " Memory advise values"]
pub type CUmem_advise_enum = ::std::os::raw::c_int;
#[doc = " Memory advise values"]
pub use self::CUmem_advise_enum as CUmem_advise;
#[doc = "< Whether the range will mostly be read and only occassionally be written to"]
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY:
    CUmem_range_attribute_enum = 1;
#[doc = "< The preferred location of the range"]
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION:
    CUmem_range_attribute_enum = 2;
#[doc = "< Memory range has ::CU_MEM_ADVISE_SET_ACCESSED_BY set for specified device"]
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY:
    CUmem_range_attribute_enum = 3;
#[doc = "< The last location to which the range was prefetched"]
pub const CUmem_range_attribute_enum_CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION:
    CUmem_range_attribute_enum = 4;
pub type CUmem_range_attribute_enum = ::std::os::raw::c_int;
pub use self::CUmem_range_attribute_enum as CUmem_range_attribute;
#[doc = " Max number of registers that a thread may use.\\n\n Option type: unsigned int\\n\n Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_MAX_REGISTERS: CUjit_option_enum = 0;
#[doc = " IN: Specifies minimum number of threads per block to target compilation\n for\\n\n OUT: Returns the number of threads the compiler actually targeted.\n This restricts the resource utilization fo the compiler (e.g. max\n registers) such that a block with the given number of threads should be\n able to launch based on register limitations. Note, this option does not\n currently take into account any other resource limitations, such as\n shared memory utilization.\\n\n Cannot be combined with ::CU_JIT_TARGET.\\n\n Option type: unsigned int\\n\n Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_THREADS_PER_BLOCK: CUjit_option_enum = 1;
#[doc = " Overwrites the option value with the total wall clock time, in\n milliseconds, spent in the compiler and linker\\n\n Option type: float\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_WALL_TIME: CUjit_option_enum = 2;
#[doc = " Pointer to a buffer in which to print any log messages\n that are informational in nature (the buffer size is specified via\n option ::CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES)\\n\n Option type: char *\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_INFO_LOG_BUFFER: CUjit_option_enum = 3;
#[doc = " IN: Log buffer size in bytes.  Log messages will be capped at this size\n (including null terminator)\\n\n OUT: Amount of log buffer filled with messages\\n\n Option type: unsigned int\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES: CUjit_option_enum = 4;
#[doc = " Pointer to a buffer in which to print any log messages that\n reflect errors (the buffer size is specified via option\n ::CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES)\\n\n Option type: char *\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_ERROR_LOG_BUFFER: CUjit_option_enum = 5;
#[doc = " IN: Log buffer size in bytes.  Log messages will be capped at this size\n (including null terminator)\\n\n OUT: Amount of log buffer filled with messages\\n\n Option type: unsigned int\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES: CUjit_option_enum = 6;
#[doc = " Level of optimizations to apply to generated code (0 - 4), with 4\n being the default and highest level of optimizations.\\n\n Option type: unsigned int\\n\n Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_OPTIMIZATION_LEVEL: CUjit_option_enum = 7;
#[doc = " No option value required. Determines the target based on the current\n attached context (default)\\n\n Option type: No option value needed\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_TARGET_FROM_CUCONTEXT: CUjit_option_enum = 8;
#[doc = " Target is chosen based on supplied ::CUjit_target.  Cannot be\n combined with ::CU_JIT_THREADS_PER_BLOCK.\\n\n Option type: unsigned int for enumerated type ::CUjit_target\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_TARGET: CUjit_option_enum = 9;
#[doc = " Specifies choice of fallback strategy if matching cubin is not found.\n Choice is based on supplied ::CUjit_fallback.  This option cannot be\n used with cuLink* APIs as the linker requires exact matches.\\n\n Option type: unsigned int for enumerated type ::CUjit_fallback\\n\n Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_FALLBACK_STRATEGY: CUjit_option_enum = 10;
#[doc = " Specifies whether to create debug information in output (-g)\n (0: false, default)\\n\n Option type: int\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_GENERATE_DEBUG_INFO: CUjit_option_enum = 11;
#[doc = " Generate verbose log messages (0: false, default)\\n\n Option type: int\\n\n Applies to: compiler and linker"]
pub const CUjit_option_enum_CU_JIT_LOG_VERBOSE: CUjit_option_enum = 12;
#[doc = " Generate line number information (-lineinfo) (0: false, default)\\n\n Option type: int\\n\n Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_GENERATE_LINE_INFO: CUjit_option_enum = 13;
#[doc = " Specifies whether to enable caching explicitly (-dlcm) \\n\n Choice is based on supplied ::CUjit_cacheMode_enum.\\n\n Option type: unsigned int for enumerated type ::CUjit_cacheMode_enum\\n\n Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_CACHE_MODE: CUjit_option_enum = 14;
#[doc = " \\deprecated\n This jit option is deprecated and should not be used."]
pub const CUjit_option_enum_CU_JIT_NEW_SM3X_OPT: CUjit_option_enum = 15;
#[doc = " This jit option is used for internal purpose only."]
pub const CUjit_option_enum_CU_JIT_FAST_COMPILE: CUjit_option_enum = 16;
#[doc = " Array of device symbol names that will be relocated to the corresponing\n host addresses stored in ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES.\\n\n Must contain ::CU_JIT_GLOBAL_SYMBOL_COUNT entries.\\n\n When loding a device module, driver will relocate all encountered\n unresolved symbols to the host addresses.\\n\n It is only allowed to register symbols that correspond to unresolved\n global variables.\\n\n It is illegal to register the same device symbol at multiple addresses.\\n\n Option type: const char **\\n\n Applies to: dynamic linker only"]
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_NAMES: CUjit_option_enum = 17;
#[doc = " Array of host addresses that will be used to relocate corresponding\n device symbols stored in ::CU_JIT_GLOBAL_SYMBOL_NAMES.\\n\n Must contain ::CU_JIT_GLOBAL_SYMBOL_COUNT entries.\\n\n Option type: void **\\n\n Applies to: dynamic linker only"]
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_ADDRESSES: CUjit_option_enum = 18;
#[doc = " Number of entries in ::CU_JIT_GLOBAL_SYMBOL_NAMES and\n ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES arrays.\\n\n Option type: unsigned int\\n\n Applies to: dynamic linker only"]
pub const CUjit_option_enum_CU_JIT_GLOBAL_SYMBOL_COUNT: CUjit_option_enum = 19;
#[doc = " \\deprecated\n Enable link-time optimization (-dlto) for device code (Disabled by default).\\n\n This option is not supported on 32-bit platforms.\\n\n Option type: int\\n\n Applies to: compiler and linker\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_LTO: CUjit_option_enum = 20;
#[doc = " \\deprecated\n Control single-precision denormals (-ftz) support (0: false, default).\n 1 : flushes denormal values to zero\n 0 : preserves denormal values\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_FTZ: CUjit_option_enum = 21;
#[doc = " \\deprecated\n Control single-precision floating-point division and reciprocals\n (-prec-div) support (1: true, default).\n 1 : Enables the IEEE round-to-nearest mode\n 0 : Enables the fast approximation mode\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_PREC_DIV: CUjit_option_enum = 22;
#[doc = " \\deprecated\n Control single-precision floating-point square root\n (-prec-sqrt) support (1: true, default).\n 1 : Enables the IEEE round-to-nearest mode\n 0 : Enables the fast approximation mode\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_PREC_SQRT: CUjit_option_enum = 23;
#[doc = " \\deprecated\n Enable/Disable the contraction of floating-point multiplies\n and adds/subtracts into floating-point multiply-add (-fma)\n operations (1: Enable, default; 0: Disable).\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_FMA: CUjit_option_enum = 24;
#[doc = " \\deprecated\n Array of kernel names that should be preserved at link time while others\n can be removed.\\n\n Must contain ::CU_JIT_REFERENCED_KERNEL_COUNT entries.\\n\n Note that kernel names can be mangled by the compiler in which case the\n mangled name needs to be specified.\\n\n Wildcard \"*\" can be used to represent zero or more characters instead of\n specifying the full or mangled name.\\n\n It is important to note that the wildcard \"*\" is also added implicitly.\n For example, specifying \"foo\" will match \"foobaz\", \"barfoo\", \"barfoobaz\" and\n thus preserve all kernels with those names. This can be avoided by providing\n a more specific name like \"barfoobaz\".\\n\n Option type: const char **\\n\n Applies to: dynamic linker only\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_REFERENCED_KERNEL_NAMES: CUjit_option_enum = 25;
#[doc = " \\deprecated\n Number of entries in ::CU_JIT_REFERENCED_KERNEL_NAMES array.\\n\n Option type: unsigned int\\n\n Applies to: dynamic linker only\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_REFERENCED_KERNEL_COUNT: CUjit_option_enum = 26;
#[doc = " \\deprecated\n Array of variable names (__device__ and/or __constant__) that should be\n preserved at link time while others can be removed.\\n\n Must contain ::CU_JIT_REFERENCED_VARIABLE_COUNT entries.\\n\n Note that variable names can be mangled by the compiler in which case the\n mangled name needs to be specified.\\n\n Wildcard \"*\" can be used to represent zero or more characters instead of\n specifying the full or mangled name.\\n\n It is important to note that the wildcard \"*\" is also added implicitly.\n For example, specifying \"foo\" will match \"foobaz\", \"barfoo\", \"barfoobaz\" and\n thus preserve all variables with those names. This can be avoided by providing\n a more specific name like \"barfoobaz\".\\n\n Option type: const char **\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_REFERENCED_VARIABLE_NAMES: CUjit_option_enum = 27;
#[doc = " \\deprecated\n Number of entries in ::CU_JIT_REFERENCED_VARIABLE_NAMES array.\\n\n Option type: unsigned int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_REFERENCED_VARIABLE_COUNT: CUjit_option_enum = 28;
#[doc = " \\deprecated\n This option serves as a hint to enable the JIT compiler/linker\n to remove constant (__constant__) and device (__device__) variables\n unreferenced in device code (Disabled by default).\\n\n Note that host references to constant and device variables using APIs like\n ::cuModuleGetGlobal() with this option specified may result in undefined behavior unless\n the variables are explicitly specified using ::CU_JIT_REFERENCED_VARIABLE_NAMES.\\n\n Option type: int\\n\n Applies to: link-time optimization specified with CU_JIT_LTO\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjit_option_enum_CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES: CUjit_option_enum = 29;
#[doc = " Generate position independent code (0: false)\\n\n Option type: int\\n\n Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_POSITION_INDEPENDENT_CODE: CUjit_option_enum = 30;
#[doc = " Generate position independent code (0: false)\\n\n Option type: int\\n\n Applies to: compiler only"]
pub const CUjit_option_enum_CU_JIT_NUM_OPTIONS: CUjit_option_enum = 31;
#[doc = " Online compiler and linker options"]
pub type CUjit_option_enum = ::std::os::raw::c_int;
#[doc = " Online compiler and linker options"]
pub use self::CUjit_option_enum as CUjit_option;
#[doc = "< Compute device class 3.0"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_30: CUjit_target_enum = 30;
#[doc = "< Compute device class 3.2"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_32: CUjit_target_enum = 32;
#[doc = "< Compute device class 3.5"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_35: CUjit_target_enum = 35;
#[doc = "< Compute device class 3.7"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_37: CUjit_target_enum = 37;
#[doc = "< Compute device class 5.0"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_50: CUjit_target_enum = 50;
#[doc = "< Compute device class 5.2"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_52: CUjit_target_enum = 52;
#[doc = "< Compute device class 5.3"]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_53: CUjit_target_enum = 53;
#[doc = "< Compute device class 6.0."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_60: CUjit_target_enum = 60;
#[doc = "< Compute device class 6.1."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_61: CUjit_target_enum = 61;
#[doc = "< Compute device class 6.2."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_62: CUjit_target_enum = 62;
#[doc = "< Compute device class 7.0."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_70: CUjit_target_enum = 70;
#[doc = "< Compute device class 7.2."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_72: CUjit_target_enum = 72;
#[doc = "< Compute device class 7.5."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_75: CUjit_target_enum = 75;
#[doc = "< Compute device class 8.0."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_80: CUjit_target_enum = 80;
#[doc = "< Compute device class 8.6."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_86: CUjit_target_enum = 86;
#[doc = "< Compute device class 8.7."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_87: CUjit_target_enum = 87;
#[doc = "< Compute device class 8.9."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_89: CUjit_target_enum = 89;
#[doc = "< Compute device class 9.0."]
pub const CUjit_target_enum_CU_TARGET_COMPUTE_90: CUjit_target_enum = 90;
pub const CUjit_target_enum_CU_TARGET_COMPUTE_90A: CUjit_target_enum = 65626;
#[doc = " Online compilation targets"]
pub type CUjit_target_enum = ::std::os::raw::c_int;
#[doc = " Online compilation targets"]
pub use self::CUjit_target_enum as CUjit_target;
#[doc = "< Prefer to compile ptx if exact binary match not found"]
pub const CUjit_fallback_enum_CU_PREFER_PTX: CUjit_fallback_enum = 0;
#[doc = "< Prefer to fall back to compatible binary code if exact match not found"]
pub const CUjit_fallback_enum_CU_PREFER_BINARY: CUjit_fallback_enum = 1;
#[doc = " Cubin matching fallback strategies"]
pub type CUjit_fallback_enum = ::std::os::raw::c_int;
#[doc = " Cubin matching fallback strategies"]
pub use self::CUjit_fallback_enum as CUjit_fallback;
#[doc = "< Compile with no -dlcm flag specified"]
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_NONE: CUjit_cacheMode_enum = 0;
#[doc = "< Compile with L1 cache disabled"]
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_CG: CUjit_cacheMode_enum = 1;
#[doc = "< Compile with L1 cache enabled"]
pub const CUjit_cacheMode_enum_CU_JIT_CACHE_OPTION_CA: CUjit_cacheMode_enum = 2;
#[doc = " Caching modes for dlcm"]
pub type CUjit_cacheMode_enum = ::std::os::raw::c_int;
#[doc = " Caching modes for dlcm"]
pub use self::CUjit_cacheMode_enum as CUjit_cacheMode;
#[doc = " Compiled device-class-specific device code\\n\n Applicable options: none"]
pub const CUjitInputType_enum_CU_JIT_INPUT_CUBIN: CUjitInputType_enum = 0;
#[doc = " PTX source code\\n\n Applicable options: PTX compiler options"]
pub const CUjitInputType_enum_CU_JIT_INPUT_PTX: CUjitInputType_enum = 1;
#[doc = " Bundle of multiple cubins and/or PTX of some device code\\n\n Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY"]
pub const CUjitInputType_enum_CU_JIT_INPUT_FATBINARY: CUjitInputType_enum = 2;
#[doc = " Host object with embedded device code\\n\n Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY"]
pub const CUjitInputType_enum_CU_JIT_INPUT_OBJECT: CUjitInputType_enum = 3;
#[doc = " Archive of host objects with embedded device code\\n\n Applicable options: PTX compiler options, ::CU_JIT_FALLBACK_STRATEGY"]
pub const CUjitInputType_enum_CU_JIT_INPUT_LIBRARY: CUjitInputType_enum = 4;
#[doc = " \\deprecated\n High-level intermediate code for link-time optimization\\n\n Applicable options: NVVM compiler options, PTX compiler options\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjitInputType_enum_CU_JIT_INPUT_NVVM: CUjitInputType_enum = 5;
#[doc = " \\deprecated\n High-level intermediate code for link-time optimization\\n\n Applicable options: NVVM compiler options, PTX compiler options\n\n Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0"]
pub const CUjitInputType_enum_CU_JIT_NUM_INPUT_TYPES: CUjitInputType_enum = 6;
#[doc = " Device code formats"]
pub type CUjitInputType_enum = ::std::os::raw::c_int;
#[doc = " Device code formats"]
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_NONE:
    CUgraphicsRegisterFlags_enum = 0;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY:
    CUgraphicsRegisterFlags_enum = 1;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD:
    CUgraphicsRegisterFlags_enum = 2;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST:
    CUgraphicsRegisterFlags_enum = 4;
pub const CUgraphicsRegisterFlags_enum_CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER:
    CUgraphicsRegisterFlags_enum = 8;
#[doc = " Flags to register a graphics resource"]
pub type CUgraphicsRegisterFlags_enum = ::std::os::raw::c_int;
#[doc = " Flags to register a graphics resource"]
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE:
    CUgraphicsMapResourceFlags_enum = 0;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY:
    CUgraphicsMapResourceFlags_enum = 1;
pub const CUgraphicsMapResourceFlags_enum_CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD:
    CUgraphicsMapResourceFlags_enum = 2;
#[doc = " Flags for mapping and unmapping interop resources"]
pub type CUgraphicsMapResourceFlags_enum = ::std::os::raw::c_int;
#[doc = " Flags for mapping and unmapping interop resources"]
pub use self::CUgraphicsMapResourceFlags_enum as CUgraphicsMapResourceFlags;
#[doc = "< Positive X face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_X: CUarray_cubemap_face_enum = 0;
#[doc = "< Negative X face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_X: CUarray_cubemap_face_enum = 1;
#[doc = "< Positive Y face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_Y: CUarray_cubemap_face_enum = 2;
#[doc = "< Negative Y face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_Y: CUarray_cubemap_face_enum = 3;
#[doc = "< Positive Z face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_POSITIVE_Z: CUarray_cubemap_face_enum = 4;
#[doc = "< Negative Z face of cubemap"]
pub const CUarray_cubemap_face_enum_CU_CUBEMAP_FACE_NEGATIVE_Z: CUarray_cubemap_face_enum = 5;
#[doc = " Array indices for cube faces"]
pub type CUarray_cubemap_face_enum = ::std::os::raw::c_int;
#[doc = " Array indices for cube faces"]
pub use self::CUarray_cubemap_face_enum as CUarray_cubemap_face;
#[doc = "< GPU thread stack size"]
pub const CUlimit_enum_CU_LIMIT_STACK_SIZE: CUlimit_enum = 0;
#[doc = "< GPU printf FIFO size"]
pub const CUlimit_enum_CU_LIMIT_PRINTF_FIFO_SIZE: CUlimit_enum = 1;
#[doc = "< GPU malloc heap size"]
pub const CUlimit_enum_CU_LIMIT_MALLOC_HEAP_SIZE: CUlimit_enum = 2;
#[doc = "< GPU device runtime launch synchronize depth"]
pub const CUlimit_enum_CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH: CUlimit_enum = 3;
#[doc = "< GPU device runtime pending launch count"]
pub const CUlimit_enum_CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT: CUlimit_enum = 4;
#[doc = "< A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint"]
pub const CUlimit_enum_CU_LIMIT_MAX_L2_FETCH_GRANULARITY: CUlimit_enum = 5;
#[doc = "< A size in bytes for L2 persisting lines cache size"]
pub const CUlimit_enum_CU_LIMIT_PERSISTING_L2_CACHE_SIZE: CUlimit_enum = 6;
pub const CUlimit_enum_CU_LIMIT_MAX: CUlimit_enum = 7;
#[doc = " Limits"]
pub type CUlimit_enum = ::std::os::raw::c_int;
#[doc = " Limits"]
pub use self::CUlimit_enum as CUlimit;
#[doc = "< Array resoure"]
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_ARRAY: CUresourcetype_enum = 0;
#[doc = "< Mipmapped array resource"]
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_MIPMAPPED_ARRAY: CUresourcetype_enum = 1;
#[doc = "< Linear resource"]
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_LINEAR: CUresourcetype_enum = 2;
#[doc = "< Pitch 2D resource"]
pub const CUresourcetype_enum_CU_RESOURCE_TYPE_PITCH2D: CUresourcetype_enum = 3;
#[doc = " Resource types"]
pub type CUresourcetype_enum = ::std::os::raw::c_int;
#[doc = " Resource types"]
pub use self::CUresourcetype_enum as CUresourcetype;
#[doc = " CUDA host function\n \\param userData Argument value passed to the function"]
pub type CUhostFn =
    ::std::option::Option<unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void)>;
#[doc = "< Normal cache persistence."]
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_NORMAL: CUaccessProperty_enum = 0;
#[doc = "< Streaming access is less likely to persit from cache."]
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_STREAMING: CUaccessProperty_enum = 1;
#[doc = "< Persisting access is more likely to persist in cache."]
pub const CUaccessProperty_enum_CU_ACCESS_PROPERTY_PERSISTING: CUaccessProperty_enum = 2;
#[doc = " Specifies performance hint with ::CUaccessPolicyWindow for hitProp and missProp members."]
pub type CUaccessProperty_enum = ::std::os::raw::c_int;
#[doc = " Specifies performance hint with ::CUaccessPolicyWindow for hitProp and missProp members."]
pub use self::CUaccessProperty_enum as CUaccessProperty;
#[doc = " Specifies an access policy for a window, a contiguous extent of memory\n beginning at base_ptr and ending at base_ptr + num_bytes.\n num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE.\n Partition into many segments and assign segments such that:\n sum of \"hit segments\" / window == approx. ratio.\n sum of \"miss segments\" / window == approx 1-ratio.\n Segments and ratio specifications are fitted to the capabilities of\n the architecture.\n Accesses in a hit segment apply the hitProp access policy.\n Accesses in a miss segment apply the missProp access policy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUaccessPolicyWindow_st {
    #[doc = "< Starting address of the access policy window. CUDA driver may align it."]
    pub base_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Size in bytes of the window policy. CUDA driver may restrict the maximum size and alignment."]
    pub num_bytes: usize,
    #[doc = "< hitRatio specifies percentage of lines assigned hitProp, rest are assigned missProp."]
    pub hitRatio: f32,
    #[doc = "< ::CUaccessProperty set for hit."]
    pub hitProp: CUaccessProperty,
    #[doc = "< ::CUaccessProperty set for miss. Must be either NORMAL or STREAMING"]
    pub missProp: CUaccessProperty,
}
#[test]
fn bindgen_test_layout_CUaccessPolicyWindow_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUaccessPolicyWindow_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUaccessPolicyWindow_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUaccessPolicyWindow_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(base_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(num_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitRatio) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(hitRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitProp) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(hitProp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missProp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(missProp)
        )
    );
}
#[doc = " Specifies an access policy for a window, a contiguous extent of memory\n beginning at base_ptr and ending at base_ptr + num_bytes.\n num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE.\n Partition into many segments and assign segments such that:\n sum of \"hit segments\" / window == approx. ratio.\n sum of \"miss segments\" / window == approx 1-ratio.\n Segments and ratio specifications are fitted to the capabilities of\n the architecture.\n Accesses in a hit segment apply the hitProp access policy.\n Accesses in a miss segment apply the missProp access policy."]
pub type CUaccessPolicyWindow_v1 = CUaccessPolicyWindow_st;
#[doc = " Access policy window"]
pub type CUaccessPolicyWindow = CUaccessPolicyWindow_v1;
#[doc = " GPU kernel node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_KERNEL_NODE_PARAMS_st {
    #[doc = "< Kernel to launch"]
    pub func: CUfunction,
    #[doc = "< Width of grid in blocks"]
    pub gridDimX: ::std::os::raw::c_uint,
    #[doc = "< Height of grid in blocks"]
    pub gridDimY: ::std::os::raw::c_uint,
    #[doc = "< Depth of grid in blocks"]
    pub gridDimZ: ::std::os::raw::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::std::os::raw::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::std::os::raw::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::std::os::raw::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Array of pointers to kernel parameters"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Extra options"]
    pub extra: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_KERNEL_NODE_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(extra)
        )
    );
}
#[doc = " GPU kernel node parameters"]
pub type CUDA_KERNEL_NODE_PARAMS_v1 = CUDA_KERNEL_NODE_PARAMS_st;
#[doc = " GPU kernel node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_KERNEL_NODE_PARAMS_v2_st {
    #[doc = "< Kernel to launch"]
    pub func: CUfunction,
    #[doc = "< Width of grid in blocks"]
    pub gridDimX: ::std::os::raw::c_uint,
    #[doc = "< Height of grid in blocks"]
    pub gridDimY: ::std::os::raw::c_uint,
    #[doc = "< Depth of grid in blocks"]
    pub gridDimZ: ::std::os::raw::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::std::os::raw::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::std::os::raw::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::std::os::raw::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Array of pointers to kernel parameters"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Extra options"]
    pub extra: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Kernel to launch, will only be referenced if func is NULL"]
    pub kern: CUkernel,
    #[doc = "< Context for the kernel task to run in. The value NULL will indicate the current context should be used by the api. This field is ignored if func is set."]
    pub ctx: CUcontext,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_v2_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_KERNEL_NODE_PARAMS_v2_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_v2_st>(),
        72usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_v2_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kern) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(kern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(ctx)
        )
    );
}
#[doc = " GPU kernel node parameters"]
pub type CUDA_KERNEL_NODE_PARAMS_v2 = CUDA_KERNEL_NODE_PARAMS_v2_st;
#[doc = " GPU kernel node parameters"]
pub type CUDA_KERNEL_NODE_PARAMS = CUDA_KERNEL_NODE_PARAMS_v2;
#[doc = " Memset node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMSET_NODE_PARAMS_st {
    #[doc = "< Destination device pointer"]
    pub dst: CUdeviceptr,
    #[doc = "< Pitch of destination device pointer. Unused if height is 1"]
    pub pitch: usize,
    #[doc = "< Value to be set"]
    pub value: ::std::os::raw::c_uint,
    #[doc = "< Size of each element in bytes. Must be 1, 2, or 4."]
    pub elementSize: ::std::os::raw::c_uint,
    #[doc = "< Width of the row in elements"]
    pub width: usize,
    #[doc = "< Number of rows"]
    pub height: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMSET_NODE_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_MEMSET_NODE_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Memset node parameters"]
pub type CUDA_MEMSET_NODE_PARAMS_v1 = CUDA_MEMSET_NODE_PARAMS_st;
#[doc = " Memset node parameters"]
pub type CUDA_MEMSET_NODE_PARAMS = CUDA_MEMSET_NODE_PARAMS_v1;
#[doc = " Host node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_HOST_NODE_PARAMS_st {
    #[doc = "< The function to call when the node executes"]
    pub fn_: CUhostFn,
    #[doc = "< Argument to pass to the function"]
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_HOST_NODE_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_HOST_NODE_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_HOST_NODE_PARAMS_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_HOST_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(userData)
        )
    );
}
#[doc = " Host node parameters"]
pub type CUDA_HOST_NODE_PARAMS_v1 = CUDA_HOST_NODE_PARAMS_st;
#[doc = " Host node parameters"]
pub type CUDA_HOST_NODE_PARAMS = CUDA_HOST_NODE_PARAMS_v1;
#[doc = "< GPU kernel node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_KERNEL: CUgraphNodeType_enum = 0;
#[doc = "< Memcpy node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEMCPY: CUgraphNodeType_enum = 1;
#[doc = "< Memset node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEMSET: CUgraphNodeType_enum = 2;
#[doc = "< Host (executable) node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_HOST: CUgraphNodeType_enum = 3;
#[doc = "< Node which executes an embedded graph"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_GRAPH: CUgraphNodeType_enum = 4;
#[doc = "< Empty (no-op) node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EMPTY: CUgraphNodeType_enum = 5;
#[doc = "< External event wait node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_WAIT_EVENT: CUgraphNodeType_enum = 6;
#[doc = "< External event record node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EVENT_RECORD: CUgraphNodeType_enum = 7;
#[doc = "< External semaphore signal node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL: CUgraphNodeType_enum = 8;
#[doc = "< External semaphore wait node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT: CUgraphNodeType_enum = 9;
#[doc = "< Memory Allocation Node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEM_ALLOC: CUgraphNodeType_enum = 10;
#[doc = "< Memory Free Node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_MEM_FREE: CUgraphNodeType_enum = 11;
#[doc = "< Batch MemOp Node"]
pub const CUgraphNodeType_enum_CU_GRAPH_NODE_TYPE_BATCH_MEM_OP: CUgraphNodeType_enum = 12;
#[doc = " Graph node types"]
pub type CUgraphNodeType_enum = ::std::os::raw::c_int;
#[doc = " Graph node types"]
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
#[doc = "< Instantiation succeeded"]
pub const CUgraphInstantiateResult_enum_CUDA_GRAPH_INSTANTIATE_SUCCESS:
    CUgraphInstantiateResult_enum = 0;
#[doc = "< Instantiation failed for an unexpected reason which is described in the return value of the function"]
pub const CUgraphInstantiateResult_enum_CUDA_GRAPH_INSTANTIATE_ERROR:
    CUgraphInstantiateResult_enum = 1;
#[doc = "< Instantiation failed due to invalid structure, such as cycles"]
pub const CUgraphInstantiateResult_enum_CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE:
    CUgraphInstantiateResult_enum = 2;
#[doc = "< Instantiation for device launch failed because the graph contained an unsupported operation"]
pub const CUgraphInstantiateResult_enum_CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED:
    CUgraphInstantiateResult_enum = 3;
#[doc = "< Instantiation for device launch failed due to the nodes belonging to different contexts"]
pub const CUgraphInstantiateResult_enum_CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED:
    CUgraphInstantiateResult_enum = 4;
#[doc = " Graph instantiation results"]
pub type CUgraphInstantiateResult_enum = ::std::os::raw::c_int;
#[doc = " Graph instantiation results"]
pub use self::CUgraphInstantiateResult_enum as CUgraphInstantiateResult;
#[doc = " Graph instantiation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_GRAPH_INSTANTIATE_PARAMS_st {
    #[doc = "< Instantiation flags"]
    pub flags: cuuint64_t,
    #[doc = "< Upload stream"]
    pub hUploadStream: CUstream,
    #[doc = "< The node which caused instantiation to fail, if any"]
    pub hErrNode_out: CUgraphNode,
    #[doc = "< Whether instantiation was successful.  If it failed, the reason why"]
    pub result_out: CUgraphInstantiateResult,
}
#[test]
fn bindgen_test_layout_CUDA_GRAPH_INSTANTIATE_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_GRAPH_INSTANTIATE_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_GRAPH_INSTANTIATE_PARAMS_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_GRAPH_INSTANTIATE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hUploadStream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st),
            "::",
            stringify!(hUploadStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hErrNode_out) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st),
            "::",
            stringify!(hErrNode_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st),
            "::",
            stringify!(result_out)
        )
    );
}
#[doc = " Graph instantiation parameters"]
pub type CUDA_GRAPH_INSTANTIATE_PARAMS = CUDA_GRAPH_INSTANTIATE_PARAMS_st;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_AUTO: CUsynchronizationPolicy_enum = 1;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_SPIN: CUsynchronizationPolicy_enum = 2;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_YIELD: CUsynchronizationPolicy_enum = 3;
pub const CUsynchronizationPolicy_enum_CU_SYNC_POLICY_BLOCKING_SYNC: CUsynchronizationPolicy_enum =
    4;
pub type CUsynchronizationPolicy_enum = ::std::os::raw::c_int;
pub use self::CUsynchronizationPolicy_enum as CUsynchronizationPolicy;
#[doc = "< the default policy"]
pub const CUclusterSchedulingPolicy_enum_CU_CLUSTER_SCHEDULING_POLICY_DEFAULT:
    CUclusterSchedulingPolicy_enum = 0;
#[doc = "< spread the blocks within a cluster to the SMs"]
pub const CUclusterSchedulingPolicy_enum_CU_CLUSTER_SCHEDULING_POLICY_SPREAD:
    CUclusterSchedulingPolicy_enum = 1;
#[doc = "< allow the hardware to load-balance the blocks in a cluster to the SMs"]
pub const CUclusterSchedulingPolicy_enum_CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING:
    CUclusterSchedulingPolicy_enum = 2;
#[doc = " Cluster scheduling policies. These may be passed to ::cuFuncSetAttribute or ::cuKernelSetAttribute"]
pub type CUclusterSchedulingPolicy_enum = ::std::os::raw::c_int;
#[doc = " Cluster scheduling policies. These may be passed to ::cuFuncSetAttribute or ::cuKernelSetAttribute"]
pub use self::CUclusterSchedulingPolicy_enum as CUclusterSchedulingPolicy;
pub const CUlaunchMemSyncDomain_enum_CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT: CUlaunchMemSyncDomain_enum =
    0;
pub const CUlaunchMemSyncDomain_enum_CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE: CUlaunchMemSyncDomain_enum =
    1;
pub type CUlaunchMemSyncDomain_enum = ::std::os::raw::c_int;
pub use self::CUlaunchMemSyncDomain_enum as CUlaunchMemSyncDomain;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchMemSyncDomainMap_st {
    pub default_: ::std::os::raw::c_uchar,
    pub remote: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_CUlaunchMemSyncDomainMap_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUlaunchMemSyncDomainMap_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUlaunchMemSyncDomainMap_st>(),
        2usize,
        concat!("Size of: ", stringify!(CUlaunchMemSyncDomainMap_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUlaunchMemSyncDomainMap_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUlaunchMemSyncDomainMap_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchMemSyncDomainMap_st),
            "::",
            stringify!(default_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchMemSyncDomainMap_st),
            "::",
            stringify!(remote)
        )
    );
}
pub type CUlaunchMemSyncDomainMap = CUlaunchMemSyncDomainMap_st;
#[doc = "< Ignored entry, for convenient composition"]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_IGNORE: CUlaunchAttributeID_enum = 0;
#[doc = "< Valid for streams, graph nodes, launches."]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW:
    CUlaunchAttributeID_enum = 1;
#[doc = "< Valid for graph nodes, launches."]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_COOPERATIVE: CUlaunchAttributeID_enum = 2;
#[doc = "< Valid for streams."]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY:
    CUlaunchAttributeID_enum = 3;
#[doc = "< Valid for graph nodes, launches."]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION: CUlaunchAttributeID_enum =
    4;
#[doc = "< Valid for graph nodes, launches."]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE:
    CUlaunchAttributeID_enum = 5;
#[doc = "< Valid for launches. Setting\nprogrammaticStreamSerializationAllowed to non-0\nsignals that the kernel will use programmatic\nmeans to resolve its stream dependency, so that\nthe CUDA runtime should opportunistically allow\nthe grid's execution to overlap with the previous\nkernel in the stream, if that kernel requests the\noverlap. The dependent launches can choose to wait\non the dependency using the programmatic sync\n(cudaGridDependencySynchronize() or equivalent PTX\ninstructions)."]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION:
    CUlaunchAttributeID_enum = 6;
#[doc = "< Valid for launches. Event recorded through this\nlaunch attribute is guaranteed to only trigger\nafter all block in the associated kernel trigger\nthe event. A block can trigger the event through\nPTX launchdep.release or CUDA builtin function\ncudaTriggerProgrammaticLaunchCompletion(). A\ntrigger can also be inserted at the beginning of\neach block's execution if triggerAtBlockStart is\nset to non-0. The dependent launches can choose to\nwait on the dependency using the programmatic sync\n(cudaGridDependencySynchronize() or equivalent PTX\ninstructions). Note that dependents (including the\nCPU thread calling cuEventSynchronize()) are not\nguaranteed to observe the release precisely when\nit is released.  For example, cuEventSynchronize()\nmay only observe the event trigger long after the\nassociated kernel has completed. This recording\ntype is primarily meant for establishing\nprogrammatic dependency between device tasks. The\nevent supplied must not be an interprocess or\ninterop event. The event must disable timing (i.e.\ncreated with ::CU_EVENT_DISABLE_TIMING flag set)."]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT:
    CUlaunchAttributeID_enum = 7;
#[doc = "< Valid for streams, graph nodes, launches."]
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_PRIORITY: CUlaunchAttributeID_enum = 8;
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP:
    CUlaunchAttributeID_enum = 9;
pub const CUlaunchAttributeID_enum_CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN: CUlaunchAttributeID_enum =
    10;
pub type CUlaunchAttributeID_enum = ::std::os::raw::c_int;
pub use self::CUlaunchAttributeID_enum as CUlaunchAttributeID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUlaunchAttributeValue_union {
    #[doc = "< Pad to 64 bytes"]
    pub pad: [::std::os::raw::c_char; 64usize],
    #[doc = "< Attribute ::CUaccessPolicyWindow."]
    pub accessPolicyWindow: CUaccessPolicyWindow,
    #[doc = "< Nonzero indicates a cooperative kernel (see ::cuLaunchCooperativeKernel)."]
    pub cooperative: ::std::os::raw::c_int,
    #[doc = "< ::CUsynchronizationPolicy for work queued up in this stream"]
    pub syncPolicy: CUsynchronizationPolicy,
    #[doc = "< Cluster dimensions for the kernel node."]
    pub clusterDim: CUlaunchAttributeValue_union__bindgen_ty_1,
    #[doc = "< Cluster scheduling policy preference for the kernel node."]
    pub clusterSchedulingPolicyPreference: CUclusterSchedulingPolicy,
    pub programmaticStreamSerializationAllowed: ::std::os::raw::c_int,
    pub programmaticEvent: CUlaunchAttributeValue_union__bindgen_ty_2,
    #[doc = "< Execution priority of the kernel."]
    pub priority: ::std::os::raw::c_int,
    pub memSyncDomainMap: CUlaunchMemSyncDomainMap,
    pub memSyncDomain: CUlaunchMemSyncDomain,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_1 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUlaunchAttributeValue_union__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUlaunchAttributeValue_union__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_2 {
    pub event: CUevent,
    pub flags: ::std::os::raw::c_int,
    pub triggerAtBlockStart: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUlaunchAttributeValue_union__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<CUlaunchAttributeValue_union__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).triggerAtBlockStart) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2),
            "::",
            stringify!(triggerAtBlockStart)
        )
    );
}
#[test]
fn bindgen_test_layout_CUlaunchAttributeValue_union() {
    const UNINIT: ::std::mem::MaybeUninit<CUlaunchAttributeValue_union> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUlaunchAttributeValue_union>(),
        64usize,
        concat!("Size of: ", stringify!(CUlaunchAttributeValue_union))
    );
    assert_eq!(
        ::std::mem::align_of::<CUlaunchAttributeValue_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUlaunchAttributeValue_union))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cooperative) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(cooperative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncPolicy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(syncPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clusterDim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(clusterDim)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).clusterSchedulingPolicyPreference) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(clusterSchedulingPolicyPreference)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).programmaticStreamSerializationAllowed) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(programmaticStreamSerializationAllowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).programmaticEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(programmaticEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memSyncDomainMap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(memSyncDomainMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memSyncDomain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(memSyncDomain)
        )
    );
}
pub type CUlaunchAttributeValue = CUlaunchAttributeValue_union;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUlaunchAttribute_st {
    pub id: CUlaunchAttributeID,
    pub pad: [::std::os::raw::c_char; 4usize],
    pub value: CUlaunchAttributeValue,
}
#[test]
fn bindgen_test_layout_CUlaunchAttribute_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUlaunchAttribute_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUlaunchAttribute_st>(),
        72usize,
        concat!("Size of: ", stringify!(CUlaunchAttribute_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUlaunchAttribute_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUlaunchAttribute_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttribute_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttribute_st),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttribute_st),
            "::",
            stringify!(value)
        )
    );
}
pub type CUlaunchAttribute = CUlaunchAttribute_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchConfig_st {
    #[doc = "< Width of grid in blocks"]
    pub gridDimX: ::std::os::raw::c_uint,
    #[doc = "< Height of grid in blocks"]
    pub gridDimY: ::std::os::raw::c_uint,
    #[doc = "< Depth of grid in blocks"]
    pub gridDimZ: ::std::os::raw::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::std::os::raw::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::std::os::raw::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::std::os::raw::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Stream identifier"]
    pub hStream: CUstream,
    #[doc = "< nullable if numAttrs == 0"]
    pub attrs: *mut CUlaunchAttribute,
    #[doc = "< number of attributes populated in attrs"]
    pub numAttrs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUlaunchConfig_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUlaunchConfig_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUlaunchConfig_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUlaunchConfig_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUlaunchConfig_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUlaunchConfig_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hStream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(hStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAttrs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(numAttrs)
        )
    );
}
pub type CUlaunchConfig = CUlaunchConfig_st;
#[doc = " Graph kernel node Attributes"]
pub use self::CUlaunchAttributeID as CUkernelNodeAttrID;
#[doc = " Graph kernel node attributes union, used with ::cuKernelNodeSetAttribute/::cuKernelNodeGetAttribute"]
pub type CUkernelNodeAttrValue_v1 = CUlaunchAttributeValue;
pub type CUkernelNodeAttrValue = CUkernelNodeAttrValue_v1;
#[doc = "< Stream is not capturing"]
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_NONE: CUstreamCaptureStatus_enum = 0;
#[doc = "< Stream is actively capturing"]
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_ACTIVE: CUstreamCaptureStatus_enum =
    1;
#[doc = "< Stream is part of a capture sequence that\nhas been invalidated, but not terminated"]
pub const CUstreamCaptureStatus_enum_CU_STREAM_CAPTURE_STATUS_INVALIDATED:
    CUstreamCaptureStatus_enum = 2;
#[doc = " Possible stream capture statuses returned by ::cuStreamIsCapturing"]
pub type CUstreamCaptureStatus_enum = ::std::os::raw::c_int;
#[doc = " Possible stream capture statuses returned by ::cuStreamIsCapturing"]
pub use self::CUstreamCaptureStatus_enum as CUstreamCaptureStatus;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_GLOBAL: CUstreamCaptureMode_enum = 0;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_THREAD_LOCAL: CUstreamCaptureMode_enum =
    1;
pub const CUstreamCaptureMode_enum_CU_STREAM_CAPTURE_MODE_RELAXED: CUstreamCaptureMode_enum = 2;
#[doc = " Possible modes for stream capture thread interactions. For more details see\n ::cuStreamBeginCapture and ::cuThreadExchangeStreamCaptureMode"]
pub type CUstreamCaptureMode_enum = ::std::os::raw::c_int;
#[doc = " Stream Attributes"]
pub use self::CUlaunchAttributeID as CUstreamAttrID;
#[doc = " Possible modes for stream capture thread interactions. For more details see\n ::cuStreamBeginCapture and ::cuThreadExchangeStreamCaptureMode"]
pub use self::CUstreamCaptureMode_enum as CUstreamCaptureMode;
#[doc = " Stream attributes union, used with ::cuStreamSetAttribute/::cuStreamGetAttribute"]
pub type CUstreamAttrValue_v1 = CUlaunchAttributeValue;
pub type CUstreamAttrValue = CUstreamAttrValue_v1;
#[doc = "< Default search mode for driver symbols."]
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_DEFAULT:
    CUdriverProcAddress_flags_enum = 0;
#[doc = "< Search for legacy versions of driver symbols."]
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_LEGACY_STREAM:
    CUdriverProcAddress_flags_enum = 1;
#[doc = "< Search for per-thread versions of driver symbols."]
pub const CUdriverProcAddress_flags_enum_CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM:
    CUdriverProcAddress_flags_enum = 2;
#[doc = " Flags to specify search options. For more details see ::cuGetProcAddress"]
pub type CUdriverProcAddress_flags_enum = ::std::os::raw::c_int;
#[doc = " Flags to specify search options. For more details see ::cuGetProcAddress"]
pub use self::CUdriverProcAddress_flags_enum as CUdriverProcAddress_flags;
#[doc = "< Symbol was succesfully found"]
pub const CUdriverProcAddressQueryResult_enum_CU_GET_PROC_ADDRESS_SUCCESS:
    CUdriverProcAddressQueryResult_enum = 0;
#[doc = "< Symbol was not found in search"]
pub const CUdriverProcAddressQueryResult_enum_CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND:
    CUdriverProcAddressQueryResult_enum = 1;
#[doc = "< Symbol was found but version supplied was not sufficient"]
pub const CUdriverProcAddressQueryResult_enum_CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT:
    CUdriverProcAddressQueryResult_enum = 2;
#[doc = " Flags to indicate search status. For more details see ::cuGetProcAddress"]
pub type CUdriverProcAddressQueryResult_enum = ::std::os::raw::c_int;
#[doc = " Flags to indicate search status. For more details see ::cuGetProcAddress"]
pub use self::CUdriverProcAddressQueryResult_enum as CUdriverProcAddressQueryResult;
#[doc = "< Create a context with limited SMs."]
pub const CUexecAffinityType_enum_CU_EXEC_AFFINITY_TYPE_SM_COUNT: CUexecAffinityType_enum = 0;
pub const CUexecAffinityType_enum_CU_EXEC_AFFINITY_TYPE_MAX: CUexecAffinityType_enum = 1;
#[doc = " Execution Affinity Types"]
pub type CUexecAffinityType_enum = ::std::os::raw::c_int;
#[doc = " Execution Affinity Types"]
pub use self::CUexecAffinityType_enum as CUexecAffinityType;
#[doc = " Value for ::CU_EXEC_AFFINITY_TYPE_SM_COUNT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUexecAffinitySmCount_st {
    #[doc = "< The number of SMs the context is limited to use."]
    pub val: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUexecAffinitySmCount_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUexecAffinitySmCount_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Size of: ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinitySmCount_st),
            "::",
            stringify!(val)
        )
    );
}
#[doc = " Value for ::CU_EXEC_AFFINITY_TYPE_SM_COUNT"]
pub type CUexecAffinitySmCount_v1 = CUexecAffinitySmCount_st;
#[doc = " Value for ::CU_EXEC_AFFINITY_TYPE_SM_COUNT"]
pub type CUexecAffinitySmCount = CUexecAffinitySmCount_v1;
#[doc = " Execution Affinity Parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUexecAffinityParam_st {
    pub type_: CUexecAffinityType,
    pub param: CUexecAffinityParam_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUexecAffinityParam_st__bindgen_ty_1 {
    pub smCount: CUexecAffinitySmCount,
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUexecAffinityParam_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1),
            "::",
            stringify!(smCount)
        )
    );
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUexecAffinityParam_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUexecAffinityParam_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUexecAffinityParam_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st),
            "::",
            stringify!(param)
        )
    );
}
#[doc = " Execution Affinity Parameters"]
pub type CUexecAffinityParam_v1 = CUexecAffinityParam_st;
#[doc = " Execution Affinity Parameters"]
pub type CUexecAffinityParam = CUexecAffinityParam_v1;
pub const CUlibraryOption_enum_CU_LIBRARY_HOST_UNIVERSAL_FUNCTION_AND_DATA_TABLE:
    CUlibraryOption_enum = 0;
#[doc = " Specifes that the argument \\p code passed to ::cuLibraryLoadData() will be preserved.\n Specifying this option will let the driver know that \\p code can be accessed at any point\n until ::cuLibraryUnload(). The default behavior is for the driver to allocate and\n maintain its own copy of \\p code. Note that this is only a memory usage optimization\n hint and the driver can choose to ignore it if required.\n Specifying this option with ::cuLibraryLoadFromFile() is invalid and\n will return ::CUDA_ERROR_INVALID_VALUE."]
pub const CUlibraryOption_enum_CU_LIBRARY_BINARY_IS_PRESERVED: CUlibraryOption_enum = 1;
#[doc = " Specifes that the argument \\p code passed to ::cuLibraryLoadData() will be preserved.\n Specifying this option will let the driver know that \\p code can be accessed at any point\n until ::cuLibraryUnload(). The default behavior is for the driver to allocate and\n maintain its own copy of \\p code. Note that this is only a memory usage optimization\n hint and the driver can choose to ignore it if required.\n Specifying this option with ::cuLibraryLoadFromFile() is invalid and\n will return ::CUDA_ERROR_INVALID_VALUE."]
pub const CUlibraryOption_enum_CU_LIBRARY_NUM_OPTIONS: CUlibraryOption_enum = 2;
#[doc = " Library options to be specified with ::cuLibraryLoadData() or ::cuLibraryLoadFromFile()"]
pub type CUlibraryOption_enum = ::std::os::raw::c_int;
#[doc = " Library options to be specified with ::cuLibraryLoadData() or ::cuLibraryLoadFromFile()"]
pub use self::CUlibraryOption_enum as CUlibraryOption;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlibraryHostUniversalFunctionAndDataTable_st {
    pub functionTable: *mut ::std::os::raw::c_void,
    pub functionWindowSize: usize,
    pub dataTable: *mut ::std::os::raw::c_void,
    pub dataWindowSize: usize,
}
#[test]
fn bindgen_test_layout_CUlibraryHostUniversalFunctionAndDataTable_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUlibraryHostUniversalFunctionAndDataTable_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUlibraryHostUniversalFunctionAndDataTable_st>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUlibraryHostUniversalFunctionAndDataTable_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).functionTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st),
            "::",
            stringify!(functionTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).functionWindowSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st),
            "::",
            stringify!(functionWindowSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataTable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st),
            "::",
            stringify!(dataTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataWindowSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st),
            "::",
            stringify!(dataWindowSize)
        )
    );
}
pub type CUlibraryHostUniversalFunctionAndDataTable = CUlibraryHostUniversalFunctionAndDataTable_st;
#[doc = " The API call returned with no errors. In the case of query calls, this\n also means that the operation being queried is complete (see\n ::cuEventQuery() and ::cuStreamQuery())."]
pub const cudaError_enum_CUDA_SUCCESS: cudaError_enum = 0;
#[doc = " This indicates that one or more of the parameters passed to the API call\n is not within an acceptable range of values."]
pub const cudaError_enum_CUDA_ERROR_INVALID_VALUE: cudaError_enum = 1;
#[doc = " The API call failed because it was unable to allocate enough memory to\n perform the requested operation."]
pub const cudaError_enum_CUDA_ERROR_OUT_OF_MEMORY: cudaError_enum = 2;
#[doc = " This indicates that the CUDA driver has not been initialized with\n ::cuInit() or that initialization has failed."]
pub const cudaError_enum_CUDA_ERROR_NOT_INITIALIZED: cudaError_enum = 3;
#[doc = " This indicates that the CUDA driver is in the process of shutting down."]
pub const cudaError_enum_CUDA_ERROR_DEINITIALIZED: cudaError_enum = 4;
#[doc = " This indicates profiler is not initialized for this run. This can\n happen when the application is running with external profiling tools\n like visual profiler."]
pub const cudaError_enum_CUDA_ERROR_PROFILER_DISABLED: cudaError_enum = 5;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to attempt to enable/disable the profiling via ::cuProfilerStart or\n ::cuProfilerStop without initialization."]
pub const cudaError_enum_CUDA_ERROR_PROFILER_NOT_INITIALIZED: cudaError_enum = 6;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cuProfilerStart() when profiling is already enabled."]
pub const cudaError_enum_CUDA_ERROR_PROFILER_ALREADY_STARTED: cudaError_enum = 7;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cuProfilerStop() when profiling is already disabled."]
pub const cudaError_enum_CUDA_ERROR_PROFILER_ALREADY_STOPPED: cudaError_enum = 8;
#[doc = " This indicates that the CUDA driver that the application has loaded is a\n stub library. Applications that run with the stub rather than a real\n driver loaded will result in CUDA API returning this error."]
pub const cudaError_enum_CUDA_ERROR_STUB_LIBRARY: cudaError_enum = 34;
#[doc = " This indicates that requested CUDA device is unavailable at the current\n time. Devices are often unavailable due to use of\n ::CU_COMPUTEMODE_EXCLUSIVE_PROCESS or ::CU_COMPUTEMODE_PROHIBITED."]
pub const cudaError_enum_CUDA_ERROR_DEVICE_UNAVAILABLE: cudaError_enum = 46;
#[doc = " This indicates that no CUDA-capable devices were detected by the installed\n CUDA driver."]
pub const cudaError_enum_CUDA_ERROR_NO_DEVICE: cudaError_enum = 100;
#[doc = " This indicates that the device ordinal supplied by the user does not\n correspond to a valid CUDA device or that the action requested is\n invalid for the specified device."]
pub const cudaError_enum_CUDA_ERROR_INVALID_DEVICE: cudaError_enum = 101;
#[doc = " This error indicates that the Grid license is not applied."]
pub const cudaError_enum_CUDA_ERROR_DEVICE_NOT_LICENSED: cudaError_enum = 102;
#[doc = " This indicates that the device kernel image is invalid. This can also\n indicate an invalid CUDA module."]
pub const cudaError_enum_CUDA_ERROR_INVALID_IMAGE: cudaError_enum = 200;
#[doc = " This most frequently indicates that there is no context bound to the\n current thread. This can also be returned if the context passed to an\n API call is not a valid handle (such as a context that has had\n ::cuCtxDestroy() invoked on it). This can also be returned if a user\n mixes different API versions (i.e. 3010 context with 3020 API calls).\n See ::cuCtxGetApiVersion() for more details."]
pub const cudaError_enum_CUDA_ERROR_INVALID_CONTEXT: cudaError_enum = 201;
#[doc = " This indicated that the context being supplied as a parameter to the\n API call was already the active context.\n \\deprecated\n This error return is deprecated as of CUDA 3.2. It is no longer an\n error to attempt to push the active context via ::cuCtxPushCurrent()."]
pub const cudaError_enum_CUDA_ERROR_CONTEXT_ALREADY_CURRENT: cudaError_enum = 202;
#[doc = " This indicates that a map or register operation has failed."]
pub const cudaError_enum_CUDA_ERROR_MAP_FAILED: cudaError_enum = 205;
#[doc = " This indicates that an unmap or unregister operation has failed."]
pub const cudaError_enum_CUDA_ERROR_UNMAP_FAILED: cudaError_enum = 206;
#[doc = " This indicates that the specified array is currently mapped and thus\n cannot be destroyed."]
pub const cudaError_enum_CUDA_ERROR_ARRAY_IS_MAPPED: cudaError_enum = 207;
#[doc = " This indicates that the resource is already mapped."]
pub const cudaError_enum_CUDA_ERROR_ALREADY_MAPPED: cudaError_enum = 208;
#[doc = " This indicates that there is no kernel image available that is suitable\n for the device. This can occur when a user specifies code generation\n options for a particular CUDA source file that do not include the\n corresponding device configuration."]
pub const cudaError_enum_CUDA_ERROR_NO_BINARY_FOR_GPU: cudaError_enum = 209;
#[doc = " This indicates that a resource has already been acquired."]
pub const cudaError_enum_CUDA_ERROR_ALREADY_ACQUIRED: cudaError_enum = 210;
#[doc = " This indicates that a resource is not mapped."]
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED: cudaError_enum = 211;
#[doc = " This indicates that a mapped resource is not available for access as an\n array."]
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED_AS_ARRAY: cudaError_enum = 212;
#[doc = " This indicates that a mapped resource is not available for access as a\n pointer."]
pub const cudaError_enum_CUDA_ERROR_NOT_MAPPED_AS_POINTER: cudaError_enum = 213;
#[doc = " This indicates that an uncorrectable ECC error was detected during\n execution."]
pub const cudaError_enum_CUDA_ERROR_ECC_UNCORRECTABLE: cudaError_enum = 214;
#[doc = " This indicates that the ::CUlimit passed to the API call is not\n supported by the active device."]
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_LIMIT: cudaError_enum = 215;
#[doc = " This indicates that the ::CUcontext passed to the API call can\n only be bound to a single CPU thread at a time but is already\n bound to a CPU thread."]
pub const cudaError_enum_CUDA_ERROR_CONTEXT_ALREADY_IN_USE: cudaError_enum = 216;
#[doc = " This indicates that peer access is not supported across the given\n devices."]
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_UNSUPPORTED: cudaError_enum = 217;
#[doc = " This indicates that a PTX JIT compilation failed."]
pub const cudaError_enum_CUDA_ERROR_INVALID_PTX: cudaError_enum = 218;
#[doc = " This indicates an error with OpenGL or DirectX context."]
pub const cudaError_enum_CUDA_ERROR_INVALID_GRAPHICS_CONTEXT: cudaError_enum = 219;
#[doc = " This indicates that an uncorrectable NVLink error was detected during the\n execution."]
pub const cudaError_enum_CUDA_ERROR_NVLINK_UNCORRECTABLE: cudaError_enum = 220;
#[doc = " This indicates that the PTX JIT compiler library was not found."]
pub const cudaError_enum_CUDA_ERROR_JIT_COMPILER_NOT_FOUND: cudaError_enum = 221;
#[doc = " This indicates that the provided PTX was compiled with an unsupported toolchain."]
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_PTX_VERSION: cudaError_enum = 222;
#[doc = " This indicates that the PTX JIT compilation was disabled."]
pub const cudaError_enum_CUDA_ERROR_JIT_COMPILATION_DISABLED: cudaError_enum = 223;
#[doc = " This indicates that the ::CUexecAffinityType passed to the API call is not\n supported by the active device."]
pub const cudaError_enum_CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY: cudaError_enum = 224;
#[doc = " This indicates that the device kernel source is invalid. This includes\n compilation/linker errors encountered in device code or user error."]
pub const cudaError_enum_CUDA_ERROR_INVALID_SOURCE: cudaError_enum = 300;
#[doc = " This indicates that the file specified was not found."]
pub const cudaError_enum_CUDA_ERROR_FILE_NOT_FOUND: cudaError_enum = 301;
#[doc = " This indicates that a link to a shared object failed to resolve."]
pub const cudaError_enum_CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND: cudaError_enum = 302;
#[doc = " This indicates that initialization of a shared object failed."]
pub const cudaError_enum_CUDA_ERROR_SHARED_OBJECT_INIT_FAILED: cudaError_enum = 303;
#[doc = " This indicates that an OS call failed."]
pub const cudaError_enum_CUDA_ERROR_OPERATING_SYSTEM: cudaError_enum = 304;
#[doc = " This indicates that a resource handle passed to the API call was not\n valid. Resource handles are opaque types like ::CUstream and ::CUevent."]
pub const cudaError_enum_CUDA_ERROR_INVALID_HANDLE: cudaError_enum = 400;
#[doc = " This indicates that a resource required by the API call is not in a\n valid state to perform the requested operation."]
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_STATE: cudaError_enum = 401;
#[doc = " This indicates that a named symbol was not found. Examples of symbols\n are global/constant variable names, driver function names, texture names,\n and surface names."]
pub const cudaError_enum_CUDA_ERROR_NOT_FOUND: cudaError_enum = 500;
#[doc = " This indicates that asynchronous operations issued previously have not\n completed yet. This result is not actually an error, but must be indicated\n differently than ::CUDA_SUCCESS (which indicates completion). Calls that\n may return this value include ::cuEventQuery() and ::cuStreamQuery()."]
pub const cudaError_enum_CUDA_ERROR_NOT_READY: cudaError_enum = 600;
#[doc = " While executing a kernel, the device encountered a\n load or store instruction on an invalid memory address.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_ADDRESS: cudaError_enum = 700;
#[doc = " This indicates that a launch did not occur because it did not have\n appropriate resources. This error usually indicates that the user has\n attempted to pass too many arguments to the device kernel, or the\n kernel launch specifies too many threads for the kernel's register\n count. Passing arguments of the wrong size (i.e. a 64-bit pointer\n when a 32-bit int is expected) is equivalent to passing too many\n arguments and can also result in this error."]
pub const cudaError_enum_CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES: cudaError_enum = 701;
#[doc = " This indicates that the device kernel took too long to execute. This can\n only occur if timeouts are enabled - see the device attribute\n ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_enum_CUDA_ERROR_LAUNCH_TIMEOUT: cudaError_enum = 702;
#[doc = " This error indicates a kernel launch that uses an incompatible texturing\n mode."]
pub const cudaError_enum_CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING: cudaError_enum = 703;
#[doc = " This error indicates that a call to ::cuCtxEnablePeerAccess() is\n trying to re-enable peer access to a context which has already\n had peer access to it enabled."]
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED: cudaError_enum = 704;
#[doc = " This error indicates that ::cuCtxDisablePeerAccess() is\n trying to disable peer access which has not been enabled yet\n via ::cuCtxEnablePeerAccess()."]
pub const cudaError_enum_CUDA_ERROR_PEER_ACCESS_NOT_ENABLED: cudaError_enum = 705;
#[doc = " This error indicates that the primary context for the specified device\n has already been initialized."]
pub const cudaError_enum_CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE: cudaError_enum = 708;
#[doc = " This error indicates that the context current to the calling thread\n has been destroyed using ::cuCtxDestroy, or is a primary context which\n has not yet been initialized."]
pub const cudaError_enum_CUDA_ERROR_CONTEXT_IS_DESTROYED: cudaError_enum = 709;
#[doc = " A device-side assert triggered during kernel execution. The context\n cannot be used anymore, and must be destroyed. All existing device\n memory allocations from this context are invalid and must be\n reconstructed if the program is to continue using CUDA."]
pub const cudaError_enum_CUDA_ERROR_ASSERT: cudaError_enum = 710;
#[doc = " This error indicates that the hardware resources required to enable\n peer access have been exhausted for one or more of the devices\n passed to ::cuCtxEnablePeerAccess()."]
pub const cudaError_enum_CUDA_ERROR_TOO_MANY_PEERS: cudaError_enum = 711;
#[doc = " This error indicates that the memory range passed to ::cuMemHostRegister()\n has already been registered."]
pub const cudaError_enum_CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED: cudaError_enum = 712;
#[doc = " This error indicates that the pointer passed to ::cuMemHostUnregister()\n does not correspond to any currently registered memory region."]
pub const cudaError_enum_CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED: cudaError_enum = 713;
#[doc = " While executing a kernel, the device encountered a stack error.\n This can be due to stack corruption or exceeding the stack size limit.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_enum_CUDA_ERROR_HARDWARE_STACK_ERROR: cudaError_enum = 714;
#[doc = " While executing a kernel, the device encountered an illegal instruction.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_enum_CUDA_ERROR_ILLEGAL_INSTRUCTION: cudaError_enum = 715;
#[doc = " While executing a kernel, the device encountered a load or store instruction\n on a memory address which is not aligned.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_enum_CUDA_ERROR_MISALIGNED_ADDRESS: cudaError_enum = 716;
#[doc = " While executing a kernel, the device encountered an instruction\n which can only operate on memory locations in certain address spaces\n (global, shared, or local), but was supplied a memory address not\n belonging to an allowed address space.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_enum_CUDA_ERROR_INVALID_ADDRESS_SPACE: cudaError_enum = 717;
#[doc = " While executing a kernel, the device program counter wrapped its address space.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_enum_CUDA_ERROR_INVALID_PC: cudaError_enum = 718;
#[doc = " An exception occurred on the device while executing a kernel. Common\n causes include dereferencing an invalid device pointer and accessing\n out of bounds shared memory. Less common cases can be system specific - more\n information about these cases can be found in the system specific user guide.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_enum_CUDA_ERROR_LAUNCH_FAILED: cudaError_enum = 719;
#[doc = " This error indicates that the number of blocks launched per grid for a kernel that was\n launched via either ::cuLaunchCooperativeKernel or ::cuLaunchCooperativeKernelMultiDevice\n exceeds the maximum number of blocks as allowed by ::cuOccupancyMaxActiveBlocksPerMultiprocessor\n or ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors\n as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT."]
pub const cudaError_enum_CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE: cudaError_enum = 720;
#[doc = " This error indicates that the attempted operation is not permitted."]
pub const cudaError_enum_CUDA_ERROR_NOT_PERMITTED: cudaError_enum = 800;
#[doc = " This error indicates that the attempted operation is not supported\n on the current system or device."]
pub const cudaError_enum_CUDA_ERROR_NOT_SUPPORTED: cudaError_enum = 801;
#[doc = " This error indicates that the system is not yet ready to start any CUDA\n work.  To continue using CUDA, verify the system configuration is in a\n valid state and all required driver daemons are actively running.\n More information about this error can be found in the system specific\n user guide."]
pub const cudaError_enum_CUDA_ERROR_SYSTEM_NOT_READY: cudaError_enum = 802;
#[doc = " This error indicates that there is a mismatch between the versions of\n the display driver and the CUDA driver. Refer to the compatibility documentation\n for supported versions."]
pub const cudaError_enum_CUDA_ERROR_SYSTEM_DRIVER_MISMATCH: cudaError_enum = 803;
#[doc = " This error indicates that the system was upgraded to run with forward compatibility\n but the visible hardware detected by CUDA does not support this configuration.\n Refer to the compatibility documentation for the supported hardware matrix or ensure\n that only supported hardware is visible during initialization via the CUDA_VISIBLE_DEVICES\n environment variable."]
pub const cudaError_enum_CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE: cudaError_enum = 804;
#[doc = " This error indicates that the MPS client failed to connect to the MPS control daemon or the MPS server."]
pub const cudaError_enum_CUDA_ERROR_MPS_CONNECTION_FAILED: cudaError_enum = 805;
#[doc = " This error indicates that the remote procedural call between the MPS server and the MPS client failed."]
pub const cudaError_enum_CUDA_ERROR_MPS_RPC_FAILURE: cudaError_enum = 806;
#[doc = " This error indicates that the MPS server is not ready to accept new MPS client requests.\n This error can be returned when the MPS server is in the process of recovering from a fatal failure."]
pub const cudaError_enum_CUDA_ERROR_MPS_SERVER_NOT_READY: cudaError_enum = 807;
#[doc = " This error indicates that the hardware resources required to create MPS client have been exhausted."]
pub const cudaError_enum_CUDA_ERROR_MPS_MAX_CLIENTS_REACHED: cudaError_enum = 808;
#[doc = " This error indicates the the hardware resources required to support device connections have been exhausted."]
pub const cudaError_enum_CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED: cudaError_enum = 809;
#[doc = " This error indicates that the MPS client has been terminated by the server. To continue using CUDA, the process must be terminated and relaunched."]
pub const cudaError_enum_CUDA_ERROR_MPS_CLIENT_TERMINATED: cudaError_enum = 810;
#[doc = " This error indicates that the module is using CUDA Dynamic Parallelism, but the current configuration, like MPS, does not support it."]
pub const cudaError_enum_CUDA_ERROR_CDP_NOT_SUPPORTED: cudaError_enum = 811;
#[doc = " This error indicates that a module contains an unsupported interaction between different versions of CUDA Dynamic Parallelism."]
pub const cudaError_enum_CUDA_ERROR_CDP_VERSION_MISMATCH: cudaError_enum = 812;
#[doc = " This error indicates that the operation is not permitted when\n the stream is capturing."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED: cudaError_enum = 900;
#[doc = " This error indicates that the current capture sequence on the stream\n has been invalidated due to a previous error."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_INVALIDATED: cudaError_enum = 901;
#[doc = " This error indicates that the operation would have resulted in a merge\n of two independent capture sequences."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_MERGE: cudaError_enum = 902;
#[doc = " This error indicates that the capture was not initiated in this stream."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNMATCHED: cudaError_enum = 903;
#[doc = " This error indicates that the capture sequence contains a fork that was\n not joined to the primary stream."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_UNJOINED: cudaError_enum = 904;
#[doc = " This error indicates that a dependency would have been created which\n crosses the capture sequence boundary. Only implicit in-stream ordering\n dependencies are allowed to cross the boundary."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_ISOLATION: cudaError_enum = 905;
#[doc = " This error indicates a disallowed implicit dependency on a current capture\n sequence from cudaStreamLegacy."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_IMPLICIT: cudaError_enum = 906;
#[doc = " This error indicates that the operation is not permitted on an event which\n was last recorded in a capturing stream."]
pub const cudaError_enum_CUDA_ERROR_CAPTURED_EVENT: cudaError_enum = 907;
#[doc = " A stream capture sequence not initiated with the ::CU_STREAM_CAPTURE_MODE_RELAXED\n argument to ::cuStreamBeginCapture was passed to ::cuStreamEndCapture in a\n different thread."]
pub const cudaError_enum_CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD: cudaError_enum = 908;
#[doc = " This error indicates that the timeout specified for the wait operation has lapsed."]
pub const cudaError_enum_CUDA_ERROR_TIMEOUT: cudaError_enum = 909;
#[doc = " This error indicates that the graph update was not performed because it included\n changes which violated constraints specific to instantiated graph update."]
pub const cudaError_enum_CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE: cudaError_enum = 910;
#[doc = " This indicates that an async error has occurred in a device outside of CUDA.\n If CUDA was waiting for an external device's signal before consuming shared data,\n the external device signaled an error indicating that the data is not valid for\n consumption. This leaves the process in an inconsistent state and any further CUDA\n work will return the same error. To continue using CUDA, the process must be\n terminated and relaunched."]
pub const cudaError_enum_CUDA_ERROR_EXTERNAL_DEVICE: cudaError_enum = 911;
#[doc = " Indicates a kernel launch error due to cluster misconfiguration."]
pub const cudaError_enum_CUDA_ERROR_INVALID_CLUSTER_SIZE: cudaError_enum = 912;
#[doc = " This indicates that an unknown internal error has occurred."]
pub const cudaError_enum_CUDA_ERROR_UNKNOWN: cudaError_enum = 999;
#[doc = " Error codes"]
pub type cudaError_enum = ::std::os::raw::c_int;
#[doc = " Error codes"]
pub use self::cudaError_enum as CUresult;
#[doc = "< A relative value indicating the performance of the link between two devices"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK:
    CUdevice_P2PAttribute_enum = 1;
#[doc = "< P2P Access is enable"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 2;
#[doc = "< Atomic operation over the link supported"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED:
    CUdevice_P2PAttribute_enum = 3;
#[doc = "< \\deprecated use CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED instead"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 4;
#[doc = "< Accessing CUDA arrays over the link supported"]
pub const CUdevice_P2PAttribute_enum_CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED:
    CUdevice_P2PAttribute_enum = 4;
#[doc = " P2P Attributes"]
pub type CUdevice_P2PAttribute_enum = ::std::os::raw::c_int;
#[doc = " P2P Attributes"]
pub use self::CUdevice_P2PAttribute_enum as CUdevice_P2PAttribute;
#[doc = " CUDA stream callback\n \\param hStream The stream the callback was added to, as passed to ::cuStreamAddCallback.  May be NULL.\n \\param status ::CUDA_SUCCESS or any persistent error on the stream.\n \\param userData User parameter provided at registration."]
pub type CUstreamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        hStream: CUstream,
        status: CUresult,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Block size to per-block dynamic shared memory mapping for a certain\n kernel \\param blockSize Block size of the kernel.\n\n \\return The dynamic shared memory needed by a block."]
pub type CUoccupancyB2DSize =
    ::std::option::Option<unsafe extern "C" fn(blockSize: ::std::os::raw::c_int) -> usize>;
#[doc = " 2D memory copy parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY2D_st {
    #[doc = "< Source X in bytes"]
    pub srcXInBytes: usize,
    #[doc = "< Source Y"]
    pub srcY: usize,
    #[doc = "< Source memory type (host, device, array)"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer"]
    pub srcHost: *const ::std::os::raw::c_void,
    #[doc = "< Source device pointer"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference"]
    pub srcArray: CUarray,
    #[doc = "< Source pitch (ignored when src is array)"]
    pub srcPitch: usize,
    #[doc = "< Destination X in bytes"]
    pub dstXInBytes: usize,
    #[doc = "< Destination Y"]
    pub dstY: usize,
    #[doc = "< Destination memory type (host, device, array)"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer"]
    pub dstHost: *mut ::std::os::raw::c_void,
    #[doc = "< Destination device pointer"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference"]
    pub dstArray: CUarray,
    #[doc = "< Destination pitch (ignored when dst is array)"]
    pub dstPitch: usize,
    #[doc = "< Width of 2D memory copy in bytes"]
    pub WidthInBytes: usize,
    #[doc = "< Height of 2D memory copy"]
    pub Height: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY2D_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_MEMCPY2D_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY2D_st>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY2D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(Height)
        )
    );
}
#[doc = " 2D memory copy parameters"]
pub type CUDA_MEMCPY2D_v2 = CUDA_MEMCPY2D_st;
#[doc = " 2D memory copy parameters"]
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_v2;
#[doc = " 3D memory copy parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY3D_st {
    #[doc = "< Source X in bytes"]
    pub srcXInBytes: usize,
    #[doc = "< Source Y"]
    pub srcY: usize,
    #[doc = "< Source Z"]
    pub srcZ: usize,
    #[doc = "< Source LOD"]
    pub srcLOD: usize,
    #[doc = "< Source memory type (host, device, array)"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer"]
    pub srcHost: *const ::std::os::raw::c_void,
    #[doc = "< Source device pointer"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference"]
    pub srcArray: CUarray,
    #[doc = "< Must be NULL"]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = "< Source pitch (ignored when src is array)"]
    pub srcPitch: usize,
    #[doc = "< Source height (ignored when src is array; may be 0 if Depth==1)"]
    pub srcHeight: usize,
    #[doc = "< Destination X in bytes"]
    pub dstXInBytes: usize,
    #[doc = "< Destination Y"]
    pub dstY: usize,
    #[doc = "< Destination Z"]
    pub dstZ: usize,
    #[doc = "< Destination LOD"]
    pub dstLOD: usize,
    #[doc = "< Destination memory type (host, device, array)"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer"]
    pub dstHost: *mut ::std::os::raw::c_void,
    #[doc = "< Destination device pointer"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference"]
    pub dstArray: CUarray,
    #[doc = "< Must be NULL"]
    pub reserved1: *mut ::std::os::raw::c_void,
    #[doc = "< Destination pitch (ignored when dst is array)"]
    pub dstPitch: usize,
    #[doc = "< Destination height (ignored when dst is array; may be 0 if Depth==1)"]
    pub dstHeight: usize,
    #[doc = "< Width of 3D memory copy in bytes"]
    pub WidthInBytes: usize,
    #[doc = "< Height of 3D memory copy"]
    pub Height: usize,
    #[doc = "< Depth of 3D memory copy"]
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_MEMCPY3D_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcLOD) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcHeight) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstZ) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstLOD) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstHeight) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Depth)
        )
    );
}
#[doc = " 3D memory copy parameters"]
pub type CUDA_MEMCPY3D_v2 = CUDA_MEMCPY3D_st;
#[doc = " 3D memory copy parameters"]
pub type CUDA_MEMCPY3D = CUDA_MEMCPY3D_v2;
#[doc = " 3D memory cross-context copy parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEMCPY3D_PEER_st {
    #[doc = "< Source X in bytes"]
    pub srcXInBytes: usize,
    #[doc = "< Source Y"]
    pub srcY: usize,
    #[doc = "< Source Z"]
    pub srcZ: usize,
    #[doc = "< Source LOD"]
    pub srcLOD: usize,
    #[doc = "< Source memory type (host, device, array)"]
    pub srcMemoryType: CUmemorytype,
    #[doc = "< Source host pointer"]
    pub srcHost: *const ::std::os::raw::c_void,
    #[doc = "< Source device pointer"]
    pub srcDevice: CUdeviceptr,
    #[doc = "< Source array reference"]
    pub srcArray: CUarray,
    #[doc = "< Source context (ignored with srcMemoryType is ::CU_MEMORYTYPE_ARRAY)"]
    pub srcContext: CUcontext,
    #[doc = "< Source pitch (ignored when src is array)"]
    pub srcPitch: usize,
    #[doc = "< Source height (ignored when src is array; may be 0 if Depth==1)"]
    pub srcHeight: usize,
    #[doc = "< Destination X in bytes"]
    pub dstXInBytes: usize,
    #[doc = "< Destination Y"]
    pub dstY: usize,
    #[doc = "< Destination Z"]
    pub dstZ: usize,
    #[doc = "< Destination LOD"]
    pub dstLOD: usize,
    #[doc = "< Destination memory type (host, device, array)"]
    pub dstMemoryType: CUmemorytype,
    #[doc = "< Destination host pointer"]
    pub dstHost: *mut ::std::os::raw::c_void,
    #[doc = "< Destination device pointer"]
    pub dstDevice: CUdeviceptr,
    #[doc = "< Destination array reference"]
    pub dstArray: CUarray,
    #[doc = "< Destination context (ignored with dstMemoryType is ::CU_MEMORYTYPE_ARRAY)"]
    pub dstContext: CUcontext,
    #[doc = "< Destination pitch (ignored when dst is array)"]
    pub dstPitch: usize,
    #[doc = "< Destination height (ignored when dst is array; may be 0 if Depth==1)"]
    pub dstHeight: usize,
    #[doc = "< Width of 3D memory copy in bytes"]
    pub WidthInBytes: usize,
    #[doc = "< Height of 3D memory copy"]
    pub Height: usize,
    #[doc = "< Depth of 3D memory copy"]
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_PEER_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_MEMCPY3D_PEER_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEMCPY3D_PEER_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEMCPY3D_PEER_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcLOD) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcContext) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcHeight) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstZ) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstLOD) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstContext) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstHeight) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Depth)
        )
    );
}
#[doc = " 3D memory cross-context copy parameters"]
pub type CUDA_MEMCPY3D_PEER_v1 = CUDA_MEMCPY3D_PEER_st;
#[doc = " 3D memory cross-context copy parameters"]
pub type CUDA_MEMCPY3D_PEER = CUDA_MEMCPY3D_PEER_v1;
#[doc = " Array descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    #[doc = "< Width of array"]
    pub Width: usize,
    #[doc = "< Height of array"]
    pub Height: usize,
    #[doc = "< Array format"]
    pub Format: CUarray_format,
    #[doc = "< Channels per array element"]
    pub NumChannels: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_DESCRIPTOR_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_ARRAY_DESCRIPTOR_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
}
#[doc = " Array descriptor"]
pub type CUDA_ARRAY_DESCRIPTOR_v2 = CUDA_ARRAY_DESCRIPTOR_st;
#[doc = " Array descriptor"]
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_v2;
#[doc = " 3D array descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    #[doc = "< Width of 3D array"]
    pub Width: usize,
    #[doc = "< Height of 3D array"]
    pub Height: usize,
    #[doc = "< Depth of 3D array"]
    pub Depth: usize,
    #[doc = "< Array format"]
    pub Format: CUarray_format,
    #[doc = "< Channels per array element"]
    pub NumChannels: ::std::os::raw::c_uint,
    #[doc = "< Flags"]
    pub Flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY3D_DESCRIPTOR_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_ARRAY3D_DESCRIPTOR_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Format) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Flags)
        )
    );
}
#[doc = " 3D array descriptor"]
pub type CUDA_ARRAY3D_DESCRIPTOR_v2 = CUDA_ARRAY3D_DESCRIPTOR_st;
#[doc = " 3D array descriptor"]
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_v2;
#[doc = " CUDA array sparse properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st {
    pub tileExtent: CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1,
    #[doc = " First mip level at which the mip tail begins."]
    pub miptailFirstLevel: ::std::os::raw::c_uint,
    #[doc = " Total size of the mip tail."]
    pub miptailSize: ::std::os::raw::c_ulonglong,
    #[doc = " Flags will either be zero or ::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL"]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 {
    #[doc = "< Width of sparse tile in elements"]
    pub width: ::std::os::raw::c_uint,
    #[doc = "< Height of sparse tile in elements"]
    pub height: ::std::os::raw::c_uint,
    #[doc = "< Depth of sparse tile in elements"]
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_ARRAY_SPARSE_PROPERTIES_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        48usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tileExtent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(tileExtent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miptailFirstLevel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(miptailFirstLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miptailSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(miptailSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA array sparse properties"]
pub type CUDA_ARRAY_SPARSE_PROPERTIES_v1 = CUDA_ARRAY_SPARSE_PROPERTIES_st;
#[doc = " CUDA array sparse properties"]
pub type CUDA_ARRAY_SPARSE_PROPERTIES = CUDA_ARRAY_SPARSE_PROPERTIES_v1;
#[doc = " CUDA array memory requirements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_ARRAY_MEMORY_REQUIREMENTS_st {
    #[doc = "< Total required memory size"]
    pub size: usize,
    #[doc = "< alignment requirement"]
    pub alignment: usize,
    pub reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_MEMORY_REQUIREMENTS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_ARRAY_MEMORY_REQUIREMENTS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " CUDA array memory requirements"]
pub type CUDA_ARRAY_MEMORY_REQUIREMENTS_v1 = CUDA_ARRAY_MEMORY_REQUIREMENTS_st;
#[doc = " CUDA array memory requirements"]
pub type CUDA_ARRAY_MEMORY_REQUIREMENTS = CUDA_ARRAY_MEMORY_REQUIREMENTS_v1;
#[doc = " CUDA Resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< CUDA array"]
    pub hArray: CUarray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< CUDA mipmapped array"]
    pub hMipmappedArray: CUmipmappedArray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hMipmappedArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hMipmappedArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: CUdeviceptr,
    #[doc = "< Array format"]
    pub format: CUarray_format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: CUdeviceptr,
    #[doc = "< Array format"]
    pub format: CUarray_format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::std::os::raw::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_RESOURCE_DESC_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " CUDA Resource descriptor"]
pub type CUDA_RESOURCE_DESC_v1 = CUDA_RESOURCE_DESC_st;
#[doc = " CUDA Resource descriptor"]
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_v1;
#[doc = " Texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [CUaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: CUfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::std::os::raw::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: CUfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::std::os::raw::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_CUDA_TEXTURE_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_TEXTURE_DESC_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).borderColor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Texture descriptor"]
pub type CUDA_TEXTURE_DESC_v1 = CUDA_TEXTURE_DESC_st;
#[doc = " Texture descriptor"]
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_v1;
#[doc = "< No resource view format (use underlying resource format)"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_NONE: CUresourceViewFormat_enum = 0;
#[doc = "< 1 channel unsigned 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X8: CUresourceViewFormat_enum = 1;
#[doc = "< 2 channel unsigned 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X8: CUresourceViewFormat_enum = 2;
#[doc = "< 4 channel unsigned 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X8: CUresourceViewFormat_enum = 3;
#[doc = "< 1 channel signed 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X8: CUresourceViewFormat_enum = 4;
#[doc = "< 2 channel signed 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X8: CUresourceViewFormat_enum = 5;
#[doc = "< 4 channel signed 8-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X8: CUresourceViewFormat_enum = 6;
#[doc = "< 1 channel unsigned 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X16: CUresourceViewFormat_enum = 7;
#[doc = "< 2 channel unsigned 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X16: CUresourceViewFormat_enum = 8;
#[doc = "< 4 channel unsigned 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X16: CUresourceViewFormat_enum = 9;
#[doc = "< 1 channel signed 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X16: CUresourceViewFormat_enum = 10;
#[doc = "< 2 channel signed 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X16: CUresourceViewFormat_enum = 11;
#[doc = "< 4 channel signed 16-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X16: CUresourceViewFormat_enum = 12;
#[doc = "< 1 channel unsigned 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_1X32: CUresourceViewFormat_enum = 13;
#[doc = "< 2 channel unsigned 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_2X32: CUresourceViewFormat_enum = 14;
#[doc = "< 4 channel unsigned 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UINT_4X32: CUresourceViewFormat_enum = 15;
#[doc = "< 1 channel signed 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_1X32: CUresourceViewFormat_enum = 16;
#[doc = "< 2 channel signed 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_2X32: CUresourceViewFormat_enum = 17;
#[doc = "< 4 channel signed 32-bit integers"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SINT_4X32: CUresourceViewFormat_enum = 18;
#[doc = "< 1 channel 16-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_1X16: CUresourceViewFormat_enum = 19;
#[doc = "< 2 channel 16-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_2X16: CUresourceViewFormat_enum = 20;
#[doc = "< 4 channel 16-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_4X16: CUresourceViewFormat_enum = 21;
#[doc = "< 1 channel 32-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_1X32: CUresourceViewFormat_enum = 22;
#[doc = "< 2 channel 32-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_2X32: CUresourceViewFormat_enum = 23;
#[doc = "< 4 channel 32-bit floating point"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_FLOAT_4X32: CUresourceViewFormat_enum = 24;
#[doc = "< Block compressed 1"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC1: CUresourceViewFormat_enum = 25;
#[doc = "< Block compressed 2"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC2: CUresourceViewFormat_enum = 26;
#[doc = "< Block compressed 3"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC3: CUresourceViewFormat_enum = 27;
#[doc = "< Block compressed 4 unsigned"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC4: CUresourceViewFormat_enum = 28;
#[doc = "< Block compressed 4 signed"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC4: CUresourceViewFormat_enum = 29;
#[doc = "< Block compressed 5 unsigned"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC5: CUresourceViewFormat_enum = 30;
#[doc = "< Block compressed 5 signed"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC5: CUresourceViewFormat_enum = 31;
#[doc = "< Block compressed 6 unsigned half-float"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC6H: CUresourceViewFormat_enum =
    32;
#[doc = "< Block compressed 6 signed half-float"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_SIGNED_BC6H: CUresourceViewFormat_enum = 33;
#[doc = "< Block compressed 7"]
pub const CUresourceViewFormat_enum_CU_RES_VIEW_FORMAT_UNSIGNED_BC7: CUresourceViewFormat_enum = 34;
#[doc = " Resource view format"]
pub type CUresourceViewFormat_enum = ::std::os::raw::c_int;
#[doc = " Resource view format"]
pub use self::CUresourceViewFormat_enum as CUresourceViewFormat;
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: CUresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::std::os::raw::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::std::os::raw::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_VIEW_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_RESOURCE_VIEW_DESC_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Resource view descriptor"]
pub type CUDA_RESOURCE_VIEW_DESC_v1 = CUDA_RESOURCE_VIEW_DESC_st;
#[doc = " Resource view descriptor"]
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_v1;
#[doc = " Tensor map descriptor. Requires compiler support for aligning to 64 bytes."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct CUtensorMap_st {
    pub opaque: [cuuint64_t; 16usize],
}
#[test]
fn bindgen_test_layout_CUtensorMap_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUtensorMap_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUtensorMap_st>(),
        128usize,
        concat!("Size of: ", stringify!(CUtensorMap_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUtensorMap_st>(),
        64usize,
        concat!("Alignment of ", stringify!(CUtensorMap_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUtensorMap_st),
            "::",
            stringify!(opaque)
        )
    );
}
#[doc = " Tensor map descriptor. Requires compiler support for aligning to 64 bytes."]
pub type CUtensorMap = CUtensorMap_st;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_UINT8: CUtensorMapDataType_enum = 0;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_UINT16: CUtensorMapDataType_enum = 1;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_UINT32: CUtensorMapDataType_enum = 2;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_INT32: CUtensorMapDataType_enum = 3;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_UINT64: CUtensorMapDataType_enum = 4;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_INT64: CUtensorMapDataType_enum = 5;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_FLOAT16: CUtensorMapDataType_enum = 6;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_FLOAT32: CUtensorMapDataType_enum = 7;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_FLOAT64: CUtensorMapDataType_enum = 8;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_BFLOAT16: CUtensorMapDataType_enum = 9;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ: CUtensorMapDataType_enum =
    10;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_TFLOAT32: CUtensorMapDataType_enum = 11;
pub const CUtensorMapDataType_enum_CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ: CUtensorMapDataType_enum =
    12;
#[doc = " Tensor map data type"]
pub type CUtensorMapDataType_enum = ::std::os::raw::c_int;
#[doc = " Tensor map data type"]
pub use self::CUtensorMapDataType_enum as CUtensorMapDataType;
pub const CUtensorMapInterleave_enum_CU_TENSOR_MAP_INTERLEAVE_NONE: CUtensorMapInterleave_enum = 0;
pub const CUtensorMapInterleave_enum_CU_TENSOR_MAP_INTERLEAVE_16B: CUtensorMapInterleave_enum = 1;
pub const CUtensorMapInterleave_enum_CU_TENSOR_MAP_INTERLEAVE_32B: CUtensorMapInterleave_enum = 2;
#[doc = " Tensor map interleave layout type"]
pub type CUtensorMapInterleave_enum = ::std::os::raw::c_int;
#[doc = " Tensor map interleave layout type"]
pub use self::CUtensorMapInterleave_enum as CUtensorMapInterleave;
pub const CUtensorMapSwizzle_enum_CU_TENSOR_MAP_SWIZZLE_NONE: CUtensorMapSwizzle_enum = 0;
pub const CUtensorMapSwizzle_enum_CU_TENSOR_MAP_SWIZZLE_32B: CUtensorMapSwizzle_enum = 1;
pub const CUtensorMapSwizzle_enum_CU_TENSOR_MAP_SWIZZLE_64B: CUtensorMapSwizzle_enum = 2;
pub const CUtensorMapSwizzle_enum_CU_TENSOR_MAP_SWIZZLE_128B: CUtensorMapSwizzle_enum = 3;
#[doc = " Tensor map swizzling mode of shared memory banks"]
pub type CUtensorMapSwizzle_enum = ::std::os::raw::c_int;
#[doc = " Tensor map swizzling mode of shared memory banks"]
pub use self::CUtensorMapSwizzle_enum as CUtensorMapSwizzle;
pub const CUtensorMapL2promotion_enum_CU_TENSOR_MAP_L2_PROMOTION_NONE: CUtensorMapL2promotion_enum =
    0;
pub const CUtensorMapL2promotion_enum_CU_TENSOR_MAP_L2_PROMOTION_L2_64B:
    CUtensorMapL2promotion_enum = 1;
pub const CUtensorMapL2promotion_enum_CU_TENSOR_MAP_L2_PROMOTION_L2_128B:
    CUtensorMapL2promotion_enum = 2;
pub const CUtensorMapL2promotion_enum_CU_TENSOR_MAP_L2_PROMOTION_L2_256B:
    CUtensorMapL2promotion_enum = 3;
#[doc = " Tensor map L2 promotion type"]
pub type CUtensorMapL2promotion_enum = ::std::os::raw::c_int;
#[doc = " Tensor map L2 promotion type"]
pub use self::CUtensorMapL2promotion_enum as CUtensorMapL2promotion;
pub const CUtensorMapFloatOOBfill_enum_CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE:
    CUtensorMapFloatOOBfill_enum = 0;
pub const CUtensorMapFloatOOBfill_enum_CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA:
    CUtensorMapFloatOOBfill_enum = 1;
#[doc = " Tensor map out-of-bounds fill type"]
pub type CUtensorMapFloatOOBfill_enum = ::std::os::raw::c_int;
#[doc = " Tensor map out-of-bounds fill type"]
pub use self::CUtensorMapFloatOOBfill_enum as CUtensorMapFloatOOBfill;
#[doc = " GPU Direct v3 tokens"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    pub p2pToken: ::std::os::raw::c_ulonglong,
    pub vaSpaceToken: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p2pToken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(p2pToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vaSpaceToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(vaSpaceToken)
        )
    );
}
#[doc = " GPU Direct v3 tokens"]
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st;
#[doc = " GPU Direct v3 tokens"]
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1;
#[doc = "< No access, meaning the device cannot access this memory at all, thus must be staged through accessible memory in order to complete certain operations"]
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 0;
#[doc = "< Read-only access, meaning writes to this memory are considered invalid accesses and thus return error in that case."]
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 1;
#[doc = "< Read-write access, the device has full read-write access to the memory"]
pub const CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum_CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE:
    CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = 3;
#[doc = " Access flags that specify the level of access the current context's device has\n on the memory referenced."]
pub type CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum = ::std::os::raw::c_int;
#[doc = " Access flags that specify the level of access the current context's device has\n on the memory referenced."]
pub use self::CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum as CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS;
#[doc = " Kernel launch parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_LAUNCH_PARAMS_st {
    #[doc = "< Kernel to launch"]
    pub function: CUfunction,
    #[doc = "< Width of grid in blocks"]
    pub gridDimX: ::std::os::raw::c_uint,
    #[doc = "< Height of grid in blocks"]
    pub gridDimY: ::std::os::raw::c_uint,
    #[doc = "< Depth of grid in blocks"]
    pub gridDimZ: ::std::os::raw::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::std::os::raw::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::std::os::raw::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::std::os::raw::c_uint,
    #[doc = "< Dynamic shared-memory size per thread block in bytes"]
    pub sharedMemBytes: ::std::os::raw::c_uint,
    #[doc = "< Stream identifier"]
    pub hStream: CUstream,
    #[doc = "< Array of pointers to kernel parameters"]
    pub kernelParams: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_LAUNCH_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_LAUNCH_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_LAUNCH_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_LAUNCH_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hStream) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(hStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
}
#[doc = " Kernel launch parameters"]
pub type CUDA_LAUNCH_PARAMS_v1 = CUDA_LAUNCH_PARAMS_st;
#[doc = " Kernel launch parameters"]
pub type CUDA_LAUNCH_PARAMS = CUDA_LAUNCH_PARAMS_v1;
#[doc = " Handle is an opaque file descriptor"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD:
    CUexternalMemoryHandleType_enum = 1;
#[doc = " Handle is an opaque shared NT handle"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32:
    CUexternalMemoryHandleType_enum = 2;
#[doc = " Handle is an opaque, globally shared handle"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT:
    CUexternalMemoryHandleType_enum = 3;
#[doc = " Handle is a D3D12 heap object"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP:
    CUexternalMemoryHandleType_enum = 4;
#[doc = " Handle is a D3D12 committed resource"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE:
    CUexternalMemoryHandleType_enum = 5;
#[doc = " Handle is a shared NT handle to a D3D11 resource"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE:
    CUexternalMemoryHandleType_enum = 6;
#[doc = " Handle is a globally shared handle to a D3D11 resource"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT:
    CUexternalMemoryHandleType_enum = 7;
#[doc = " Handle is an NvSciBuf object"]
pub const CUexternalMemoryHandleType_enum_CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF:
    CUexternalMemoryHandleType_enum = 8;
#[doc = " External memory handle types"]
pub type CUexternalMemoryHandleType_enum = ::std::os::raw::c_int;
#[doc = " External memory handle types"]
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
#[doc = " External memory handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    #[doc = " Type of the handle"]
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    #[doc = " Size of the memory allocation"]
    pub size: ::std::os::raw::c_ulonglong,
    #[doc = " Flags must either be zero or ::CUDA_EXTERNAL_MEMORY_DEDICATED"]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    #[doc = " File descriptor referencing the memory object. Valid\n when type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD"]
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    #[doc = " A handle representing an NvSciBuf Object. Valid when type\n is ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF"]
    pub nvSciBufObject: *const ::std::os::raw::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when\n type is one of the following:\n - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32\n - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT\n - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP\n - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE\n - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE\n - ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT\n Exactly one of 'handle' and 'name' must be non-NULL. If\n type is one of the following:\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT\n then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Name of a valid memory object.\n Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciBufObject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(nvSciBufObject)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " External memory handle descriptor"]
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
#[doc = " External memory handle descriptor"]
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1;
#[doc = " External memory buffer descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    #[doc = " Offset into the memory object where the buffer's base is"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = " Size of the buffer"]
    pub size: ::std::os::raw::c_ulonglong,
    #[doc = " Flags reserved for future use. Must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " External memory buffer descriptor"]
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
#[doc = " External memory buffer descriptor"]
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1;
#[doc = " External memory mipmap descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    #[doc = " Offset into the memory object where the base level of the\n mipmap chain is."]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = " Format, dimension and type of base level of the mipmap chain"]
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    #[doc = " Total number of levels in the mipmap chain"]
    pub numLevels: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayDesc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(arrayDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numLevels) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " External memory mipmap descriptor"]
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 =
    CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
#[doc = " External memory mipmap descriptor"]
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1;
#[doc = " Handle is an opaque file descriptor"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD:
    CUexternalSemaphoreHandleType_enum = 1;
#[doc = " Handle is an opaque shared NT handle"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32:
    CUexternalSemaphoreHandleType_enum = 2;
#[doc = " Handle is an opaque, globally shared handle"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT:
    CUexternalSemaphoreHandleType_enum = 3;
#[doc = " Handle is a shared NT handle referencing a D3D12 fence object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE:
    CUexternalSemaphoreHandleType_enum = 4;
#[doc = " Handle is a shared NT handle referencing a D3D11 fence object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE:
    CUexternalSemaphoreHandleType_enum = 5;
#[doc = " Opaque handle to NvSciSync Object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC:
    CUexternalSemaphoreHandleType_enum = 6;
#[doc = " Handle is a shared NT handle referencing a D3D11 keyed mutex object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX:
    CUexternalSemaphoreHandleType_enum = 7;
#[doc = " Handle is a globally shared handle referencing a D3D11 keyed mutex object"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT : CUexternalSemaphoreHandleType_enum = 8 ;
#[doc = " Handle is an opaque file descriptor referencing a timeline semaphore"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD : CUexternalSemaphoreHandleType_enum = 9 ;
#[doc = " Handle is an opaque shared NT handle referencing a timeline semaphore"]
pub const CUexternalSemaphoreHandleType_enum_CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 : CUexternalSemaphoreHandleType_enum = 10 ;
#[doc = " External semaphore handle types"]
pub type CUexternalSemaphoreHandleType_enum = ::std::os::raw::c_int;
#[doc = " External semaphore handle types"]
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
#[doc = " External semaphore handle descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    #[doc = " Type of the handle"]
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    #[doc = " Flags reserved for the future. Must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    #[doc = " File descriptor referencing the semaphore object. Valid\n when type is one of the following:\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD"]
    pub fd: ::std::os::raw::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    #[doc = " Valid NvSciSyncObj. Must be non NULL"]
    pub nvSciSyncObj: *const ::std::os::raw::c_void,
}
#[doc = " Win32 handle referencing the semaphore object. Valid when\n type is one of the following:\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32\n Exactly one of 'handle' and 'name' must be non-NULL. If\n type is one of the following:\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT\n - ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT\n then 'name' must be NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Valid NT handle. Must be NULL if 'name' is non-NULL"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = " Name of a valid synchronization primitive.\n Must be NULL if 'handle' is non-NULL."]
    pub name: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciSyncObj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSyncObj)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " External semaphore handle descriptor"]
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
#[doc = " External semaphore handle descriptor"]
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1;
#[doc = " External semaphore signal parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    #[doc = " Only when ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS is used to\n signal a ::CUexternalSemaphore of type\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, the valid flag is\n ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC which indicates\n that while signaling the ::CUexternalSemaphore, no memory synchronization\n operations should be performed for any external memory object imported\n as ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF.\n For all other types of ::CUexternalSemaphore, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 12usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be signaled"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Pointer to NvSciSyncFence. Valid if ::CUexternalSemaphoreHandleType\n is of type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC."]
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to release the mutex with"]
    pub key: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " External semaphore signal parameters"]
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
#[doc = " External semaphore signal parameters"]
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1;
#[doc = " External semaphore wait parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
    #[doc = " Only when ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS is used to wait on\n a ::CUexternalSemaphore of type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC,\n the valid flag is ::CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC\n which indicates that while waiting for the ::CUexternalSemaphore, no memory\n synchronization operations should be performed for any external memory\n object imported as ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF.\n For all other types of ::CUexternalSemaphore, flags must be zero."]
    pub flags: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::std::os::raw::c_uint; 10usize],
}
#[doc = " Parameters for fence objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Value of fence to be waited on"]
    pub value: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Pointer to NvSciSyncFence. Valid if CUexternalSemaphoreHandleType\n is of type CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::std::os::raw::c_void,
    pub reserved: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Parameters for keyed mutex objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Value of key to acquire the mutex with"]
    pub key: ::std::os::raw::c_ulonglong,
    #[doc = " Timeout in milliseconds to wait to acquire the mutex"]
    pub timeoutMs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(timeoutMs)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " External semaphore wait parameters"]
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st;
#[doc = " External semaphore wait parameters"]
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1;
#[doc = " Semaphore signal node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut CUexternalSemaphore,
    #[doc = "< Array of external semaphore signal parameters."]
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
#[doc = " Semaphore signal node parameters"]
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st;
#[doc = " Semaphore signal node parameters"]
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1;
#[doc = " Semaphore wait node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    #[doc = "< Array of external semaphore handles."]
    pub extSemArray: *mut CUexternalSemaphore,
    #[doc = "< Array of external semaphore wait parameters."]
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
    #[doc = "< Number of handles and parameters supplied in extSemArray and paramsArray."]
    pub numExtSems: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_WAIT_NODE_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
#[doc = " Semaphore wait node parameters"]
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 = CUDA_EXT_SEM_WAIT_NODE_PARAMS_st;
#[doc = " Semaphore wait node parameters"]
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1;
pub type CUmemGenericAllocationHandle_v1 = ::std::os::raw::c_ulonglong;
pub type CUmemGenericAllocationHandle = CUmemGenericAllocationHandle_v1;
#[doc = "< Does not allow any export mechanism. >"]
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_NONE: CUmemAllocationHandleType_enum =
    0;
#[doc = "< Allows a file descriptor to be used for exporting. Permitted only on POSIX systems. (int)"]
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR:
    CUmemAllocationHandleType_enum = 1;
#[doc = "< Allows a Win32 NT handle to be used for exporting. (HANDLE)"]
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_WIN32: CUmemAllocationHandleType_enum =
    2;
#[doc = "< Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)"]
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_WIN32_KMT:
    CUmemAllocationHandleType_enum = 4;
pub const CUmemAllocationHandleType_enum_CU_MEM_HANDLE_TYPE_MAX: CUmemAllocationHandleType_enum =
    2147483647;
#[doc = " Flags for specifying particular handle types"]
pub type CUmemAllocationHandleType_enum = ::std::os::raw::c_int;
#[doc = " Flags for specifying particular handle types"]
pub use self::CUmemAllocationHandleType_enum as CUmemAllocationHandleType;
#[doc = "< Default, make the address range not accessible"]
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_NONE: CUmemAccess_flags_enum = 0;
#[doc = "< Make the address range read accessible"]
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_READ: CUmemAccess_flags_enum = 1;
#[doc = "< Make the address range read-write accessible"]
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_READWRITE: CUmemAccess_flags_enum = 3;
pub const CUmemAccess_flags_enum_CU_MEM_ACCESS_FLAGS_PROT_MAX: CUmemAccess_flags_enum = 2147483647;
#[doc = " Specifies the memory protection flags for mapping."]
pub type CUmemAccess_flags_enum = ::std::os::raw::c_int;
#[doc = " Specifies the memory protection flags for mapping."]
pub use self::CUmemAccess_flags_enum as CUmemAccess_flags;
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_INVALID: CUmemLocationType_enum = 0;
#[doc = "< Location is a device location, thus id is a device ordinal"]
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_DEVICE: CUmemLocationType_enum = 1;
pub const CUmemLocationType_enum_CU_MEM_LOCATION_TYPE_MAX: CUmemLocationType_enum = 2147483647;
#[doc = " Specifies the type of location"]
pub type CUmemLocationType_enum = ::std::os::raw::c_int;
#[doc = " Specifies the type of location"]
pub use self::CUmemLocationType_enum as CUmemLocationType;
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_INVALID: CUmemAllocationType_enum = 0;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_PINNED: CUmemAllocationType_enum = 1;
#[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
pub const CUmemAllocationType_enum_CU_MEM_ALLOCATION_TYPE_MAX: CUmemAllocationType_enum =
    2147483647;
#[doc = " Defines the allocation types available"]
pub type CUmemAllocationType_enum = ::std::os::raw::c_int;
#[doc = " Defines the allocation types available"]
pub use self::CUmemAllocationType_enum as CUmemAllocationType;
#[doc = "< Minimum required granularity for allocation"]
pub const CUmemAllocationGranularity_flags_enum_CU_MEM_ALLOC_GRANULARITY_MINIMUM:
    CUmemAllocationGranularity_flags_enum = 0;
#[doc = "< Recommended granularity for allocation for best performance"]
pub const CUmemAllocationGranularity_flags_enum_CU_MEM_ALLOC_GRANULARITY_RECOMMENDED:
    CUmemAllocationGranularity_flags_enum = 1;
#[doc = " Flag for requesting different optimal and required granularities for an allocation."]
pub type CUmemAllocationGranularity_flags_enum = ::std::os::raw::c_int;
#[doc = " Flag for requesting different optimal and required granularities for an allocation."]
pub use self::CUmemAllocationGranularity_flags_enum as CUmemAllocationGranularity_flags;
pub const CUmemRangeHandleType_enum_CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD: CUmemRangeHandleType_enum =
    1;
pub const CUmemRangeHandleType_enum_CU_MEM_RANGE_HANDLE_TYPE_MAX: CUmemRangeHandleType_enum =
    2147483647;
#[doc = " Specifies the handle type for address range"]
pub type CUmemRangeHandleType_enum = ::std::os::raw::c_int;
#[doc = " Specifies the handle type for address range"]
pub use self::CUmemRangeHandleType_enum as CUmemRangeHandleType;
pub const CUarraySparseSubresourceType_enum_CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL:
    CUarraySparseSubresourceType_enum = 0;
pub const CUarraySparseSubresourceType_enum_CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL:
    CUarraySparseSubresourceType_enum = 1;
#[doc = " Sparse subresource types"]
pub type CUarraySparseSubresourceType_enum = ::std::os::raw::c_int;
#[doc = " Sparse subresource types"]
pub use self::CUarraySparseSubresourceType_enum as CUarraySparseSubresourceType;
pub const CUmemOperationType_enum_CU_MEM_OPERATION_TYPE_MAP: CUmemOperationType_enum = 1;
pub const CUmemOperationType_enum_CU_MEM_OPERATION_TYPE_UNMAP: CUmemOperationType_enum = 2;
#[doc = " Memory operation types"]
pub type CUmemOperationType_enum = ::std::os::raw::c_int;
#[doc = " Memory operation types"]
pub use self::CUmemOperationType_enum as CUmemOperationType;
pub const CUmemHandleType_enum_CU_MEM_HANDLE_TYPE_GENERIC: CUmemHandleType_enum = 0;
#[doc = " Memory handle types"]
pub type CUmemHandleType_enum = ::std::os::raw::c_int;
#[doc = " Memory handle types"]
pub use self::CUmemHandleType_enum as CUmemHandleType;
#[doc = " Specifies the CUDA array or CUDA mipmapped array memory mapping information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUarrayMapInfo_st {
    #[doc = "< Resource type"]
    pub resourceType: CUresourcetype,
    pub resource: CUarrayMapInfo_st__bindgen_ty_1,
    #[doc = "< Sparse subresource type"]
    pub subresourceType: CUarraySparseSubresourceType,
    pub subresource: CUarrayMapInfo_st__bindgen_ty_2,
    #[doc = "< Memory operation type"]
    pub memOperationType: CUmemOperationType,
    #[doc = "< Memory handle type"]
    pub memHandleType: CUmemHandleType,
    pub memHandle: CUarrayMapInfo_st__bindgen_ty_3,
    #[doc = "< Offset within the memory"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Device ordinal bit mask"]
    pub deviceBitMask: ::std::os::raw::c_uint,
    #[doc = "< flags for future use, must be zero now."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use, must be zero now."]
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_1 {
    pub mipmap: CUmipmappedArray,
    pub array: CUarray,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_2 {
    pub sparseLevel: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1,
    pub miptail: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< For CUDA mipmapped arrays must a valid mipmap level. For CUDA arrays must be zero"]
    pub level: ::std::os::raw::c_uint,
    #[doc = "< For CUDA layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< Starting X offset in elements"]
    pub offsetX: ::std::os::raw::c_uint,
    #[doc = "< Starting Y offset in elements"]
    pub offsetY: ::std::os::raw::c_uint,
    #[doc = "< Starting Z offset in elements"]
    pub offsetZ: ::std::os::raw::c_uint,
    #[doc = "< Width in elements"]
    pub extentWidth: ::std::os::raw::c_uint,
    #[doc = "< Height in elements"]
    pub extentHeight: ::std::os::raw::c_uint,
    #[doc = "< Depth in elements"]
    pub extentDepth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extentWidth) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extentHeight) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extentDepth) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentDepth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "< For CUDA layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::std::os::raw::c_uint,
    #[doc = "< Offset within mip tail"]
    pub offset: ::std::os::raw::c_ulonglong,
    #[doc = "< Extent in bytes"]
    pub size: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sparseLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2),
            "::",
            stringify!(sparseLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miptail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2),
            "::",
            stringify!(miptail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_3 {
    pub memHandle: CUmemGenericAllocationHandle,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_3),
            "::",
            stringify!(memHandle)
        )
    );
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUarrayMapInfo_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUarrayMapInfo_st>(),
        96usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUarrayMapInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subresourceType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(subresourceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subresource) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(subresource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memOperationType) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memOperationType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memHandleType) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memHandleType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memHandle) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceBitMask) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(deviceBitMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Specifies the CUDA array or CUDA mipmapped array memory mapping information"]
pub type CUarrayMapInfo_v1 = CUarrayMapInfo_st;
#[doc = " Specifies the CUDA array or CUDA mipmapped array memory mapping information"]
pub type CUarrayMapInfo = CUarrayMapInfo_v1;
#[doc = " Specifies a memory location."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemLocation_st {
    #[doc = "< Specifies the location type, which modifies the meaning of id."]
    pub type_: CUmemLocationType,
    #[doc = "< identifier for a given this location's ::CUmemLocationType."]
    pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUmemLocation_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUmemLocation_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUmemLocation_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemLocation_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemLocation_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemLocation_st),
            "::",
            stringify!(id)
        )
    );
}
#[doc = " Specifies a memory location."]
pub type CUmemLocation_v1 = CUmemLocation_st;
#[doc = " Specifies a memory location."]
pub type CUmemLocation = CUmemLocation_v1;
#[doc = "< Allocating non-compressible memory"]
pub const CUmemAllocationCompType_enum_CU_MEM_ALLOCATION_COMP_NONE: CUmemAllocationCompType_enum =
    0;
#[doc = "< Allocating  compressible memory"]
pub const CUmemAllocationCompType_enum_CU_MEM_ALLOCATION_COMP_GENERIC:
    CUmemAllocationCompType_enum = 1;
#[doc = " Specifies compression attribute for an allocation."]
pub type CUmemAllocationCompType_enum = ::std::os::raw::c_int;
#[doc = " Specifies compression attribute for an allocation."]
pub use self::CUmemAllocationCompType_enum as CUmemAllocationCompType;
#[doc = " Specifies the allocation properties for a allocation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAllocationProp_st {
    #[doc = " Allocation type"]
    pub type_: CUmemAllocationType,
    #[doc = " requested ::CUmemAllocationHandleType"]
    pub requestedHandleTypes: CUmemAllocationHandleType,
    #[doc = " Location of allocation"]
    pub location: CUmemLocation,
    #[doc = " Windows-specific POBJECT_ATTRIBUTES required when\n ::CU_MEM_HANDLE_TYPE_WIN32 is specified.  This object atributes structure\n includes security attributes that define\n the scope of which exported allocations may be tranferred to other\n processes.  In all other cases, this field is required to be zero."]
    pub win32HandleMetaData: *mut ::std::os::raw::c_void,
    pub allocFlags: CUmemAllocationProp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAllocationProp_st__bindgen_ty_1 {
    #[doc = " Allocation hint for requesting compressible memory.\n On devices that support Compute Data Compression, compressible\n memory can be used to accelerate accesses to data with unstructured\n sparsity and other compressible data patterns. Applications are\n expected to query allocation property of the handle obtained with\n ::cuMemCreate using ::cuMemGetAllocationPropertiesFromHandle to\n validate if the obtained allocation is compressible or not. Note that\n compressed memory may not be mappable on all devices."]
    pub compressionType: ::std::os::raw::c_uchar,
    pub gpuDirectRDMACapable: ::std::os::raw::c_uchar,
    #[doc = " Bitmask indicating intended usage for this allocation"]
    pub usage: ::std::os::raw::c_ushort,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUmemAllocationProp_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compressionType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(compressionType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuDirectRDMACapable) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(gpuDirectRDMACapable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUmemAllocationProp_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUmemAllocationProp_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAllocationProp_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requestedHandleTypes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(requestedHandleTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32HandleMetaData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(win32HandleMetaData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocFlags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(allocFlags)
        )
    );
}
#[doc = " Specifies the allocation properties for a allocation."]
pub type CUmemAllocationProp_v1 = CUmemAllocationProp_st;
#[doc = " Specifies the allocation properties for a allocation."]
pub type CUmemAllocationProp = CUmemAllocationProp_v1;
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemAccessDesc_st {
    #[doc = "< Location on which the request is to change it's accessibility"]
    pub location: CUmemLocation,
    #[doc = "< ::CUmemProt accessibility flags to set on the request"]
    pub flags: CUmemAccess_flags,
}
#[test]
fn bindgen_test_layout_CUmemAccessDesc_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUmemAccessDesc_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUmemAccessDesc_st>(),
        12usize,
        concat!("Size of: ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemAccessDesc_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAccessDesc_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAccessDesc_st),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Memory access descriptor"]
pub type CUmemAccessDesc_v1 = CUmemAccessDesc_st;
#[doc = " Memory access descriptor"]
pub type CUmemAccessDesc = CUmemAccessDesc_v1;
#[doc = "< The update succeeded"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_SUCCESS: CUgraphExecUpdateResult_enum =
    0;
#[doc = "< The update failed for an unexpected reason which is described in the return value of the function"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR: CUgraphExecUpdateResult_enum = 1;
#[doc = "< The update failed because the topology changed"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED:
    CUgraphExecUpdateResult_enum = 2;
#[doc = "< The update failed because a node type changed"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED:
    CUgraphExecUpdateResult_enum = 3;
#[doc = "< The update failed because the function of a kernel node changed (CUDA driver < 11.2)"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED:
    CUgraphExecUpdateResult_enum = 4;
#[doc = "< The update failed because the parameters changed in a way that is not supported"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED:
    CUgraphExecUpdateResult_enum = 5;
#[doc = "< The update failed because something about the node is not supported"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED:
    CUgraphExecUpdateResult_enum = 6;
#[doc = "< The update failed because the function of a kernel node changed in an unsupported way"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE:
    CUgraphExecUpdateResult_enum = 7;
#[doc = "< The update failed because the node attributes changed in a way that is not supported"]
pub const CUgraphExecUpdateResult_enum_CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED:
    CUgraphExecUpdateResult_enum = 8;
#[doc = " CUDA Graph Update error types"]
pub type CUgraphExecUpdateResult_enum = ::std::os::raw::c_int;
#[doc = " CUDA Graph Update error types"]
pub use self::CUgraphExecUpdateResult_enum as CUgraphExecUpdateResult;
#[doc = " Result information returned by cuGraphExecUpdate"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExecUpdateResultInfo_st {
    #[doc = " Gives more specific detail when a cuda graph update fails."]
    pub result: CUgraphExecUpdateResult,
    #[doc = " The \"to node\" of the error edge when the topologies do not match.\n The error node when the error is associated with a specific node.\n NULL when the error is generic."]
    pub errorNode: CUgraphNode,
    #[doc = " The from node of error edge when the topologies do not match. Otherwise NULL."]
    pub errorFromNode: CUgraphNode,
}
#[test]
fn bindgen_test_layout_CUgraphExecUpdateResultInfo_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUgraphExecUpdateResultInfo_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUgraphExecUpdateResultInfo_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUgraphExecUpdateResultInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUgraphExecUpdateResultInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUgraphExecUpdateResultInfo_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphExecUpdateResultInfo_st),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorNode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphExecUpdateResultInfo_st),
            "::",
            stringify!(errorNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorFromNode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphExecUpdateResultInfo_st),
            "::",
            stringify!(errorFromNode)
        )
    );
}
#[doc = " Result information returned by cuGraphExecUpdate"]
pub type CUgraphExecUpdateResultInfo_v1 = CUgraphExecUpdateResultInfo_st;
#[doc = " Result information returned by cuGraphExecUpdate"]
pub type CUgraphExecUpdateResultInfo = CUgraphExecUpdateResultInfo_v1;
#[doc = " (value type = int)\n Allow cuMemAllocAsync to use memory asynchronously freed\n in another streams as long as a stream ordering dependency\n of the allocating stream on the free action exists.\n Cuda events and null stream interactions can create the required\n stream ordered dependencies. (default enabled)"]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES:
    CUmemPool_attribute_enum = 1;
#[doc = " (value type = int)\n Allow reuse of already completed frees when there is no dependency\n between the free and allocation. (default enabled)"]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC:
    CUmemPool_attribute_enum = 2;
#[doc = " (value type = int)\n Allow cuMemAllocAsync to insert new stream dependencies\n in order to establish the stream ordering required to reuse\n a piece of memory released by cuFreeAsync (default enabled)."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES:
    CUmemPool_attribute_enum = 3;
#[doc = " (value type = cuuint64_t)\n Amount of reserved memory in bytes to hold onto before trying\n to release memory back to the OS. When more than the release\n threshold bytes of memory are held by the memory pool, the\n allocator will try to release memory back to the OS on the\n next call to stream, event or context synchronize. (default 0)"]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RELEASE_THRESHOLD: CUmemPool_attribute_enum = 4;
#[doc = " (value type = cuuint64_t)\n Amount of backing memory currently allocated for the mempool."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT: CUmemPool_attribute_enum =
    5;
#[doc = " (value type = cuuint64_t)\n High watermark of backing memory allocated for the mempool since the\n last time it was reset. High watermark can only be reset to zero."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH: CUmemPool_attribute_enum = 6;
#[doc = " (value type = cuuint64_t)\n Amount of memory from the pool that is currently in use by the application."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_USED_MEM_CURRENT: CUmemPool_attribute_enum = 7;
#[doc = " (value type = cuuint64_t)\n High watermark of the amount of memory from the pool that was in use by the application since\n the last time it was reset. High watermark can only be reset to zero."]
pub const CUmemPool_attribute_enum_CU_MEMPOOL_ATTR_USED_MEM_HIGH: CUmemPool_attribute_enum = 8;
#[doc = " CUDA memory pool attributes"]
pub type CUmemPool_attribute_enum = ::std::os::raw::c_int;
#[doc = " CUDA memory pool attributes"]
pub use self::CUmemPool_attribute_enum as CUmemPool_attribute;
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolProps_st {
    #[doc = "< Allocation type. Currently must be specified as CU_MEM_ALLOCATION_TYPE_PINNED"]
    pub allocType: CUmemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool."]
    pub handleTypes: CUmemAllocationHandleType,
    #[doc = "< Location where allocations should reside."]
    pub location: CUmemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when\n ::CU_MEM_HANDLE_TYPE_WIN32 is specified.  This security attribute defines\n the scope of which exported allocations may be tranferred to other\n processes.  In all other cases, this field is required to be zero."]
    pub win32SecurityAttributes: *mut ::std::os::raw::c_void,
    #[doc = "< reserved for future use, must be 0"]
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolProps_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUmemPoolProps_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUmemPoolProps_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemPoolProps_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(allocType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(handleTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32SecurityAttributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(win32SecurityAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Specifies the properties of allocations made from the pool."]
pub type CUmemPoolProps_v1 = CUmemPoolProps_st;
#[doc = " Specifies the properties of allocations made from the pool."]
pub type CUmemPoolProps = CUmemPoolProps_v1;
#[doc = " Opaque data for exporting a pool allocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolPtrExportData_st {
    pub reserved: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolPtrExportData_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUmemPoolPtrExportData_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUmemPoolPtrExportData_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUmemPoolPtrExportData_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolPtrExportData_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Opaque data for exporting a pool allocation"]
pub type CUmemPoolPtrExportData_v1 = CUmemPoolPtrExportData_st;
#[doc = " Opaque data for exporting a pool allocation"]
pub type CUmemPoolPtrExportData = CUmemPoolPtrExportData_v1;
#[doc = " Memory allocation node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUDA_MEM_ALLOC_NODE_PARAMS_st {
    #[doc = " in: location where the allocation should reside (specified in ::location).\n ::handleTypes must be ::CU_MEM_HANDLE_TYPE_NONE. IPC is not supported."]
    pub poolProps: CUmemPoolProps,
    #[doc = "< in: array of memory access descriptors. Used to describe peer GPU access"]
    pub accessDescs: *const CUmemAccessDesc,
    #[doc = "< in: number of memory access descriptors.  Must not exceed the number of GPUs."]
    pub accessDescCount: usize,
    #[doc = "< in: size in bytes of the requested allocation"]
    pub bytesize: usize,
    #[doc = "< out: address of the allocation returned by CUDA"]
    pub dptr: CUdeviceptr,
}
#[test]
fn bindgen_test_layout_CUDA_MEM_ALLOC_NODE_PARAMS_st() {
    const UNINIT: ::std::mem::MaybeUninit<CUDA_MEM_ALLOC_NODE_PARAMS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUDA_MEM_ALLOC_NODE_PARAMS_st>(),
        120usize,
        concat!("Size of: ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<CUDA_MEM_ALLOC_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(poolProps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(accessDescs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(accessDescCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(bytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_st),
            "::",
            stringify!(dptr)
        )
    );
}
#[doc = " Memory allocation node parameters"]
pub type CUDA_MEM_ALLOC_NODE_PARAMS = CUDA_MEM_ALLOC_NODE_PARAMS_st;
#[doc = " (value type = cuuint64_t)\n Amount of memory, in bytes, currently associated with graphs"]
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT: CUgraphMem_attribute_enum =
    0;
#[doc = " (value type = cuuint64_t)\n High watermark of memory, in bytes, associated with graphs since the\n last time it was reset.  High watermark can only be reset to zero."]
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_USED_MEM_HIGH: CUgraphMem_attribute_enum = 1;
#[doc = " (value type = cuuint64_t)\n Amount of memory, in bytes, currently allocated for use by\n the CUDA graphs asynchronous allocator."]
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT:
    CUgraphMem_attribute_enum = 2;
#[doc = " (value type = cuuint64_t)\n High watermark of memory, in bytes, currently allocated for use by\n the CUDA graphs asynchronous allocator."]
pub const CUgraphMem_attribute_enum_CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH: CUgraphMem_attribute_enum =
    3;
pub type CUgraphMem_attribute_enum = ::std::os::raw::c_int;
pub use self::CUgraphMem_attribute_enum as CUgraphMem_attribute;
#[doc = "< ::cuFlushGPUDirectRDMAWrites() and its CUDA Runtime API counterpart are supported on the device."]
pub const CUflushGPUDirectRDMAWritesOptions_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST:
    CUflushGPUDirectRDMAWritesOptions_enum = 1;
#[doc = "< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device."]
pub const CUflushGPUDirectRDMAWritesOptions_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS:
    CUflushGPUDirectRDMAWritesOptions_enum = 2;
#[doc = " Bitmasks for ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS"]
pub type CUflushGPUDirectRDMAWritesOptions_enum = ::std::os::raw::c_int;
#[doc = " Bitmasks for ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS"]
pub use self::CUflushGPUDirectRDMAWritesOptions_enum as CUflushGPUDirectRDMAWritesOptions;
#[doc = "< The device does not natively support ordering of remote writes. ::cuFlushGPUDirectRDMAWrites() can be leveraged if supported."]
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE:
    CUGPUDirectRDMAWritesOrdering_enum = 0;
#[doc = "< Natively, the device can consistently consume remote writes, although other CUDA devices may not."]
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER:
    CUGPUDirectRDMAWritesOrdering_enum = 100;
#[doc = "< Any CUDA device in the system can consistently consume remote writes to this device."]
pub const CUGPUDirectRDMAWritesOrdering_enum_CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES:
    CUGPUDirectRDMAWritesOrdering_enum = 200;
#[doc = " Platform native ordering for GPUDirect RDMA writes"]
pub type CUGPUDirectRDMAWritesOrdering_enum = ::std::os::raw::c_int;
#[doc = " Platform native ordering for GPUDirect RDMA writes"]
pub use self::CUGPUDirectRDMAWritesOrdering_enum as CUGPUDirectRDMAWritesOrdering;
#[doc = "< Blocks until remote writes are visible to the CUDA device context owning the data."]
pub const CUflushGPUDirectRDMAWritesScope_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER:
    CUflushGPUDirectRDMAWritesScope_enum = 100;
#[doc = "< Blocks until remote writes are visible to all CUDA device contexts."]
pub const CUflushGPUDirectRDMAWritesScope_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES:
    CUflushGPUDirectRDMAWritesScope_enum = 200;
#[doc = " The scopes for ::cuFlushGPUDirectRDMAWrites"]
pub type CUflushGPUDirectRDMAWritesScope_enum = ::std::os::raw::c_int;
#[doc = " The scopes for ::cuFlushGPUDirectRDMAWrites"]
pub use self::CUflushGPUDirectRDMAWritesScope_enum as CUflushGPUDirectRDMAWritesScope;
#[doc = "< Sets the target for ::cuFlushGPUDirectRDMAWrites() to the currently active CUDA device context."]
pub const CUflushGPUDirectRDMAWritesTarget_enum_CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX : CUflushGPUDirectRDMAWritesTarget_enum = 0 ;
#[doc = " The targets for ::cuFlushGPUDirectRDMAWrites"]
pub type CUflushGPUDirectRDMAWritesTarget_enum = ::std::os::raw::c_int;
#[doc = " The targets for ::cuFlushGPUDirectRDMAWrites"]
pub use self::CUflushGPUDirectRDMAWritesTarget_enum as CUflushGPUDirectRDMAWritesTarget;
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE: CUgraphDebugDot_flags_enum =
    1;
#[doc = " Output all debug data as if every debug flag is enabled"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES:
    CUgraphDebugDot_flags_enum = 2;
#[doc = " Use CUDA Runtime structures for output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 4;
#[doc = " Adds CUDA_KERNEL_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 8;
#[doc = " Adds CUDA_MEMCPY3D values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 16;
#[doc = " Adds CUDA_MEMSET_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 32;
#[doc = " Adds CUDA_HOST_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 64;
#[doc = " Adds CUevent handle from record and wait nodes to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 128;
#[doc = " Adds CUDA_EXT_SEM_SIGNAL_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 256;
#[doc = " Adds CUDA_EXT_SEM_WAIT_NODE_PARAMS values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES:
    CUgraphDebugDot_flags_enum = 512;
#[doc = " Adds CUkernelNodeAttrValue values to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES: CUgraphDebugDot_flags_enum =
    1024;
#[doc = " Adds node handles and every kernel function handle to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 2048;
#[doc = " Adds memory alloc node parameters to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 4096;
#[doc = " Adds memory free node parameters to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS:
    CUgraphDebugDot_flags_enum = 8192;
#[doc = " Adds batch mem op node parameters to output"]
pub const CUgraphDebugDot_flags_enum_CU_GRAPH_DEBUG_DOT_FLAGS_EXTRA_TOPO_INFO:
    CUgraphDebugDot_flags_enum = 16384;
#[doc = " The additional write options for ::cuGraphDebugDotPrint"]
pub type CUgraphDebugDot_flags_enum = ::std::os::raw::c_int;
#[doc = " The additional write options for ::cuGraphDebugDotPrint"]
pub use self::CUgraphDebugDot_flags_enum as CUgraphDebugDot_flags;
#[doc = "< Indicates the destructor execution is not synchronized by any CUDA handle."]
pub const CUuserObject_flags_enum_CU_USER_OBJECT_NO_DESTRUCTOR_SYNC: CUuserObject_flags_enum = 1;
#[doc = " Flags for user objects for graphs"]
pub type CUuserObject_flags_enum = ::std::os::raw::c_int;
#[doc = " Flags for user objects for graphs"]
pub use self::CUuserObject_flags_enum as CUuserObject_flags;
#[doc = "< Transfer references from the caller rather than creating new references."]
pub const CUuserObjectRetain_flags_enum_CU_GRAPH_USER_OBJECT_MOVE: CUuserObjectRetain_flags_enum =
    1;
#[doc = " Flags for retaining user object references for graphs"]
pub type CUuserObjectRetain_flags_enum = ::std::os::raw::c_int;
#[doc = " Flags for retaining user object references for graphs"]
pub use self::CUuserObjectRetain_flags_enum as CUuserObjectRetain_flags;
#[doc = "< Automatically free memory allocated in a graph before relaunching."]
pub const CUgraphInstantiate_flags_enum_CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH:
    CUgraphInstantiate_flags_enum = 1;
#[doc = "< Automatically upload the graph after instantiaton."]
pub const CUgraphInstantiate_flags_enum_CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD:
    CUgraphInstantiate_flags_enum = 2;
#[doc = "< Instantiate the graph to be launchable from the device."]
pub const CUgraphInstantiate_flags_enum_CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH:
    CUgraphInstantiate_flags_enum = 4;
#[doc = "< Run the graph using the per-node priority attributes rather than the\npriority of the stream it is launched into."]
pub const CUgraphInstantiate_flags_enum_CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY:
    CUgraphInstantiate_flags_enum = 8;
#[doc = " Flags for instantiating a graph"]
pub type CUgraphInstantiate_flags_enum = ::std::os::raw::c_int;
#[doc = " Flags for instantiating a graph"]
pub use self::CUgraphInstantiate_flags_enum as CUgraphInstantiate_flags;
extern "C" {
    #[doc = " \\brief Gets the string description of an error code\n\n Sets \\p *pStr to the address of a NULL-terminated string description\n of the error code \\p error.\n If the error code is not recognized, ::CUDA_ERROR_INVALID_VALUE\n will be returned and \\p *pStr will be set to the NULL address.\n\n \\param error - Error code to convert to string\n \\param pStr - Address of the string pointer.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::CUresult,\n ::cudaGetErrorString"]
    pub fn cuGetErrorString(error: CUresult, pStr: *mut *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the string representation of an error code enum name\n\n Sets \\p *pStr to the address of a NULL-terminated string representation\n of the name of the enum error code \\p error.\n If the error code is not recognized, ::CUDA_ERROR_INVALID_VALUE\n will be returned and \\p *pStr will be set to the NULL address.\n\n \\param error - Error code to convert to string\n \\param pStr - Address of the string pointer.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::CUresult,\n ::cudaGetErrorName"]
    pub fn cuGetErrorName(error: CUresult, pStr: *mut *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Initialize the CUDA driver API\n Initializes the driver API and must be called before any other function from\n the driver API in the current process. Currently, the \\p Flags parameter must be 0. If ::cuInit()\n has not been called, any function from the driver API will return\n ::CUDA_ERROR_NOT_INITIALIZED.\n\n \\param Flags - Initialization flag for CUDA.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_SYSTEM_DRIVER_MISMATCH,\n ::CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE\n \\notefnerr"]
    pub fn cuInit(Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the latest CUDA version supported by driver\n\n Returns in \\p *driverVersion the version of CUDA supported by\n the driver.  The version is returned as\n (1000 &times; major + 10 &times; minor). For example, CUDA 9.2\n would be represented by 9020.\n\n This function automatically returns ::CUDA_ERROR_INVALID_VALUE if\n \\p driverVersion is NULL.\n\n \\param driverVersion - Returns the CUDA driver version\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa\n ::cudaDriverGetVersion,\n ::cudaRuntimeGetVersion"]
    pub fn cuDriverGetVersion(driverVersion: *mut ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a handle to a compute device\n\n Returns in \\p *device a device handle given an ordinal in the range <b>[0,\n ::cuDeviceGetCount()-1]</b>.\n\n \\param device  - Returned device handle\n \\param ordinal - Device number to get handle for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetAttribute,\n ::cuDeviceGetCount,\n ::cuDeviceGetName,\n ::cuDeviceGetUuid,\n ::cuDeviceGetLuid,\n ::cuDeviceTotalMem,\n ::cuDeviceGetExecAffinitySupport"]
    pub fn cuDeviceGet(device: *mut CUdevice, ordinal: ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the number of compute-capable devices\n\n Returns in \\p *count the number of devices with compute capability greater\n than or equal to 2.0 that are available for execution. If there is no such\n device, ::cuDeviceGetCount() returns 0.\n\n \\param count - Returned number of compute-capable devices\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetAttribute,\n ::cuDeviceGetName,\n ::cuDeviceGetUuid,\n ::cuDeviceGetLuid,\n ::cuDeviceGet,\n ::cuDeviceTotalMem,\n ::cuDeviceGetExecAffinitySupport,\n ::cudaGetDeviceCount"]
    pub fn cuDeviceGetCount(count: *mut ::std::os::raw::c_int) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns an identifer string for the device\n\n Returns an ASCII string identifying the device \\p dev in the NULL-terminated\n string pointed to by \\p name. \\p len specifies the maximum length of the\n string that may be returned.\n\n \\param name - Returned identifier string for the device\n \\param len  - Maximum length of string to store in \\p name\n \\param dev  - Device to get identifier string for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetAttribute,\n ::cuDeviceGetUuid,\n ::cuDeviceGetLuid,\n ::cuDeviceGetCount,\n ::cuDeviceGet,\n ::cuDeviceTotalMem,\n ::cuDeviceGetExecAffinitySupport,\n ::cudaGetDeviceProperties"]
    pub fn cuDeviceGetName(
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Return an UUID for the device\n\n Note there is a later version of this API, ::cuDeviceGetUuid_v2. It will\n supplant this version in 12.0, which is retained for minor version compatibility.\n\n Returns 16-octets identifing the device \\p dev in the structure\n pointed by the \\p uuid.\n\n \\param uuid - Returned UUID\n \\param dev  - Device to get identifier string for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetUuid_v2\n ::cuDeviceGetAttribute,\n ::cuDeviceGetCount,\n ::cuDeviceGetName,\n ::cuDeviceGetLuid,\n ::cuDeviceGet,\n ::cuDeviceTotalMem,\n ::cuDeviceGetExecAffinitySupport,\n ::cudaGetDeviceProperties"]
    pub fn cuDeviceGetUuid(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDeviceGetUuid_v2(uuid: *mut CUuuid, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Return an LUID and device node mask for the device\n\n Return identifying information (\\p luid and \\p deviceNodeMask) to allow\n matching device with graphics APIs.\n\n \\param luid - Returned LUID\n \\param deviceNodeMask - Returned device node mask\n \\param dev  - Device to get identifier string for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetAttribute,\n ::cuDeviceGetCount,\n ::cuDeviceGetName,\n ::cuDeviceGet,\n ::cuDeviceTotalMem,\n ::cuDeviceGetExecAffinitySupport,\n ::cudaGetDeviceProperties"]
    pub fn cuDeviceGetLuid(
        luid: *mut ::std::os::raw::c_char,
        deviceNodeMask: *mut ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDeviceTotalMem_v2(bytes: *mut usize, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size.\n\n Returns in \\p maxWidthInElements the maximum number of texture elements allocatable in a 1D linear texture\n for given \\p format and \\p numChannels.\n\n \\param maxWidthInElements    - Returned maximum number of texture elements allocatable for given \\p format and \\p numChannels.\n \\param format                - Texture format.\n \\param numChannels           - Number of channels per texture element.\n \\param dev                   - Device handle.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetAttribute,\n ::cuDeviceGetCount,\n ::cuDeviceGetName,\n ::cuDeviceGetUuid,\n ::cuDeviceGet,\n ::cudaMemGetInfo,\n ::cuDeviceTotalMem"]
    pub fn cuDeviceGetTexture1DLinearMaxWidth(
        maxWidthInElements: *mut usize,
        format: CUarray_format,
        numChannels: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about the device\n\n Returns in \\p *pi the integer value of the attribute \\p attrib on device\n \\p dev. The supported attributes are:\n - ::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: Maximum number of threads per\n   block;\n - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: Maximum x-dimension of a block\n - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: Maximum y-dimension of a block\n - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: Maximum z-dimension of a block\n - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: Maximum x-dimension of a grid\n - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: Maximum y-dimension of a grid\n - ::CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: Maximum z-dimension of a grid\n - ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK: Maximum amount of\n   shared memory available to a thread block in bytes\n - ::CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY: Memory available on device for\n   __constant__ variables in a CUDA C kernel in bytes\n - ::CU_DEVICE_ATTRIBUTE_WARP_SIZE: Warp size in threads\n - ::CU_DEVICE_ATTRIBUTE_MAX_PITCH: Maximum pitch in bytes allowed by the\n   memory copy functions that involve memory regions allocated through\n   ::cuMemAllocPitch()\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH: Maximum 1D\n  texture width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH: Maximum width\n  for a 1D texture bound to linear memory\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH: Maximum\n  mipmapped 1D texture width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH: Maximum 2D\n  texture width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT: Maximum 2D\n  texture height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH: Maximum width\n  for a 2D texture bound to linear memory\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT: Maximum height\n  for a 2D texture bound to linear memory\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH: Maximum pitch\n  in bytes for a 2D texture bound to linear memory\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH: Maximum\n  mipmapped 2D texture width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT: Maximum\n  mipmapped 2D texture height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH: Maximum 3D\n  texture width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT: Maximum 3D\n  texture height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH: Maximum 3D\n  texture depth\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE:\n  Alternate maximum 3D texture width, 0 if no alternate\n  maximum 3D texture size is supported\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE:\n  Alternate maximum 3D texture height, 0 if no alternate\n  maximum 3D texture size is supported\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE:\n  Alternate maximum 3D texture depth, 0 if no alternate\n  maximum 3D texture size is supported\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH:\n  Maximum cubemap texture width or height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH:\n  Maximum 1D layered texture width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS:\n   Maximum layers in a 1D layered texture\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH:\n  Maximum 2D layered texture width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT:\n   Maximum 2D layered texture height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS:\n   Maximum layers in a 2D layered texture\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH:\n   Maximum cubemap layered texture width or height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS:\n   Maximum layers in a cubemap layered texture\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH:\n   Maximum 1D surface width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH:\n   Maximum 2D surface width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT:\n   Maximum 2D surface height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH:\n   Maximum 3D surface width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT:\n   Maximum 3D surface height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH:\n   Maximum 3D surface depth\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH:\n   Maximum 1D layered surface width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS:\n   Maximum layers in a 1D layered surface\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH:\n   Maximum 2D layered surface width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT:\n   Maximum 2D layered surface height\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS:\n   Maximum layers in a 2D layered surface\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH:\n   Maximum cubemap surface width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH:\n   Maximum cubemap layered surface width\n - ::CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS:\n   Maximum layers in a cubemap layered surface\n - ::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK: Maximum number of 32-bit\n   registers available to a thread block\n - ::CU_DEVICE_ATTRIBUTE_CLOCK_RATE: The typical clock frequency in kilohertz\n - ::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: Alignment requirement; texture\n   base addresses aligned to ::textureAlign bytes do not need an offset\n   applied to texture fetches\n - ::CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT: Pitch alignment requirement\n   for 2D texture references bound to pitched memory\n - ::CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: 1 if the device can concurrently copy\n   memory between host and device while executing a kernel, or 0 if not\n - ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: Number of multiprocessors on\n   the device\n - ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: 1 if there is a run time limit\n   for kernels executed on the device, or 0 if not\n - ::CU_DEVICE_ATTRIBUTE_INTEGRATED: 1 if the device is integrated with the\n   memory subsystem, or 0 if not\n - ::CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: 1 if the device can map host\n   memory into the CUDA address space, or 0 if not\n - ::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: Compute mode that device is currently\n   in. Available modes are as follows:\n   - ::CU_COMPUTEMODE_DEFAULT: Default mode - Device is not restricted and\n     can have multiple CUDA contexts present at a single time.\n   - ::CU_COMPUTEMODE_PROHIBITED: Compute-prohibited mode - Device is\n     prohibited from creating new CUDA contexts.\n   - ::CU_COMPUTEMODE_EXCLUSIVE_PROCESS:  Compute-exclusive-process mode - Device\n     can have only one context used by a single process at a time.\n - ::CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS: 1 if the device supports\n   executing multiple kernels within the same context simultaneously, or 0 if\n   not. It is not guaranteed that multiple kernels will be resident\n   on the device concurrently so this feature should not be relied upon for\n   correctness.\n - ::CU_DEVICE_ATTRIBUTE_ECC_ENABLED: 1 if error correction is enabled on the\n    device, 0 if error correction is disabled or not supported by the device\n - ::CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: PCI bus identifier of the device\n - ::CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: PCI device (also known as slot) identifier\n   of the device\n - ::CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: PCI domain identifier of the device\n - ::CU_DEVICE_ATTRIBUTE_TCC_DRIVER: 1 if the device is using a TCC driver. TCC\n    is only available on Tesla hardware running Windows Vista or later\n - ::CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: Peak memory clock frequency in kilohertz\n - ::CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH: Global memory bus width in bits\n - ::CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: Size of L2 cache in bytes. 0 if the device doesn't have L2 cache\n - ::CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR: Maximum resident threads per multiprocessor\n - ::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: 1 if the device shares a unified address space with\n   the host, or 0 if not\n - ::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR: Major compute capability version number\n - ::CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR: Minor compute capability version number\n - ::CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED: 1 if device supports caching globals\n    in L1 cache, 0 if caching globals in L1 cache is not supported by the device\n - ::CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED: 1 if device supports caching locals\n    in L1 cache, 0 if caching locals in L1 cache is not supported by the device\n - ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR: Maximum amount of\n   shared memory available to a multiprocessor in bytes; this amount is shared\n   by all thread blocks simultaneously resident on a multiprocessor\n - ::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR: Maximum number of 32-bit\n   registers available to a multiprocessor; this number is shared by all thread\n   blocks simultaneously resident on a multiprocessor\n - ::CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: 1 if device supports allocating managed memory\n   on this system, 0 if allocating managed memory is not supported by the device on this system.\n - ::CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: 1 if device is on a multi-GPU board, 0 if not.\n - ::CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID: Unique identifier for a group of devices\n   associated with the same board. Devices on the same multi-GPU board will share the same identifier.\n - ::CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED: 1 if Link between the device and the host\n   supports native atomic operations.\n - ::CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO: Ratio of single precision performance\n   (in floating-point operations per second) to double precision performance.\n - ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS: Device suppports coherently accessing\n   pageable memory without calling cudaHostRegister on it.\n - ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS: Device can coherently access managed memory\n   concurrently with the CPU.\n - ::CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED: Device supports Compute Preemption.\n - ::CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM: Device can access host registered\n   memory at the same virtual address as the CPU.\n -  ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN: The maximum per block shared memory size\n    suported on this device. This is the maximum value that can be opted into when using the cuFuncSetAttribute() or cuKernelSetAttribute() call.\n    For more details see ::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES\n - ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES: Device accesses pageable memory via the host's\n   page tables.\n - ::CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST: The host can directly access managed memory on the device without migration.\n - ::CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED:  Device supports virtual memory management APIs like ::cuMemAddressReserve, ::cuMemCreate, ::cuMemMap and related APIs\n - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED: Device supports exporting memory to a posix file descriptor with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate\n - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED:  Device supports exporting memory to a Win32 NT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate\n - ::CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED: Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate\n - ::CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR: Maximum number of thread blocks that can reside on a multiprocessor\n - ::CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED: Device supports compressible memory allocation via ::cuMemCreate\n - ::CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE: Maximum L2 persisting lines capacity setting in bytes\n - ::CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE: Maximum value of CUaccessPolicyWindow::num_bytes\n - ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED: Device supports specifying the GPUDirect RDMA flag with ::cuMemCreate.\n - ::CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK: Amount of shared memory per block reserved by CUDA driver in bytes\n - ::CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED: Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays.\n - ::CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED: Device supports using the ::cuMemHostRegister flag ::CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU\n - ::CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED: Device supports using the ::cuMemAllocAsync and ::cuMemPool family of APIs\n - ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED: Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)\n - ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS: The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the ::CUflushGPUDirectRDMAWritesOptions enum\n - ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING: GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::CUGPUDirectRDMAWritesOrdering for the numerical values returned here.\n - ::CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES: Bitmask of handle types supported with mempool based IPC\n - ::CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED: Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays.\n\n \\param pi     - Returned device attribute value\n \\param attrib - Device attribute to query\n \\param dev    - Device handle\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetCount,\n ::cuDeviceGetName,\n ::cuDeviceGetUuid,\n ::cuDeviceGet,\n ::cuDeviceTotalMem,\n ::cuDeviceGetExecAffinitySupport,\n ::cudaDeviceGetAttribute,\n ::cudaGetDeviceProperties"]
    pub fn cuDeviceGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUdevice_attribute,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Return NvSciSync attributes that this device can support.\n\n Returns in \\p nvSciSyncAttrList, the properties of NvSciSync that\n this CUDA device, \\p dev can support. The returned \\p nvSciSyncAttrList\n can be used to create an NvSciSync object that matches this device's capabilities.\n\n If NvSciSyncAttrKey_RequiredPerm field in \\p nvSciSyncAttrList is\n already set this API will return ::CUDA_ERROR_INVALID_VALUE.\n\n The applications should set \\p nvSciSyncAttrList to a valid\n NvSciSyncAttrList failing which this API will return\n ::CUDA_ERROR_INVALID_HANDLE.\n\n The \\p flags controls how applications intends to use\n the NvSciSync created from the \\p nvSciSyncAttrList. The valid flags are:\n - ::CUDA_NVSCISYNC_ATTR_SIGNAL, specifies that the applications intends to\n signal an NvSciSync on this CUDA device.\n - ::CUDA_NVSCISYNC_ATTR_WAIT, specifies that the applications intends to\n wait on an NvSciSync on this CUDA device.\n\n At least one of these flags must be set, failing which the API\n returns ::CUDA_ERROR_INVALID_VALUE. Both the flags are orthogonal\n to one another: a developer may set both these flags that allows to\n set both wait and signal specific attributes in the same \\p nvSciSyncAttrList.\n\n \\param nvSciSyncAttrList     - Return NvSciSync attributes supported.\n \\param dev                   - Valid Cuda Device to get NvSciSync attributes for.\n \\param flags                 - flags describing NvSciSync usage.\n\n \\return\n\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa\n ::cuImportExternalSemaphore,\n ::cuDestroyExternalSemaphore,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync"]
    pub fn cuDeviceGetNvSciSyncAttributes(
        nvSciSyncAttrList: *mut ::std::os::raw::c_void,
        dev: CUdevice,
        flags: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the current memory pool of a device\n\n The memory pool must be local to the specified device.\n ::cuMemAllocAsync allocates from the current mempool of the provided stream's device.\n By default, a device's current memory pool is its default memory pool.\n\n \\note Use ::cuMemAllocFromPoolAsync to specify asynchronous allocations from a device different\n than the one the stream runs on.\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuDeviceGetDefaultMemPool, ::cuDeviceGetMemPool, ::cuMemPoolCreate, ::cuMemPoolDestroy, ::cuMemAllocFromPoolAsync"]
    pub fn cuDeviceSetMemPool(dev: CUdevice, pool: CUmemoryPool) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the current mempool for a device\n\n Returns the last pool provided to ::cuDeviceSetMemPool for this device\n or the device's default memory pool if ::cuDeviceSetMemPool has never been called.\n By default the current mempool is the default mempool for a device.\n Otherwise the returned pool must have been set with ::cuDeviceSetMemPool.\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuDeviceGetDefaultMemPool, ::cuMemPoolCreate, ::cuDeviceSetMemPool"]
    pub fn cuDeviceGetMemPool(pool: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the default mempool of a device\n\n The default mempool of a device contains device memory from that device.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\notefnerr\n\n \\sa ::cuMemAllocAsync, ::cuMemPoolTrimTo, ::cuMemPoolGetAttribute, ::cuMemPoolSetAttribute, cuMemPoolSetAccess, ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuDeviceGetDefaultMemPool(pool_out: *mut CUmemoryPool, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about the execution affinity support of the device.\n\n Returns in \\p *pi whether execution affinity type \\p type is supported by device \\p dev.\n The supported types are:\n - ::CU_EXEC_AFFINITY_TYPE_SM_COUNT: 1 if context with limited SMs is supported by the device,\n   or 0 if not;\n\n \\param pi   - 1 if the execution affinity type \\p type is supported by the device, or 0 if not\n \\param type - Execution affinity type to query\n \\param dev  - Device handle\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetAttribute,\n ::cuDeviceGetCount,\n ::cuDeviceGetName,\n ::cuDeviceGetUuid,\n ::cuDeviceGet,\n ::cuDeviceTotalMem"]
    pub fn cuDeviceGetExecAffinitySupport(
        pi: *mut ::std::os::raw::c_int,
        type_: CUexecAffinityType,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Blocks until remote writes are visible to the specified scope\n\n Blocks until GPUDirect RDMA writes to the target context via mappings\n created through APIs like nvidia_p2p_get_pages (see\n https://docs.nvidia.com/cuda/gpudirect-rdma for more information), are\n visible to the specified scope.\n\n If the scope equals or lies within the scope indicated by\n ::CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING, the call\n will be a no-op and can be safely omitted for performance. This can be\n determined by comparing the numerical values between the two enums, with\n smaller scopes having smaller values.\n\n Users may query support for this API via\n ::CU_DEVICE_ATTRIBUTE_FLUSH_FLUSH_GPU_DIRECT_RDMA_OPTIONS.\n\n \\param target - The target of the operation, see ::CUflushGPUDirectRDMAWritesTarget\n \\param scope  - The scope of the operation, see ::CUflushGPUDirectRDMAWritesScope\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n \\notefnerr\n"]
    pub fn cuFlushGPUDirectRDMAWrites(
        target: CUflushGPUDirectRDMAWritesTarget,
        scope: CUflushGPUDirectRDMAWritesScope,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns properties for a selected device\n\n \\deprecated\n\n This function was deprecated as of CUDA 5.0 and replaced by ::cuDeviceGetAttribute().\n\n Returns in \\p *prop the properties of device \\p dev. The ::CUdevprop\n structure is defined as:\n\n \\code\ntypedef struct CUdevprop_st {\nint maxThreadsPerBlock;\nint maxThreadsDim[3];\nint maxGridSize[3];\nint sharedMemPerBlock;\nint totalConstantMemory;\nint SIMDWidth;\nint memPitch;\nint regsPerBlock;\nint clockRate;\nint textureAlign\n} CUdevprop;\n \\endcode\n where:\n\n - ::maxThreadsPerBlock is the maximum number of threads per block;\n - ::maxThreadsDim[3] is the maximum sizes of each dimension of a block;\n - ::maxGridSize[3] is the maximum sizes of each dimension of a grid;\n - ::sharedMemPerBlock is the total amount of shared memory available per\n   block in bytes;\n - ::totalConstantMemory is the total amount of constant memory available on\n   the device in bytes;\n - ::SIMDWidth is the warp size;\n - ::memPitch is the maximum pitch allowed by the memory copy functions that\n   involve memory regions allocated through ::cuMemAllocPitch();\n - ::regsPerBlock is the total number of registers available per block;\n - ::clockRate is the clock frequency in kilohertz;\n - ::textureAlign is the alignment requirement; texture base addresses that\n   are aligned to ::textureAlign bytes do not need an offset applied to\n   texture fetches.\n\n \\param prop - Returned properties of device\n \\param dev  - Device to get properties for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetAttribute,\n ::cuDeviceGetCount,\n ::cuDeviceGetName,\n ::cuDeviceGetUuid,\n ::cuDeviceGet,\n ::cuDeviceTotalMem"]
    pub fn cuDeviceGetProperties(prop: *mut CUdevprop, dev: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the compute capability of the device\n\n \\deprecated\n\n This function was deprecated as of CUDA 5.0 and its functionality superceded\n by ::cuDeviceGetAttribute().\n\n Returns in \\p *major and \\p *minor the major and minor revision numbers that\n define the compute capability of the device \\p dev.\n\n \\param major - Major revision number\n \\param minor - Minor revision number\n \\param dev   - Device handle\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGetAttribute,\n ::cuDeviceGetCount,\n ::cuDeviceGetName,\n ::cuDeviceGetUuid,\n ::cuDeviceGet,\n ::cuDeviceTotalMem"]
    pub fn cuDeviceComputeCapability(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retain the primary context on the GPU\n\n Retains the primary context on the device.\n Once the user successfully retains the primary context, the primary context\n will be active and available to the user until the user releases it\n with ::cuDevicePrimaryCtxRelease() or resets it with ::cuDevicePrimaryCtxReset().\n Unlike ::cuCtxCreate() the newly retained context is not pushed onto the stack.\n\n Retaining the primary context for the first time will fail with ::CUDA_ERROR_UNKNOWN\n if the compute mode of the device is ::CU_COMPUTEMODE_PROHIBITED. The function\n ::cuDeviceGetAttribute() can be used with ::CU_DEVICE_ATTRIBUTE_COMPUTE_MODE to\n determine the compute mode  of the device.\n The <i>nvidia-smi</i> tool can be used to set the compute mode for\n devices. Documentation for <i>nvidia-smi</i> can be obtained by passing a\n -h option to it.\n\n Please note that the primary context always supports pinned allocations. Other\n flags can be specified by ::cuDevicePrimaryCtxSetFlags().\n\n \\param pctx  - Returned context handle of the new context\n \\param dev   - Device for which primary context is requested\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa ::cuDevicePrimaryCtxRelease,\n ::cuDevicePrimaryCtxSetFlags,\n ::cuCtxCreate,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize"]
    pub fn cuDevicePrimaryCtxRetain(pctx: *mut CUcontext, dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxRelease_v2(dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxSetFlags_v2(dev: CUdevice, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Get the state of the primary context\n\n Returns in \\p *flags the flags for the primary context of \\p dev, and in\n \\p *active whether it is active.  See ::cuDevicePrimaryCtxSetFlags for flag\n values.\n\n \\param dev    - Device to get primary context flags for\n \\param flags  - Pointer to store flags\n \\param active - Pointer to store context state; 0 = inactive, 1 = active\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_INVALID_VALUE,\n \\notefnerr\n\n \\sa\n ::cuDevicePrimaryCtxSetFlags,\n ::cuCtxGetFlags,\n ::cudaGetDeviceFlags"]
    pub fn cuDevicePrimaryCtxGetState(
        dev: CUdevice,
        flags: *mut ::std::os::raw::c_uint,
        active: *mut ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    pub fn cuDevicePrimaryCtxReset_v2(dev: CUdevice) -> CUresult;
}
extern "C" {
    pub fn cuCtxCreate_v2(
        pctx: *mut CUcontext,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxCreate_v3(
        pctx: *mut CUcontext,
        paramsArray: *mut CUexecAffinityParam,
        numParams: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuCtxDestroy_v2(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxPushCurrent_v2(ctx: CUcontext) -> CUresult;
}
extern "C" {
    pub fn cuCtxPopCurrent_v2(pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Binds the specified CUDA context to the calling CPU thread\n\n Binds the specified CUDA context to the calling CPU thread.\n If \\p ctx is NULL then the CUDA context previously bound to the\n calling CPU thread is unbound and ::CUDA_SUCCESS is returned.\n\n If there exists a CUDA context stack on the calling CPU thread, this\n will replace the top of that stack with \\p ctx.\n If \\p ctx is NULL then this will be equivalent to popping the top\n of the calling CPU thread's CUDA context stack (or a no-op if the\n calling CPU thread's CUDA context stack is empty).\n\n \\param ctx - Context to bind to the calling CPU thread\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT\n \\notefnerr\n\n \\sa\n ::cuCtxGetCurrent,\n ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cudaSetDevice"]
    pub fn cuCtxSetCurrent(ctx: CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the CUDA context bound to the calling CPU thread.\n\n Returns in \\p *pctx the CUDA context bound to the calling CPU thread.\n If no context is bound to the calling CPU thread then \\p *pctx is\n set to NULL and ::CUDA_SUCCESS is returned.\n\n \\param pctx - Returned context handle\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n \\notefnerr\n\n \\sa\n ::cuCtxSetCurrent,\n ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cudaGetDevice"]
    pub fn cuCtxGetCurrent(pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the device ID for the current context\n\n Returns in \\p *device the ordinal of the current context's device.\n\n \\param device - Returned device ID for the current context\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize,\n ::cudaGetDevice"]
    pub fn cuCtxGetDevice(device: *mut CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the flags for the current context\n\n Returns in \\p *flags the flags of the current context. See ::cuCtxCreate\n for flag values.\n\n \\param flags - Pointer to store flags of current context\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetCurrent,\n ::cuCtxGetDevice,\n ::cuCtxGetLimit,\n ::cuCtxGetSharedMemConfig,\n ::cuCtxGetStreamPriorityRange,\n ::cudaGetDeviceFlags"]
    pub fn cuCtxGetFlags(flags: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the unique Id associated with the context supplied\n\n Returns in \\p ctxId the unique Id which is associated with a given context.\n The Id is unique for the life of the program for this instance of CUDA.\n If context is supplied as NULL and there is one current, the Id of the\n current context is returned.\n\n \\param ctx - Context for which to obtain the Id\n \\param ctxId - Pointer to store the Id of the context\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_CONTEXT_IS_DESTROYED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPushCurrent"]
    pub fn cuCtxGetId(ctx: CUcontext, ctxId: *mut ::std::os::raw::c_ulonglong) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Block for a context's tasks to complete\n\n Blocks until the device has completed all preceding requested tasks.\n ::cuCtxSynchronize() returns an error if one of the preceding tasks failed.\n If the context was created with the ::CU_CTX_SCHED_BLOCKING_SYNC flag, the\n CPU thread will block until the GPU context has finished its work.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSetLimit,\n ::cudaDeviceSynchronize"]
    pub fn cuCtxSynchronize() -> CUresult;
}
extern "C" {
    #[doc = " \\brief Set resource limits\n\n Setting \\p limit to \\p value is a request by the application to update\n the current limit maintained by the context. The driver is free to\n modify the requested value to meet h/w requirements (this could be\n clamping to minimum or maximum values, rounding up to nearest element\n size, etc). The application can use ::cuCtxGetLimit() to find out exactly\n what the limit has been set to.\n\n Setting each ::CUlimit has its own specific restrictions, so each is\n discussed here.\n\n - ::CU_LIMIT_STACK_SIZE controls the stack size in bytes of each GPU thread.\n   The driver automatically increases the per-thread stack size\n   for each kernel launch as needed. This size isn't reset back to the\n   original value after each launch. Setting this value will take effect\n   immediately, and if necessary, the device will block until all preceding\n   requested tasks are complete.\n\n - ::CU_LIMIT_PRINTF_FIFO_SIZE controls the size in bytes of the FIFO used\n   by the ::printf() device system call. Setting ::CU_LIMIT_PRINTF_FIFO_SIZE\n   must be performed before launching any kernel that uses the ::printf()\n   device system call, otherwise ::CUDA_ERROR_INVALID_VALUE will be returned.\n\n - ::CU_LIMIT_MALLOC_HEAP_SIZE controls the size in bytes of the heap used\n   by the ::malloc() and ::free() device system calls. Setting\n   ::CU_LIMIT_MALLOC_HEAP_SIZE must be performed before launching any kernel\n   that uses the ::malloc() or ::free() device system calls, otherwise\n   ::CUDA_ERROR_INVALID_VALUE will be returned.\n\n - ::CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH controls the maximum nesting depth of\n   a grid at which a thread can safely call ::cudaDeviceSynchronize(). Setting\n   this limit must be performed before any launch of a kernel that uses the\n   device runtime and calls ::cudaDeviceSynchronize() above the default sync\n   depth, two levels of grids. Calls to ::cudaDeviceSynchronize() will fail\n   with error code ::cudaErrorSyncDepthExceeded if the limitation is\n   violated. This limit can be set smaller than the default or up the maximum\n   launch depth of 24. When setting this limit, keep in mind that additional\n   levels of sync depth require the driver to reserve large amounts of device\n   memory which can no longer be used for user allocations. If these\n   reservations of device memory fail, ::cuCtxSetLimit() will return\n   ::CUDA_ERROR_OUT_OF_MEMORY, and the limit can be reset to a lower value.\n   This limit is only applicable to devices of compute capability < 9.0.\n   Attempting to set this limit on devices of other compute capability\n   versions will result in the error ::CUDA_ERROR_UNSUPPORTED_LIMIT being\n   returned.\n\n - ::CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT controls the maximum number of\n   outstanding device runtime launches that can be made from the current\n   context. A grid is outstanding from the point of launch up until the grid\n   is known to have been completed. Device runtime launches which violate\n   this limitation fail and return ::cudaErrorLaunchPendingCountExceeded when\n   ::cudaGetLastError() is called after launch. If more pending launches than\n   the default (2048 launches) are needed for a module using the device\n   runtime, this limit can be increased. Keep in mind that being able to\n   sustain additional pending launches will require the driver to reserve\n   larger amounts of device memory upfront which can no longer be used for\n   allocations. If these reservations fail, ::cuCtxSetLimit() will return\n   ::CUDA_ERROR_OUT_OF_MEMORY, and the limit can be reset to a lower value.\n   This limit is only applicable to devices of compute capability 3.5 and\n   higher. Attempting to set this limit on devices of compute capability less\n   than 3.5 will result in the error ::CUDA_ERROR_UNSUPPORTED_LIMIT being\n   returned.\n\n - ::CU_LIMIT_MAX_L2_FETCH_GRANULARITY controls the L2 cache fetch granularity.\n   Values can range from 0B to 128B. This is purely a performence hint and\n   it can be ignored or clamped depending on the platform.\n\n - ::CU_LIMIT_PERSISTING_L2_CACHE_SIZE controls size in bytes availabe for\n   persisting L2 cache. This is purely a performance hint and it can be\n   ignored or clamped depending on the platform.\n\n \\param limit - Limit to set\n \\param value - Size of limit\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNSUPPORTED_LIMIT,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_INVALID_CONTEXT\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSynchronize,\n ::cudaDeviceSetLimit"]
    pub fn cuCtxSetLimit(limit: CUlimit, value: usize) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns resource limits\n\n Returns in \\p *pvalue the current size of \\p limit.  The supported\n ::CUlimit values are:\n - ::CU_LIMIT_STACK_SIZE: stack size in bytes of each GPU thread.\n - ::CU_LIMIT_PRINTF_FIFO_SIZE: size in bytes of the FIFO used by the\n   ::printf() device system call.\n - ::CU_LIMIT_MALLOC_HEAP_SIZE: size in bytes of the heap used by the\n   ::malloc() and ::free() device system calls.\n - ::CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH: maximum grid depth at which a thread\n   can issue the device runtime call ::cudaDeviceSynchronize() to wait on\n   child grid launches to complete.\n - ::CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT: maximum number of outstanding\n   device runtime launches that can be made from this context.\n - ::CU_LIMIT_MAX_L2_FETCH_GRANULARITY: L2 cache fetch granularity.\n - ::CU_LIMIT_PERSISTING_L2_CACHE_SIZE: Persisting L2 cache size in bytes\n\n \\param limit  - Limit to query\n \\param pvalue - Returned size of limit\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNSUPPORTED_LIMIT\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize,\n ::cudaDeviceGetLimit"]
    pub fn cuCtxGetLimit(pvalue: *mut usize, limit: CUlimit) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the preferred cache configuration for the current context.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this function returns through \\p pconfig the preferred cache configuration\n for the current context. This is only a preference. The driver will use\n the requested configuration if possible, but it is free to choose a different\n configuration if required to execute functions.\n\n This will return a \\p pconfig of ::CU_FUNC_CACHE_PREFER_NONE on devices\n where the size of the L1 cache and shared memory are fixed.\n\n The supported cache configurations are:\n - ::CU_FUNC_CACHE_PREFER_NONE: no preference for shared memory or L1 (default)\n - ::CU_FUNC_CACHE_PREFER_SHARED: prefer larger shared memory and smaller L1 cache\n - ::CU_FUNC_CACHE_PREFER_L1: prefer larger L1 cache and smaller shared memory\n - ::CU_FUNC_CACHE_PREFER_EQUAL: prefer equal sized L1 cache and shared memory\n\n \\param pconfig - Returned cache configuration\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize,\n ::cuFuncSetCacheConfig,\n ::cudaDeviceGetCacheConfig"]
    pub fn cuCtxGetCacheConfig(pconfig: *mut CUfunc_cache) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the preferred cache configuration for the current context.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through \\p config the preferred cache configuration for\n the current context. This is only a preference. The driver will use\n the requested configuration if possible, but it is free to choose a different\n configuration if required to execute the function. Any function preference\n set via ::cuFuncSetCacheConfig() or ::cuKernelSetCacheConfig() will be preferred over this context-wide\n setting. Setting the context-wide cache configuration to\n ::CU_FUNC_CACHE_PREFER_NONE will cause subsequent kernel launches to prefer\n to not change the cache configuration unless required to launch the kernel.\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n The supported cache configurations are:\n - ::CU_FUNC_CACHE_PREFER_NONE: no preference for shared memory or L1 (default)\n - ::CU_FUNC_CACHE_PREFER_SHARED: prefer larger shared memory and smaller L1 cache\n - ::CU_FUNC_CACHE_PREFER_L1: prefer larger L1 cache and smaller shared memory\n - ::CU_FUNC_CACHE_PREFER_EQUAL: prefer equal sized L1 cache and shared memory\n\n \\param config - Requested cache configuration\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize,\n ::cuFuncSetCacheConfig,\n ::cudaDeviceSetCacheConfig,\n ::cuKernelSetCacheConfig"]
    pub fn cuCtxSetCacheConfig(config: CUfunc_cache) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the current shared memory configuration for the current context.\n\n This function will return in \\p pConfig the current size of shared memory banks\n in the current context. On devices with configurable shared memory banks,\n ::cuCtxSetSharedMemConfig can be used to change this setting, so that all\n subsequent kernel launches will by default use the new bank size. When\n ::cuCtxGetSharedMemConfig is called on devices without configurable shared\n memory, it will return the fixed bank size of the hardware.\n\n The returned bank configurations can be either:\n - ::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE:  shared memory bank width is\n   four bytes.\n - ::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: shared memory bank width will\n   eight bytes.\n\n \\param pConfig - returned shared memory configuration\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize,\n ::cuCtxGetSharedMemConfig,\n ::cuFuncSetCacheConfig,\n ::cudaDeviceGetSharedMemConfig"]
    pub fn cuCtxGetSharedMemConfig(pConfig: *mut CUsharedconfig) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the shared memory configuration for the current context.\n\n On devices with configurable shared memory banks, this function will set\n the context's shared memory bank size which is used for subsequent kernel\n launches.\n\n Changed the shared memory configuration between launches may insert a device\n side synchronization point between those launches.\n\n Changing the shared memory bank size will not increase shared memory usage\n or affect occupancy of kernels, but may have major effects on performance.\n Larger bank sizes will allow for greater potential bandwidth to shared memory,\n but will change what kinds of accesses to shared memory will result in bank\n conflicts.\n\n This function will do nothing on devices with fixed shared memory bank size.\n\n The supported bank configurations are:\n - ::CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE: set bank width to the default initial\n   setting (currently, four bytes).\n - ::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: set shared memory bank width to\n   be natively four bytes.\n - ::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: set shared memory bank width to\n   be natively eight bytes.\n\n \\param config - requested shared memory configuration\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize,\n ::cuCtxGetSharedMemConfig,\n ::cuFuncSetCacheConfig,\n ::cudaDeviceSetSharedMemConfig"]
    pub fn cuCtxSetSharedMemConfig(config: CUsharedconfig) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the context's API version.\n\n Returns a version number in \\p version corresponding to the capabilities of\n the context (e.g. 3010 or 3020), which library developers can use to direct\n callers to a specific API version. If \\p ctx is NULL, returns the API version\n used to create the currently bound context.\n\n Note that new API versions are only introduced when context capabilities are\n changed that break binary compatibility, so the API version and driver version\n may be different. For example, it is valid for the API version to be 3020 while\n the driver version is 4020.\n\n \\param ctx     - Context to check\n \\param version - Pointer to version\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize"]
    pub fn cuCtxGetApiVersion(ctx: CUcontext, version: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns numerical values that correspond to the least and\n greatest stream priorities.\n\n Returns in \\p *leastPriority and \\p *greatestPriority the numerical values that correspond\n to the least and greatest stream priorities respectively. Stream priorities\n follow a convention where lower numbers imply greater priorities. The range of\n meaningful stream priorities is given by [\\p *greatestPriority, \\p *leastPriority].\n If the user attempts to create a stream with a priority value that is\n outside the meaningful range as specified by this API, the priority is\n automatically clamped down or up to either \\p *leastPriority or \\p *greatestPriority\n respectively. See ::cuStreamCreateWithPriority for details on creating a\n priority stream.\n A NULL may be passed in for \\p *leastPriority or \\p *greatestPriority if the value\n is not desired.\n\n This function will return '0' in both \\p *leastPriority and \\p *greatestPriority if\n the current context's device does not support stream priorities\n (see ::cuDeviceGetAttribute).\n\n \\param leastPriority    - Pointer to an int in which the numerical value for least\n                           stream priority is returned\n \\param greatestPriority - Pointer to an int in which the numerical value for greatest\n                           stream priority is returned\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\notefnerr\n\n \\sa ::cuStreamCreateWithPriority,\n ::cuStreamGetPriority,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize,\n ::cudaDeviceGetStreamPriorityRange"]
    pub fn cuCtxGetStreamPriorityRange(
        leastPriority: *mut ::std::os::raw::c_int,
        greatestPriority: *mut ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Resets all persisting lines in cache to normal status.\n\n ::cuCtxResetPersistingL2Cache Resets all persisting lines in cache to normal\n status. Takes effect on function return.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\notefnerr\n\n \\sa\n ::CUaccessPolicyWindow"]
    pub fn cuCtxResetPersistingL2Cache() -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the execution affinity setting for the current context.\n\n Returns in \\p *pExecAffinity the current value of \\p type. The supported\n ::CUexecAffinityType values are:\n - ::CU_EXEC_AFFINITY_TYPE_SM_COUNT: number of SMs the context is limited to use.\n\n \\param type          - Execution affinity type to query\n \\param pExecAffinity - Returned execution affinity\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY\n \\notefnerr\n\n \\sa\n ::CUexecAffinityParam"]
    pub fn cuCtxGetExecAffinity(
        pExecAffinity: *mut CUexecAffinityParam,
        type_: CUexecAffinityType,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Increment a context's usage-count\n\n \\deprecated\n\n Note that this function is deprecated and should not be used.\n\n Increments the usage count of the context and passes back a context handle\n in \\p *pctx that must be passed to ::cuCtxDetach() when the application is\n done with the context. ::cuCtxAttach() fails if there is no context current\n to the thread.\n\n Currently, the \\p flags parameter must be 0.\n\n \\param pctx  - Returned context handle of the current context\n \\param flags - Context attach flags (must be 0)\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxDetach,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize"]
    pub fn cuCtxAttach(pctx: *mut CUcontext, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Decrement a context's usage-count\n\n \\deprecated\n\n Note that this function is deprecated and should not be used.\n\n Decrements the usage count of the context \\p ctx, and destroys the context\n if the usage count goes to 0. The context must be a handle that was passed\n back by ::cuCtxCreate() or ::cuCtxAttach(), and must be current to the\n calling thread.\n\n \\param ctx - Context to destroy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT\n \\notefnerr\n\n \\sa ::cuCtxCreate,\n ::cuCtxDestroy,\n ::cuCtxGetApiVersion,\n ::cuCtxGetCacheConfig,\n ::cuCtxGetDevice,\n ::cuCtxGetFlags,\n ::cuCtxGetLimit,\n ::cuCtxPopCurrent,\n ::cuCtxPushCurrent,\n ::cuCtxSetCacheConfig,\n ::cuCtxSetLimit,\n ::cuCtxSynchronize"]
    pub fn cuCtxDetach(ctx: CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Loads a compute module\n\n Takes a filename \\p fname and loads the corresponding module \\p module into\n the current context. The CUDA driver API does not attempt to lazily\n allocate the resources needed by a module; if the memory for functions and\n data (constant and global) needed by the module cannot be allocated,\n ::cuModuleLoad() fails. The file should be a \\e cubin file as output by\n \\b nvcc, or a \\e PTX file either as output by \\b nvcc or handwritten, or\n a \\e fatbin file as output by \\b nvcc from toolchain 4.0 or later.\n\n \\param module - Returned module\n \\param fname  - Filename of module to load\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_PTX,\n ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,\n ::CUDA_ERROR_NOT_FOUND,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_FILE_NOT_FOUND,\n ::CUDA_ERROR_NO_BINARY_FOR_GPU,\n ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND\n \\notefnerr\n\n \\sa ::cuModuleGetFunction,\n ::cuModuleGetGlobal,\n ::cuModuleGetTexRef,\n ::cuModuleLoadData,\n ::cuModuleLoadDataEx,\n ::cuModuleLoadFatBinary,\n ::cuModuleUnload"]
    pub fn cuModuleLoad(module: *mut CUmodule, fname: *const ::std::os::raw::c_char) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Load a module's data\n\n Takes a pointer \\p image and loads the corresponding module \\p module into\n the current context. The pointer may be obtained by mapping a \\e cubin or\n \\e PTX or \\e fatbin file, passing a \\e cubin or \\e PTX or \\e fatbin file\n as a NULL-terminated text string, or incorporating a \\e cubin or \\e fatbin\n object into the executable resources and using operating system calls such\n as Windows \\c FindResource() to obtain the pointer.\n\n \\param module - Returned module\n \\param image  - Module data to load\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_PTX,\n ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_NO_BINARY_FOR_GPU,\n ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND\n \\notefnerr\n\n \\sa ::cuModuleGetFunction,\n ::cuModuleGetGlobal,\n ::cuModuleGetTexRef,\n ::cuModuleLoad,\n ::cuModuleLoadDataEx,\n ::cuModuleLoadFatBinary,\n ::cuModuleUnload"]
    pub fn cuModuleLoadData(
        module: *mut CUmodule,
        image: *const ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Load a module's data with options\n\n Takes a pointer \\p image and loads the corresponding module \\p module into\n the current context. The pointer may be obtained by mapping a \\e cubin or\n \\e PTX or \\e fatbin file, passing a \\e cubin or \\e PTX or \\e fatbin file\n as a NULL-terminated text string, or incorporating a \\e cubin or \\e fatbin\n object into the executable resources and using operating system calls such\n as Windows \\c FindResource() to obtain the pointer. Options are passed as\n an array via \\p options and any corresponding parameters are passed in\n \\p optionValues. The number of total options is supplied via \\p numOptions.\n Any outputs will be returned via \\p optionValues.\n\n \\param module       - Returned module\n \\param image        - Module data to load\n \\param numOptions   - Number of options\n \\param options      - Options for JIT\n \\param optionValues - Option values for JIT\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_PTX,\n ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_NO_BINARY_FOR_GPU,\n ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND\n \\notefnerr\n\n \\sa ::cuModuleGetFunction,\n ::cuModuleGetGlobal,\n ::cuModuleGetTexRef,\n ::cuModuleLoad,\n ::cuModuleLoadData,\n ::cuModuleLoadFatBinary,\n ::cuModuleUnload"]
    pub fn cuModuleLoadDataEx(
        module: *mut CUmodule,
        image: *const ::std::os::raw::c_void,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Load a module's data\n\n Takes a pointer \\p fatCubin and loads the corresponding module \\p module\n into the current context. The pointer represents a <i>fat binary</i> object,\n which is a collection of different \\e cubin and/or \\e PTX files, all\n representing the same device code, but compiled and optimized for different\n architectures.\n\n Prior to CUDA 4.0, there was no documented API for constructing and using\n fat binary objects by programmers.  Starting with CUDA 4.0, fat binary\n objects can be constructed by providing the <i>-fatbin option</i> to \\b nvcc.\n More information can be found in the \\b nvcc document.\n\n \\param module   - Returned module\n \\param fatCubin - Fat binary to load\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_PTX,\n ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,\n ::CUDA_ERROR_NOT_FOUND,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_NO_BINARY_FOR_GPU,\n ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND\n \\notefnerr\n\n \\sa ::cuModuleGetFunction,\n ::cuModuleGetGlobal,\n ::cuModuleGetTexRef,\n ::cuModuleLoad,\n ::cuModuleLoadData,\n ::cuModuleLoadDataEx,\n ::cuModuleUnload"]
    pub fn cuModuleLoadFatBinary(
        module: *mut CUmodule,
        fatCubin: *const ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unloads a module\n\n Unloads a module \\p hmod from the current context.\n\n \\param hmod - Module to unload\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_destroy_ub\n\n \\sa ::cuModuleGetFunction,\n ::cuModuleGetGlobal,\n ::cuModuleGetTexRef,\n ::cuModuleLoad,\n ::cuModuleLoadData,\n ::cuModuleLoadDataEx,\n ::cuModuleLoadFatBinary"]
    pub fn cuModuleUnload(hmod: CUmodule) -> CUresult;
}
#[doc = "< Lazy Kernel Loading is not enabled"]
pub const CUmoduleLoadingMode_enum_CU_MODULE_EAGER_LOADING: CUmoduleLoadingMode_enum = 1;
#[doc = "< Lazy Kernel Loading is enabled"]
pub const CUmoduleLoadingMode_enum_CU_MODULE_LAZY_LOADING: CUmoduleLoadingMode_enum = 2;
#[doc = " CUDA Lazy Loading status"]
pub type CUmoduleLoadingMode_enum = ::std::os::raw::c_int;
#[doc = " CUDA Lazy Loading status"]
pub use self::CUmoduleLoadingMode_enum as CUmoduleLoadingMode;
extern "C" {
    #[doc = " \\brief Query lazy loading mode\n\n Returns lazy loading mode\n Module loading mode is controlled by CUDA_MODULE_LOADING env variable\n\n \\param mode      - Returns the lazy loading mode\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\notefnerr\n\n \\sa\n ::cuModuleLoad,"]
    pub fn cuModuleGetLoadingMode(mode: *mut CUmoduleLoadingMode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a function handle\n\n Returns in \\p *hfunc the handle of the function of name \\p name located in\n module \\p hmod. If no function of that name exists, ::cuModuleGetFunction()\n returns ::CUDA_ERROR_NOT_FOUND.\n\n \\param hfunc - Returned function handle\n \\param hmod  - Module to retrieve function from\n \\param name  - Name of function to retrieve\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_FOUND\n \\notefnerr\n\n \\sa ::cuModuleGetGlobal,\n ::cuModuleGetTexRef,\n ::cuModuleLoad,\n ::cuModuleLoadData,\n ::cuModuleLoadDataEx,\n ::cuModuleLoadFatBinary,\n ::cuModuleUnload"]
    pub fn cuModuleGetFunction(
        hfunc: *mut CUfunction,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuModuleGetGlobal_v2(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkCreate_v2(
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
        stateOut: *mut CUlinkState,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkAddData_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        data: *mut ::std::os::raw::c_void,
        size: usize,
        name: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    pub fn cuLinkAddFile_v2(
        state: CUlinkState,
        type_: CUjitInputType,
        path: *const ::std::os::raw::c_char,
        numOptions: ::std::os::raw::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Complete a pending linker invocation\n\n Completes the pending linker action and returns the cubin image for the linked\n device code, which can be used with ::cuModuleLoadData.  The cubin is owned by\n \\p state, so it should be loaded before \\p state is destroyed via ::cuLinkDestroy.\n This call does not destroy \\p state.\n\n \\param state    A pending linker invocation\n \\param cubinOut On success, this will point to the output image\n \\param sizeOut  Optional parameter to receive the size of the generated image\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuLinkCreate,\n ::cuLinkAddData,\n ::cuLinkAddFile,\n ::cuLinkDestroy,\n ::cuModuleLoadData"]
    pub fn cuLinkComplete(
        state: CUlinkState,
        cubinOut: *mut *mut ::std::os::raw::c_void,
        sizeOut: *mut usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys state for a JIT linker invocation.\n\n \\param state State object for the linker invocation\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_HANDLE\n\n \\sa ::cuLinkCreate"]
    pub fn cuLinkDestroy(state: CUlinkState) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a handle to a texture reference\n\n \\deprecated\n\n Returns in \\p *pTexRef the handle of the texture reference of name \\p name\n in the module \\p hmod. If no texture reference of that name exists,\n ::cuModuleGetTexRef() returns ::CUDA_ERROR_NOT_FOUND. This texture reference\n handle should not be destroyed, since it will be destroyed when the module\n is unloaded.\n\n \\param pTexRef  - Returned texture reference\n \\param hmod     - Module to retrieve texture reference from\n \\param name     - Name of texture reference to retrieve\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_FOUND\n \\notefnerr\n\n \\sa\n ::cuModuleGetFunction,\n ::cuModuleGetGlobal,\n ::cuModuleGetSurfRef,\n ::cuModuleLoad,\n ::cuModuleLoadData,\n ::cuModuleLoadDataEx,\n ::cuModuleLoadFatBinary,\n ::cuModuleUnload"]
    pub fn cuModuleGetTexRef(
        pTexRef: *mut CUtexref,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a handle to a surface reference\n\n \\deprecated\n\n Returns in \\p *pSurfRef the handle of the surface reference of name \\p name\n in the module \\p hmod. If no surface reference of that name exists,\n ::cuModuleGetSurfRef() returns ::CUDA_ERROR_NOT_FOUND.\n\n \\param pSurfRef  - Returned surface reference\n \\param hmod     - Module to retrieve surface reference from\n \\param name     - Name of surface reference to retrieve\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_FOUND\n \\notefnerr\n\n \\sa\n ::cuModuleGetFunction,\n ::cuModuleGetGlobal,\n ::cuModuleGetTexRef,\n ::cuModuleLoad,\n ::cuModuleLoadData,\n ::cuModuleLoadDataEx,\n ::cuModuleLoadFatBinary,\n ::cuModuleUnload"]
    pub fn cuModuleGetSurfRef(
        pSurfRef: *mut CUsurfref,
        hmod: CUmodule,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Load a library with specified code and options\n\n Takes a pointer \\p code and loads the corresponding library \\p library into\n all contexts existent at the time of the call and future contexts at the time\n of creation until the library is unloaded with ::cuLibraryUnload().\n\n The pointer may be obtained by mapping a \\e cubin or \\e PTX or \\e fatbin file,\n passing a \\e cubin or \\e PTX or \\e fatbin file as a NULL-terminated text string, or\n incorporating a \\e cubin or \\e fatbin object into the executable resources and\n using operating system calls such as Windows \\c FindResource() to obtain the pointer.\n Options are passed as an array via \\p jitOptions and any corresponding parameters are passed in\n \\p jitOptionsValues. The number of total JTT options is supplied via \\p numJitOptions.\n Any outputs will be returned via \\p jitOptionsValues.\n\n \\param library             - Returned library\n \\param code                - Code to load\n \\param jitOptions          - Options for JIT\n \\param jitOptionsValues    - Option values for JIT\n \\param numJitOptions       - Number of options\n \\param libraryOptions      - Options for loading\n \\param libraryOptionValues - Option values for loading\n \\param numLibraryOptions   - Number of options for loading\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_PTX,\n ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_NO_BINARY_FOR_GPU,\n ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND\n\n \\sa ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,\n ::cuModuleLoad,\n ::cuModuleLoadData,\n ::cuModuleLoadDataEx"]
    pub fn cuLibraryLoadData(
        library: *mut CUlibrary,
        code: *const ::std::os::raw::c_void,
        jitOptions: *mut CUjit_option,
        jitOptionsValues: *mut *mut ::std::os::raw::c_void,
        numJitOptions: ::std::os::raw::c_uint,
        libraryOptions: *mut CUlibraryOption,
        libraryOptionValues: *mut *mut ::std::os::raw::c_void,
        numLibraryOptions: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Load a library with specified file and options\n\n Takes a filename \\p fileName and loads the corresponding library \\p library into\n all contexts existent at the time of the call and future contexts at the time of\n creation until the library is unloaded with ::cuLibraryUnload().\n\n The file should be a \\e cubin file as output by \\b nvcc, or a \\e PTX file either\n as output by \\b nvcc or handwritten, or a \\e fatbin file as output by \\b nvcc\n from toolchain 4.0 or later.\n\n Options are passed as an array via \\p jitOptions and any corresponding parameters are\n passed in \\p jitOptionsValues. The number of total options is supplied via \\p numJitOptions.\n Any outputs will be returned via \\p jitOptionsValues.\n\n \\param library             - Returned library\n \\param code                - Code to load\n \\param jitOptions          - Options for JIT\n \\param jitOptionsValues    - Option values for JIT\n \\param numJitOptions       - Number of options\n \\param libraryOptions      - Options for loading\n \\param libraryOptionValues - Option values for loading\n \\param numLibraryOptions   - Number of options for loading\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_PTX,\n ::CUDA_ERROR_UNSUPPORTED_PTX_VERSION,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_NO_BINARY_FOR_GPU,\n ::CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_JIT_COMPILER_NOT_FOUND\n\n \\sa ::cuLibraryLoadData,\n :: cuLibraryUnload,\n ::cuModuleLoad,\n ::cuModuleLoadData,\n ::cuModuleLoadDataEx"]
    pub fn cuLibraryLoadFromFile(
        library: *mut CUlibrary,
        fileName: *const ::std::os::raw::c_char,
        jitOptions: *mut CUjit_option,
        jitOptionsValues: *mut *mut ::std::os::raw::c_void,
        numJitOptions: ::std::os::raw::c_uint,
        libraryOptions: *mut CUlibraryOption,
        libraryOptionValues: *mut *mut ::std::os::raw::c_void,
        numLibraryOptions: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unloads a library\n\n Unloads the library specified with \\p library\n\n \\param library - Library to unload\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuLibraryLoadData\n ::cuLibraryLoadFromFile,\n ::cuModuleUnload"]
    pub fn cuLibraryUnload(library: CUlibrary) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a kernel handle\n\n Returns in \\p pKernel the handle of the kernel with name \\p name located in library \\p library.\n If kernel handle is not found, the call returns ::CUDA_ERROR_NOT_FOUND.\n\n \\param pKernel - Returned kernel handle\n \\param library - Library to retrieve kernel from\n \\param name - Name of kernel to retrieve\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_FOUND,\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,\n ::cuKernelGetFunction,\n ::cuLibraryGetModule,\n ::cuModuleGetFunction"]
    pub fn cuLibraryGetKernel(
        pKernel: *mut CUkernel,
        library: CUlibrary,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a module handle\n\n Returns in \\p pMod the module handle associated with the current context located in\n library \\p library. If module handle is not found, the call returns ::CUDA_ERROR_NOT_FOUND.\n\n \\param pMod - Returned module handle\n \\param library - Library to retrieve module from\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_FOUND,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_CONTEXT_IS_DESTROYED\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,\n ::cuModuleGetFunction"]
    pub fn cuLibraryGetModule(pMod: *mut CUmodule, library: CUlibrary) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a function handle\n\n Returns in \\p pFunc the handle of the function for the requested kernel \\p kernel and\n the current context. If function handle is not found, the call returns ::CUDA_ERROR_NOT_FOUND.\n\n \\param pFunc - Returned function handle\n \\param kernel - Kernel to retrieve function for the requested context\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_FOUND,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_CONTEXT_IS_DESTROYED\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,\n ::cuLibraryGetKernel,\n ::cuLibraryGetModule,\n ::cuModuleGetFunction"]
    pub fn cuKernelGetFunction(pFunc: *mut CUfunction, kernel: CUkernel) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a global device pointer\n\n Returns in \\p *dptr and \\p *bytes the base pointer and size of the global with\n name \\p name for the requested library \\p library and the current context.\n If no global for the requested name \\p name exists, the call returns ::CUDA_ERROR_NOT_FOUND.\n One of the parameters \\p dptr or \\p bytes (not both) can be NULL in which\n case it is ignored.\n\n \\param dptr - Returned global device pointer for the requested context\n \\param bytes - Returned global size in bytes\n \\param library - Library to retrieve global from\n \\param name - Name of global to retrieve\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_FOUND,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_CONTEXT_IS_DESTROYED\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,\n ::cuLibraryGetModule,\n cuModuleGetGlobal"]
    pub fn cuLibraryGetGlobal(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        library: CUlibrary,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a pointer to managed memory\n\n Returns in \\p *dptr and \\p *bytes the base pointer and size of the managed memory with\n name \\p name for the requested library \\p library. If no managed memory with the\n requested name \\p name exists, the call returns ::CUDA_ERROR_NOT_FOUND. One of the parameters\n \\p dptr or \\p bytes (not both) can be NULL in which case it is ignored.\n Note that managed memory for library \\p library is shared across devices and is registered\n when the library is loaded into atleast one context.\n\n \\note The API requires a CUDA context to be present and initialized on at least one device.\n If no context is present, the call returns ::CUDA_ERROR_NOT_FOUND.\n\n \\param dptr - Returned pointer to the managed memory\n \\param bytes - Returned memory size in bytes\n \\param library - Library to retrieve managed memory from\n \\param name - Name of managed memory to retrieve\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_FOUND,\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,"]
    pub fn cuLibraryGetManaged(
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        library: CUlibrary,
        name: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a pointer to a universal function\n\n Returns in \\p *fptr the function pointer to a global function denoted by \\p symbol.\n If no universal function with name \\p symbol exists, the call returns ::CUDA_ERROR_NOT_FOUND.\n If there is no device with attrubute ::CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS present in the system,\n the call may return ::CUDA_ERROR_NOT_FOUND.\n\n \\param fptr - Returned pointer to a universal function\n \\param library - Library to retrieve function pointer memory from\n \\param symbol - Name of function pointer to retrieve\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_FOUND,\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,"]
    pub fn cuLibraryGetUnifiedFunction(
        fptr: *mut *mut ::std::os::raw::c_void,
        library: CUlibrary,
        symbol: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about a kernel\n\n Returns in \\p *pi the integer value of the attribute \\p attrib for the kernel\n \\p kernel for the requested device \\p dev. The supported attributes are:\n - ::CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK: The maximum number of threads\n   per block, beyond which a launch of the kernel would fail. This number\n   depends on both the kernel and the requested device.\n - ::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: The size in bytes of\n   statically-allocated shared memory per block required by this kernel.\n   This does not include dynamically-allocated shared memory requested by\n   the user at runtime.\n - ::CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: The size in bytes of user-allocated\n   constant memory required by this kernel.\n - ::CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: The size in bytes of local memory\n   used by each thread of this kernel.\n - ::CU_FUNC_ATTRIBUTE_NUM_REGS: The number of registers used by each thread\n   of this kernel.\n - ::CU_FUNC_ATTRIBUTE_PTX_VERSION: The PTX virtual architecture version for\n   which the kernel was compiled. This value is the major PTX version * 10\n   + the minor PTX version, so a PTX version 1.3 function would return the\n   value 13. Note that this may return the undefined value of 0 for cubins\n   compiled prior to CUDA 3.0.\n - ::CU_FUNC_ATTRIBUTE_BINARY_VERSION: The binary architecture version for\n   which the kernel was compiled. This value is the major binary\n   version * 10 + the minor binary version, so a binary version 1.3 function\n   would return the value 13. Note that this will return a value of 10 for\n   legacy cubins that do not have a properly-encoded binary architecture\n   version.\n - ::CU_FUNC_CACHE_MODE_CA: The attribute to indicate whether the kernel has\n   been compiled with user specified option \"-Xptxas --dlcm=ca\" set.\n - ::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES: The maximum size in bytes of\n   dynamically-allocated shared memory.\n - ::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: Preferred shared memory-L1\n   cache split ratio in percent of total shared memory.\n - ::CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET: If this attribute is set, the\n   kernel must launch with a valid cluster size specified.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH: The required cluster width in\n   blocks.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT: The required cluster height in\n   blocks.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH: The required cluster depth in\n   blocks.\n - ::CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED: Indicates whether\n   the function can be launched with non-portable cluster size. 1 is allowed,\n   0 is disallowed. A non-portable cluster size may only function on the\n   specific SKUs the program is tested on. The launch might fail if the\n   program is run on a different hardware platform. CUDA API provides\n   cudaOccupancyMaxActiveClusters to assist with checking whether the desired\n   size can be launched on the current device. A portable cluster size is\n   guaranteed to be functional on all compute capabilities higher than the\n   target compute capability. The portable cluster size for sm_90 is 8 blocks\n   per cluster. This value may increase for future compute capabilities. The\n   specific hardware unit may support higher cluster sizes thats not\n   guaranteed to be portable.\n - ::CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: The block\n   scheduling policy of a function. The value type is CUclusterSchedulingPolicy.\n\n \\note If another thread is trying to set the same attribute on the same device using\n ::cuKernelSetAttribute() simultaneously, the attribute query will give the old or new\n value depending on the interleavings chosen by the OS scheduler and memory consistency.\n\n \\param pi     - Returned attribute value\n \\param attrib - Attribute requested\n \\param kernel  - Kernel to query attribute of\n \\param dev - Device to query attribute of\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,\n ::cuKernelSetAttribute,\n ::cuLibraryGetKernel,\n ::cuLaunchKernel,\n ::cuKernelGetFunction,\n ::cuLibraryGetModule,\n ::cuModuleGetFunction,\n ::cuFuncGetAttribute"]
    pub fn cuKernelGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUfunction_attribute,
        kernel: CUkernel,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets information about a kernel\n\n This call sets the value of a specified attribute \\p attrib on the kernel \\p kernel\n for the requested device \\p dev to an integer value specified by \\p val.\n This function returns CUDA_SUCCESS if the new value of the attribute could be\n successfully set. If the set fails, this call will return an error.\n Not all attributes can have values set. Attempting to set a value on a read-only\n attribute will result in an error (CUDA_ERROR_INVALID_VALUE)\n\n Note that attributes set using ::cuFuncSetAttribute() will override the attribute\n set by this API irrespective of whether the call to ::cuFuncSetAttribute() is made\n before or after this API call. However, ::cuKernelGetAttribute() will always\n return the attribute value set by this API.\n\n Supported attributes are:\n - ::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES: This is the maximum size in bytes of\n   dynamically-allocated shared memory. The value should contain the requested\n   maximum size of dynamically-allocated shared memory. The sum of this value and\n   the function attribute ::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES cannot exceed the\n   device attribute ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN.\n   The maximal size of requestable dynamic shared memory may differ by GPU\n   architecture.\n - ::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: On devices where the L1\n   cache and shared memory use the same hardware resources, this sets the shared memory\n   carveout preference, in percent of the total shared memory.\n   See ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR\n   This is only a hint, and the driver can choose a different ratio if required to execute the function.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH: The required cluster width in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT: The required cluster height in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH: The required cluster depth in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - ::CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: The block\n   scheduling policy of a function. The value type is CUclusterSchedulingPolicy.\n\n \\note The API has stricter locking requirements in comparison to its legacy counterpart\n ::cuFuncSetAttribute() due to device-wide semantics. If multiple threads are trying to\n set the same attribute on the same device simultaneously, the attribute setting will depend\n on the interleavings chosen by the OS scheduler and memory consistency.\n\n \\param attrib - Attribute requested\n \\param val - Value to set\n \\param kernel  - Kernel to set attribute of\n \\param dev - Device to set attribute of\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,\n ::cuKernelGetAttribute,\n ::cuLibraryGetKernel,\n ::cuLaunchKernel,\n ::cuKernelGetFunction,\n ::cuLibraryGetModule,\n ::cuModuleGetFunction,\n ::cuFuncSetAttribute"]
    pub fn cuKernelSetAttribute(
        attrib: CUfunction_attribute,
        val: ::std::os::raw::c_int,
        kernel: CUkernel,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the preferred cache configuration for a device kernel.\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through \\p config the preferred cache configuration for\n the device kernel \\p kernel on the requested device \\p dev. This is only a preference.\n The driver will use the requested configuration if possible, but it is free to choose a different\n configuration if required to execute \\p kernel.  Any context-wide preference\n set via ::cuCtxSetCacheConfig() will be overridden by this per-kernel\n setting.\n\n Note that attributes set using ::cuFuncSetCacheConfig() will override the attribute\n set by this API irrespective of whether the call to ::cuFuncSetCacheConfig() is made\n before or after this API call.\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n\n The supported cache configurations are:\n - ::CU_FUNC_CACHE_PREFER_NONE: no preference for shared memory or L1 (default)\n - ::CU_FUNC_CACHE_PREFER_SHARED: prefer larger shared memory and smaller L1 cache\n - ::CU_FUNC_CACHE_PREFER_L1: prefer larger L1 cache and smaller shared memory\n - ::CU_FUNC_CACHE_PREFER_EQUAL: prefer equal sized L1 cache and shared memory\n\n \\note The API has stricter locking requirements in comparison to its legacy counterpart\n ::cuFuncSetCacheConfig() due to device-wide semantics. If multiple threads are trying to\n set a config on the same device simultaneously, the cache config setting will depend\n on the interleavings chosen by the OS scheduler and memory consistency.\n\n \\param kernel  - Kernel to configure cache for\n \\param config - Requested cache configuration\n \\param dev - Device to set attribute of\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuLibraryLoadData,\n ::cuLibraryLoadFromFile,\n ::cuLibraryUnload,\n ::cuLibraryGetKernel,\n ::cuKernelGetFunction,\n ::cuLibraryGetModule,\n ::cuModuleGetFunction,\n ::cuFuncSetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuLaunchKernel"]
    pub fn cuKernelSetCacheConfig(
        kernel: CUkernel,
        config: CUfunc_cache,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemGetInfo_v2(free: *mut usize, total: *mut usize) -> CUresult;
}
extern "C" {
    pub fn cuMemAlloc_v2(dptr: *mut CUdeviceptr, bytesize: usize) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocPitch_v2(
        dptr: *mut CUdeviceptr,
        pPitch: *mut usize,
        WidthInBytes: usize,
        Height: usize,
        ElementSizeBytes: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemFree_v2(dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuMemGetAddressRange_v2(
        pbase: *mut CUdeviceptr,
        psize: *mut usize,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemAllocHost_v2(pp: *mut *mut ::std::os::raw::c_void, bytesize: usize) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Frees page-locked host memory\n\n Frees the memory space pointed to by \\p p, which must have been returned by\n a previous call to ::cuMemAllocHost().\n\n \\param p - Pointer to memory to free\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,\n ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,\n ::cudaFreeHost"]
    pub fn cuMemFreeHost(p: *mut ::std::os::raw::c_void) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocates page-locked host memory\n\n Allocates \\p bytesize bytes of host memory that is page-locked and accessible\n to the device. The driver tracks the virtual memory ranges allocated with\n this function and automatically accelerates calls to functions such as\n ::cuMemcpyHtoD(). Since the memory can be accessed directly by the device,\n it can be read or written with much higher bandwidth than pageable memory\n obtained with functions such as ::malloc(). Allocating excessive amounts of\n pinned memory may degrade system performance, since it reduces the amount\n of memory available to the system for paging. As a result, this function is\n best used sparingly to allocate staging areas for data exchange between\n host and device.\n\n The \\p Flags parameter enables different options to be specified that\n affect the allocation, as follows.\n\n - ::CU_MEMHOSTALLOC_PORTABLE: The memory returned by this call will be\n   considered as pinned memory by all CUDA contexts, not just the one that\n   performed the allocation.\n\n - ::CU_MEMHOSTALLOC_DEVICEMAP: Maps the allocation into the CUDA address\n   space. The device pointer to the memory may be obtained by calling\n   ::cuMemHostGetDevicePointer().\n\n - ::CU_MEMHOSTALLOC_WRITECOMBINED: Allocates the memory as write-combined\n   (WC). WC memory can be transferred across the PCI Express bus more\n   quickly on some system configurations, but cannot be read efficiently by\n   most CPUs. WC memory is a good option for buffers that will be written by\n   the CPU and read by the GPU via mapped pinned memory or host->device\n   transfers.\n\n All of these flags are orthogonal to one another: a developer may allocate\n memory that is portable, mapped and/or write-combined with no restrictions.\n\n The ::CU_MEMHOSTALLOC_DEVICEMAP flag may be specified on CUDA contexts for\n devices that do not support mapped pinned memory. The failure is deferred\n to ::cuMemHostGetDevicePointer() because the memory may be mapped into\n other CUDA contexts via the ::CU_MEMHOSTALLOC_PORTABLE flag.\n\n The memory allocated by this function must be freed with ::cuMemFreeHost().\n\n Note all host memory allocated using ::cuMemHostAlloc() will automatically\n be immediately accessible to all contexts on all devices which support unified\n addressing (as may be queried using ::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING).\n Unless the flag ::CU_MEMHOSTALLOC_WRITECOMBINED is specified, the device pointer\n that may be used to access this host memory from those contexts is always equal\n to the returned host pointer \\p *pp.  If the flag ::CU_MEMHOSTALLOC_WRITECOMBINED\n is specified, then the function ::cuMemHostGetDevicePointer() must be used\n to query the device pointer, even if the context supports unified addressing.\n See \\ref CUDA_UNIFIED for additional details.\n\n \\param pp       - Returned host pointer to page-locked memory\n \\param bytesize - Requested allocation size in bytes\n \\param Flags    - Flags for allocation request\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\notefnerr\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,\n ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,\n ::cudaHostAlloc"]
    pub fn cuMemHostAlloc(
        pp: *mut *mut ::std::os::raw::c_void,
        bytesize: usize,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemHostGetDevicePointer_v2(
        pdptr: *mut CUdeviceptr,
        p: *mut ::std::os::raw::c_void,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Passes back flags that were used for a pinned allocation\n\n Passes back the flags \\p pFlags that were specified when allocating\n the pinned host buffer \\p p allocated by ::cuMemHostAlloc.\n\n ::cuMemHostGetFlags() will fail if the pointer does not reside in\n an allocation performed by ::cuMemAllocHost() or ::cuMemHostAlloc().\n\n \\param pFlags - Returned flags word\n \\param p     - Host pointer\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa\n ::cuMemAllocHost,\n ::cuMemHostAlloc,\n ::cudaHostGetFlags"]
    pub fn cuMemHostGetFlags(
        pFlags: *mut ::std::os::raw::c_uint,
        p: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocates memory that will be automatically managed by the Unified Memory system\n\n Allocates \\p bytesize bytes of managed memory on the device and returns in\n \\p *dptr a pointer to the allocated memory. If the device doesn't support\n allocating managed memory, ::CUDA_ERROR_NOT_SUPPORTED is returned. Support\n for managed memory can be queried using the device attribute\n ::CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY. The allocated memory is suitably\n aligned for any kind of variable. The memory is not cleared. If \\p bytesize\n is 0, ::cuMemAllocManaged returns ::CUDA_ERROR_INVALID_VALUE. The pointer\n is valid on the CPU and on all GPUs in the system that support managed memory.\n All accesses to this pointer must obey the Unified Memory programming model.\n\n \\p flags specifies the default stream association for this allocation.\n \\p flags must be one of ::CU_MEM_ATTACH_GLOBAL or ::CU_MEM_ATTACH_HOST. If\n ::CU_MEM_ATTACH_GLOBAL is specified, then this memory is accessible from\n any stream on any device. If ::CU_MEM_ATTACH_HOST is specified, then the\n allocation should not be accessed from devices that have a zero value for the\n device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS; an explicit call to\n ::cuStreamAttachMemAsync will be required to enable access on such devices.\n\n If the association is later changed via ::cuStreamAttachMemAsync to\n a single stream, the default association as specifed during ::cuMemAllocManaged\n is restored when that stream is destroyed. For __managed__ variables, the\n default association is always ::CU_MEM_ATTACH_GLOBAL. Note that destroying a\n stream is an asynchronous operation, and as a result, the change to default\n association won't happen until all work in the stream has completed.\n\n Memory allocated with ::cuMemAllocManaged should be released with ::cuMemFree.\n\n Device memory oversubscription is possible for GPUs that have a non-zero value for the\n device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS. Managed memory on\n such GPUs may be evicted from device memory to host memory at any time by the Unified\n Memory driver in order to make room for other allocations.\n\n In a multi-GPU system where all GPUs have a non-zero value for the device attribute\n ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS, managed memory may not be populated when this\n API returns and instead may be populated on access. In such systems, managed memory can\n migrate to any processor's memory at any time. The Unified Memory driver will employ heuristics to\n maintain data locality and prevent excessive page faults to the extent possible. The application\n can also guide the driver about memory usage patterns via ::cuMemAdvise. The application\n can also explicitly migrate memory to a desired processor's memory via\n ::cuMemPrefetchAsync.\n\n In a multi-GPU system where all of the GPUs have a zero value for the device attribute\n ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS and all the GPUs have peer-to-peer support\n with each other, the physical storage for managed memory is created on the GPU which is active\n at the time ::cuMemAllocManaged is called. All other GPUs will reference the data at reduced\n bandwidth via peer mappings over the PCIe bus. The Unified Memory driver does not migrate\n memory among such GPUs.\n\n In a multi-GPU system where not all GPUs have peer-to-peer support with each other and\n where the value of the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS\n is zero for at least one of those GPUs, the location chosen for physical storage of managed\n memory is system-dependent.\n - On Linux, the location chosen will be device memory as long as the current set of active\n contexts are on devices that either have peer-to-peer support with each other or have a\n non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS.\n If there is an active context on a GPU that does not have a non-zero value for that device\n attribute and it does not have peer-to-peer support with the other devices that have active\n contexts on them, then the location for physical storage will be 'zero-copy' or host memory.\n Note that this means that managed memory that is located in device memory is migrated to\n host memory if a new context is created on a GPU that doesn't have a non-zero value for\n the device attribute and does not support peer-to-peer with at least one of the other devices\n that has an active context. This in turn implies that context creation may fail if there is\n insufficient host memory to migrate all managed allocations.\n - On Windows, the physical storage is always created in 'zero-copy' or host memory.\n All GPUs will reference the data at reduced bandwidth over the PCIe bus. In these\n circumstances, use of the environment variable CUDA_VISIBLE_DEVICES is recommended to\n restrict CUDA to only use those GPUs that have peer-to-peer support.\n Alternatively, users can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a\n non-zero value to force the driver to always use device memory for physical storage.\n When this environment variable is set to a non-zero value, all contexts created in\n that process on devices that support managed memory have to be peer-to-peer compatible\n with each other. Context creation will fail if a context is created on a device that\n supports managed memory and is not peer-to-peer compatible with any of the other\n managed memory supporting devices on which contexts were previously created, even if\n those contexts have been destroyed. These environment variables are described\n in the CUDA programming guide under the \"CUDA environment variables\" section.\n - On ARM, managed memory is not available on discrete gpu with Drive PX-2.\n\n \\param dptr     - Returned device pointer\n \\param bytesize - Requested allocation size in bytes\n \\param flags    - Must be one of ::CU_MEM_ATTACH_GLOBAL or ::CU_MEM_ATTACH_HOST\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\notefnerr\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,\n ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,\n ::cuDeviceGetAttribute, ::cuStreamAttachMemAsync,\n ::cudaMallocManaged"]
    pub fn cuMemAllocManaged(
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a handle to a compute device\n\n Returns in \\p *device a device handle given a PCI bus ID string.\n\n \\param dev      - Returned device handle\n\n \\param pciBusId - String in one of the following forms:\n [domain]:[bus]:[device].[function]\n [domain]:[bus]:[device]\n [bus]:[device].[function]\n where \\p domain, \\p bus, \\p device, and \\p function are all hexadecimal values\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGet,\n ::cuDeviceGetAttribute,\n ::cuDeviceGetPCIBusId,\n ::cudaDeviceGetByPCIBusId"]
    pub fn cuDeviceGetByPCIBusId(
        dev: *mut CUdevice,
        pciBusId: *const ::std::os::raw::c_char,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a PCI Bus Id string for the device\n\n Returns an ASCII string identifying the device \\p dev in the NULL-terminated\n string pointed to by \\p pciBusId. \\p len specifies the maximum length of the\n string that may be returned.\n\n \\param pciBusId - Returned identifier string for the device in the following format\n [domain]:[bus]:[device].[function]\n where \\p domain, \\p bus, \\p device, and \\p function are all hexadecimal values.\n pciBusId should be large enough to store 13 characters including the NULL-terminator.\n\n \\param len      - Maximum length of string to store in \\p name\n\n \\param dev      - Device to get identifier string for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuDeviceGet,\n ::cuDeviceGetAttribute,\n ::cuDeviceGetByPCIBusId,\n ::cudaDeviceGetPCIBusId"]
    pub fn cuDeviceGetPCIBusId(
        pciBusId: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets an interprocess handle for a previously allocated event\n\n Takes as input a previously allocated event. This event must have been\n created with the ::CU_EVENT_INTERPROCESS and ::CU_EVENT_DISABLE_TIMING\n flags set. This opaque handle may be copied into other processes and\n opened with ::cuIpcOpenEventHandle to allow efficient hardware\n synchronization between GPU work in different processes.\n\n After the event has been opened in the importing process,\n ::cuEventRecord, ::cuEventSynchronize, ::cuStreamWaitEvent and\n ::cuEventQuery may be used in either process. Performing operations\n on the imported event after the exported event has been freed\n with ::cuEventDestroy will result in undefined behavior.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is restricted to GPUs in TCC mode\n Users can test their device for IPC functionality by calling\n ::cuapiDeviceGetAttribute with ::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED\n\n \\param pHandle - Pointer to a user allocated CUipcEventHandle\n                    in which to return the opaque event handle\n \\param event   - Event allocated with ::CU_EVENT_INTERPROCESS and\n                    ::CU_EVENT_DISABLE_TIMING flags.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_MAP_FAILED,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuEventCreate,\n ::cuEventDestroy,\n ::cuEventSynchronize,\n ::cuEventQuery,\n ::cuStreamWaitEvent,\n ::cuIpcOpenEventHandle,\n ::cuIpcGetMemHandle,\n ::cuIpcOpenMemHandle,\n ::cuIpcCloseMemHandle,\n ::cudaIpcGetEventHandle"]
    pub fn cuIpcGetEventHandle(pHandle: *mut CUipcEventHandle, event: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Opens an interprocess event handle for use in the current process\n\n Opens an interprocess event handle exported from another process with\n ::cuIpcGetEventHandle. This function returns a ::CUevent that behaves like\n a locally created event with the ::CU_EVENT_DISABLE_TIMING flag specified.\n This event must be freed with ::cuEventDestroy.\n\n Performing operations on the imported event after the exported event has\n been freed with ::cuEventDestroy will result in undefined behavior.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is restricted to GPUs in TCC mode\n Users can test their device for IPC functionality by calling\n ::cuapiDeviceGetAttribute with ::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED\n\n \\param phEvent - Returns the imported event\n \\param handle  - Interprocess handle to open\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_MAP_FAILED,\n ::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuEventCreate,\n ::cuEventDestroy,\n ::cuEventSynchronize,\n ::cuEventQuery,\n ::cuStreamWaitEvent,\n ::cuIpcGetEventHandle,\n ::cuIpcGetMemHandle,\n ::cuIpcOpenMemHandle,\n ::cuIpcCloseMemHandle,\n ::cudaIpcOpenEventHandle"]
    pub fn cuIpcOpenEventHandle(phEvent: *mut CUevent, handle: CUipcEventHandle) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets an interprocess memory handle for an existing device memory\n allocation\n\n Takes a pointer to the base of an existing device memory allocation created\n with ::cuMemAlloc and exports it for use in another process. This is a\n lightweight operation and may be called multiple times on an allocation\n without adverse effects.\n\n If a region of memory is freed with ::cuMemFree and a subsequent call\n to ::cuMemAlloc returns memory with the same device address,\n ::cuIpcGetMemHandle will return a unique handle for the\n new memory.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is restricted to GPUs in TCC mode\n Users can test their device for IPC functionality by calling\n ::cuapiDeviceGetAttribute with ::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED\n\n \\param pHandle - Pointer to user allocated ::CUipcMemHandle to return\n                    the handle in.\n \\param dptr    - Base pointer to previously allocated device memory\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_MAP_FAILED,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuMemAlloc,\n ::cuMemFree,\n ::cuIpcGetEventHandle,\n ::cuIpcOpenEventHandle,\n ::cuIpcOpenMemHandle,\n ::cuIpcCloseMemHandle,\n ::cudaIpcGetMemHandle"]
    pub fn cuIpcGetMemHandle(pHandle: *mut CUipcMemHandle, dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuIpcOpenMemHandle_v2(
        pdptr: *mut CUdeviceptr,
        handle: CUipcMemHandle,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Attempts to close memory mapped with ::cuIpcOpenMemHandle\n\n Decrements the reference count of the memory returned by ::cuIpcOpenMemHandle by 1.\n When the reference count reaches 0, this API unmaps the memory. The original allocation\n in the exporting process as well as imported mappings in other processes\n will be unaffected.\n\n Any resources used to enable peer access will be freed if this is the\n last mapping using them.\n\n IPC functionality is restricted to devices with support for unified\n addressing on Linux and Windows operating systems.\n IPC functionality on Windows is restricted to GPUs in TCC mode\n Users can test their device for IPC functionality by calling\n ::cuapiDeviceGetAttribute with ::CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED\n\n \\param dptr - Device pointer returned by ::cuIpcOpenMemHandle\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_MAP_FAILED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE\n \\sa\n ::cuMemAlloc,\n ::cuMemFree,\n ::cuIpcGetEventHandle,\n ::cuIpcOpenEventHandle,\n ::cuIpcGetMemHandle,\n ::cuIpcOpenMemHandle,\n ::cudaIpcCloseMemHandle"]
    pub fn cuIpcCloseMemHandle(dptr: CUdeviceptr) -> CUresult;
}
extern "C" {
    pub fn cuMemHostRegister_v2(
        p: *mut ::std::os::raw::c_void,
        bytesize: usize,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unregisters a memory range that was registered with cuMemHostRegister.\n\n Unmaps the memory range whose base address is specified by \\p p, and makes\n it pageable again.\n\n The base address must be the same one specified to ::cuMemHostRegister().\n\n \\param p - Host pointer to memory to unregister\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED,\n \\notefnerr\n\n \\sa\n ::cuMemHostRegister,\n ::cudaHostUnregister"]
    pub fn cuMemHostUnregister(p: *mut ::std::os::raw::c_void) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies memory\n\n Copies data between two pointers.\n \\p dst and \\p src are base pointers of the destination and source, respectively.\n \\p ByteCount specifies the number of bytes to copy.\n Note that this function infers the type of the transfer (host to host, host to\n   device, device to device, or device to host) from the pointer values.  This\n   function is only allowed in contexts which support unified addressing.\n\n \\param dst - Destination unified virtual address space pointer\n \\param src - Source unified virtual address space pointer\n \\param ByteCount - Size of memory copy in bytes\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_sync\n \\note_memcpy\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,\n ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,\n ::cudaMemcpy,\n ::cudaMemcpyToSymbol,\n ::cudaMemcpyFromSymbol"]
    pub fn cuMemcpy(dst: CUdeviceptr, src: CUdeviceptr, ByteCount: usize) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies device memory between two contexts\n\n Copies from device memory in one context to device memory in another\n context. \\p dstDevice is the base device pointer of the destination memory\n and \\p dstContext is the destination context.  \\p srcDevice is the base\n device pointer of the source memory and \\p srcContext is the source pointer.\n \\p ByteCount specifies the number of bytes to copy.\n\n \\param dstDevice  - Destination device pointer\n \\param dstContext - Destination context\n \\param srcDevice  - Source device pointer\n \\param srcContext - Source context\n \\param ByteCount  - Size of memory copy in bytes\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_sync\n\n \\sa ::cuMemcpyDtoD, ::cuMemcpy3DPeer, ::cuMemcpyDtoDAsync, ::cuMemcpyPeerAsync,\n ::cuMemcpy3DPeerAsync,\n ::cudaMemcpyPeer"]
    pub fn cuMemcpyPeer(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoD_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoH_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoD_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoD_v2(
        dstDevice: CUdeviceptr,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoH_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoA_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2D_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2DUnaligned_v2(pCopy: *const CUDA_MEMCPY2D) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3D_v2(pCopy: *const CUDA_MEMCPY3D) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies memory between contexts\n\n Perform a 3D memory copy according to the parameters specified in\n \\p pCopy.  See the definition of the ::CUDA_MEMCPY3D_PEER structure\n for documentation of its parameters.\n\n \\param pCopy - Parameters for the memory copy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_sync\n\n \\sa ::cuMemcpyDtoD, ::cuMemcpyPeer, ::cuMemcpyDtoDAsync, ::cuMemcpyPeerAsync,\n ::cuMemcpy3DPeerAsync,\n ::cudaMemcpy3DPeer"]
    pub fn cuMemcpy3DPeer(pCopy: *const CUDA_MEMCPY3D_PEER) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies memory asynchronously\n\n Copies data between two pointers.\n \\p dst and \\p src are base pointers of the destination and source, respectively.\n \\p ByteCount specifies the number of bytes to copy.\n Note that this function infers the type of the transfer (host to host, host to\n   device, device to device, or device to host) from the pointer values.  This\n   function is only allowed in contexts which support unified addressing.\n\n \\param dst       - Destination unified virtual address space pointer\n \\param src       - Source unified virtual address space pointer\n \\param ByteCount - Size of memory copy in bytes\n \\param hStream   - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n \\note_async\n \\note_null_stream\n \\note_memcpy\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,\n ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,\n ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async,\n ::cuMemsetD32, ::cuMemsetD32Async,\n ::cudaMemcpyAsync,\n ::cudaMemcpyToSymbolAsync,\n ::cudaMemcpyFromSymbolAsync"]
    pub fn cuMemcpyAsync(
        dst: CUdeviceptr,
        src: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies device memory between two contexts asynchronously.\n\n Copies from device memory in one context to device memory in another\n context. \\p dstDevice is the base device pointer of the destination memory\n and \\p dstContext is the destination context.  \\p srcDevice is the base\n device pointer of the source memory and \\p srcContext is the source pointer.\n \\p ByteCount specifies the number of bytes to copy.\n\n \\param dstDevice  - Destination device pointer\n \\param dstContext - Destination context\n \\param srcDevice  - Source device pointer\n \\param srcContext - Source context\n \\param ByteCount  - Size of memory copy in bytes\n \\param hStream    - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n \\note_async\n \\note_null_stream\n\n \\sa ::cuMemcpyDtoD, ::cuMemcpyPeer, ::cuMemcpy3DPeer, ::cuMemcpyDtoDAsync,\n ::cuMemcpy3DPeerAsync,\n ::cudaMemcpyPeerAsync"]
    pub fn cuMemcpyPeerAsync(
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoHAsync_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyDtoDAsync_v2(
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyHtoAAsync_v2(
        dstArray: CUarray,
        dstOffset: usize,
        srcHost: *const ::std::os::raw::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpyAtoHAsync_v2(
        dstHost: *mut ::std::os::raw::c_void,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy2DAsync_v2(pCopy: *const CUDA_MEMCPY2D, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemcpy3DAsync_v2(pCopy: *const CUDA_MEMCPY3D, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies memory between contexts asynchronously.\n\n Perform a 3D memory copy according to the parameters specified in\n \\p pCopy.  See the definition of the ::CUDA_MEMCPY3D_PEER structure\n for documentation of its parameters.\n\n \\param pCopy - Parameters for the memory copy\n \\param hStream - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_async\n \\note_null_stream\n\n \\sa ::cuMemcpyDtoD, ::cuMemcpyPeer, ::cuMemcpyDtoDAsync, ::cuMemcpyPeerAsync,\n ::cuMemcpy3DPeerAsync,\n ::cudaMemcpy3DPeerAsync"]
    pub fn cuMemcpy3DPeerAsync(pCopy: *const CUDA_MEMCPY3D_PEER, hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD8_v2(dstDevice: CUdeviceptr, uc: ::std::os::raw::c_uchar, N: usize)
        -> CUresult;
}
extern "C" {
    pub fn cuMemsetD16_v2(
        dstDevice: CUdeviceptr,
        us: ::std::os::raw::c_ushort,
        N: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD32_v2(dstDevice: CUdeviceptr, ui: ::std::os::raw::c_uint, N: usize)
        -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D8_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        uc: ::std::os::raw::c_uchar,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D16_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        us: ::std::os::raw::c_ushort,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuMemsetD2D32_v2(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        ui: ::std::os::raw::c_uint,
        Width: usize,
        Height: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory\n\n Sets the memory range of \\p N 8-bit values to the specified value\n \\p uc.\n\n \\param dstDevice - Destination device pointer\n \\param uc        - Value to set\n \\param N         - Number of elements\n \\param hStream   - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_memset\n \\note_null_stream\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,\n ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,\n ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD16Async,\n ::cuMemsetD32, ::cuMemsetD32Async,\n ::cudaMemsetAsync"]
    pub fn cuMemsetD8Async(
        dstDevice: CUdeviceptr,
        uc: ::std::os::raw::c_uchar,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory\n\n Sets the memory range of \\p N 16-bit values to the specified value\n \\p us. The \\p dstDevice pointer must be two byte aligned.\n\n \\param dstDevice - Destination device pointer\n \\param us        - Value to set\n \\param N         - Number of elements\n \\param hStream   - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_memset\n \\note_null_stream\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,\n ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,\n ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16,\n ::cuMemsetD32, ::cuMemsetD32Async,\n ::cudaMemsetAsync"]
    pub fn cuMemsetD16Async(
        dstDevice: CUdeviceptr,
        us: ::std::os::raw::c_ushort,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory\n\n Sets the memory range of \\p N 32-bit values to the specified value\n \\p ui. The \\p dstDevice pointer must be four byte aligned.\n\n \\param dstDevice - Destination device pointer\n \\param ui        - Value to set\n \\param N         - Number of elements\n \\param hStream   - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_memset\n \\note_null_stream\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,\n ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,\n ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async, ::cuMemsetD32,\n ::cudaMemsetAsync"]
    pub fn cuMemsetD32Async(
        dstDevice: CUdeviceptr,
        ui: ::std::os::raw::c_uint,
        N: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory\n\n Sets the 2D memory range of \\p Width 8-bit values to the specified value\n \\p uc. \\p Height specifies the number of rows to set, and \\p dstPitch\n specifies the number of bytes between each row. This function performs\n fastest when the pitch is one that has been passed back by\n ::cuMemAllocPitch().\n\n \\param dstDevice - Destination device pointer\n \\param dstPitch  - Pitch of destination device pointer(Unused if \\p Height is 1)\n \\param uc        - Value to set\n \\param Width     - Width of row\n \\param Height    - Number of rows\n \\param hStream   - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_memset\n \\note_null_stream\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8,\n ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32, ::cuMemsetD2D32Async,\n ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async,\n ::cuMemsetD32, ::cuMemsetD32Async,\n ::cudaMemset2DAsync"]
    pub fn cuMemsetD2D8Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        uc: ::std::os::raw::c_uchar,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory\n\n Sets the 2D memory range of \\p Width 16-bit values to the specified value\n \\p us. \\p Height specifies the number of rows to set, and \\p dstPitch\n specifies the number of bytes between each row. The \\p dstDevice pointer\n and \\p dstPitch offset must be two byte aligned. This function performs\n fastest when the pitch is one that has been passed back by\n ::cuMemAllocPitch().\n\n \\param dstDevice - Destination device pointer\n \\param dstPitch  - Pitch of destination device pointer(Unused if \\p Height is 1)\n \\param us        - Value to set\n \\param Width     - Width of row\n \\param Height    - Number of rows\n \\param hStream   - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_memset\n \\note_null_stream\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,\n ::cuMemsetD2D16, ::cuMemsetD2D32, ::cuMemsetD2D32Async,\n ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async,\n ::cuMemsetD32, ::cuMemsetD32Async,\n ::cudaMemset2DAsync"]
    pub fn cuMemsetD2D16Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        us: ::std::os::raw::c_ushort,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets device memory\n\n Sets the 2D memory range of \\p Width 32-bit values to the specified value\n \\p ui. \\p Height specifies the number of rows to set, and \\p dstPitch\n specifies the number of bytes between each row. The \\p dstDevice pointer\n and \\p dstPitch offset must be four byte aligned. This function performs\n fastest when the pitch is one that has been passed back by\n ::cuMemAllocPitch().\n\n \\param dstDevice - Destination device pointer\n \\param dstPitch  - Pitch of destination device pointer(Unused if \\p Height is 1)\n \\param ui        - Value to set\n \\param Width     - Width of row\n \\param Height    - Number of rows\n \\param hStream   - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n \\note_memset\n \\note_null_stream\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayDestroy, ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D8Async,\n ::cuMemsetD2D16, ::cuMemsetD2D16Async, ::cuMemsetD2D32,\n ::cuMemsetD8, ::cuMemsetD8Async, ::cuMemsetD16, ::cuMemsetD16Async,\n ::cuMemsetD32, ::cuMemsetD32Async,\n ::cudaMemset2DAsync"]
    pub fn cuMemsetD2D32Async(
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        ui: ::std::os::raw::c_uint,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArrayGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the layout properties of a sparse CUDA array\n\n Returns the layout properties of a sparse CUDA array in \\p sparseProperties\n If the CUDA array is not allocated with flag ::CUDA_ARRAY3D_SPARSE\n ::CUDA_ERROR_INVALID_VALUE will be returned.\n\n If the returned value in ::CUDA_ARRAY_SPARSE_PROPERTIES::flags contains ::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL,\n then ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize represents the total size of the array. Otherwise, it will be zero.\n Also, the returned value in ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailFirstLevel is always zero.\n Note that the \\p array must have been allocated using ::cuArrayCreate or ::cuArray3DCreate. For CUDA arrays obtained\n using ::cuMipmappedArrayGetLevel, ::CUDA_ERROR_INVALID_VALUE will be returned. Instead, ::cuMipmappedArrayGetSparseProperties\n must be used to obtain the sparse properties of the entire CUDA mipmapped array to which \\p array belongs to.\n\n \\return\n ::CUDA_SUCCESS\n ::CUDA_ERROR_INVALID_VALUE\n\n \\param[out] sparseProperties - Pointer to ::CUDA_ARRAY_SPARSE_PROPERTIES\n \\param[in] array - CUDA array to get the sparse properties of\n \\sa ::cuMipmappedArrayGetSparseProperties, ::cuMemMapArrayAsync"]
    pub fn cuArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        array: CUarray,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the layout properties of a sparse CUDA mipmapped array\n\n Returns the sparse array layout properties in \\p sparseProperties\n If the CUDA mipmapped array is not allocated with flag ::CUDA_ARRAY3D_SPARSE\n ::CUDA_ERROR_INVALID_VALUE will be returned.\n\n For non-layered CUDA mipmapped arrays, ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize returns the\n size of the mip tail region. The mip tail region includes all mip levels whose width, height or depth\n is less than that of the tile.\n For layered CUDA mipmapped arrays, if ::CUDA_ARRAY_SPARSE_PROPERTIES::flags contains ::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL,\n then ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize specifies the size of the mip tail of all layers combined.\n Otherwise, ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize specifies mip tail size per layer.\n The returned value of ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailFirstLevel is valid only if ::CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize is non-zero.\n\n \\return\n ::CUDA_SUCCESS\n ::CUDA_ERROR_INVALID_VALUE\n\n \\param[out] sparseProperties - Pointer to ::CUDA_ARRAY_SPARSE_PROPERTIES\n \\param[in] mipmap - CUDA mipmapped array to get the sparse properties of\n \\sa ::cuArrayGetSparseProperties, ::cuMemMapArrayAsync"]
    pub fn cuMipmappedArrayGetSparseProperties(
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        mipmap: CUmipmappedArray,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the memory requirements of a CUDA array\n\n Returns the memory requirements of a CUDA array in \\p memoryRequirements\n If the CUDA array is not allocated with flag ::CUDA_ARRAY3D_DEFERRED_MAPPING\n ::CUDA_ERROR_INVALID_VALUE will be returned.\n\n The returned value in ::CUDA_ARRAY_MEMORY_REQUIREMENTS::size\n represents the total size of the CUDA array.\n The returned value in ::CUDA_ARRAY_MEMORY_REQUIREMENTS::alignment\n represents the alignment necessary for mapping the CUDA array.\n\n \\return\n ::CUDA_SUCCESS\n ::CUDA_ERROR_INVALID_VALUE\n\n \\param[out] memoryRequirements - Pointer to ::CUDA_ARRAY_MEMORY_REQUIREMENTS\n \\param[in] array - CUDA array to get the memory requirements of\n \\param[in] device - Device to get the memory requirements for\n \\sa ::cuMipmappedArrayGetMemoryRequirements, ::cuMemMapArrayAsync"]
    pub fn cuArrayGetMemoryRequirements(
        memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
        array: CUarray,
        device: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the memory requirements of a CUDA mipmapped array\n\n Returns the memory requirements of a CUDA mipmapped array in \\p memoryRequirements\n If the CUDA mipmapped array is not allocated with flag ::CUDA_ARRAY3D_DEFERRED_MAPPING\n ::CUDA_ERROR_INVALID_VALUE will be returned.\n\n The returned value in ::CUDA_ARRAY_MEMORY_REQUIREMENTS::size\n represents the total size of the CUDA mipmapped array.\n The returned value in ::CUDA_ARRAY_MEMORY_REQUIREMENTS::alignment\n represents the alignment necessary for mapping the CUDA mipmapped\n array.\n\n \\return\n ::CUDA_SUCCESS\n ::CUDA_ERROR_INVALID_VALUE\n\n \\param[out] memoryRequirements - Pointer to ::CUDA_ARRAY_MEMORY_REQUIREMENTS\n \\param[in] mipmap - CUDA mipmapped array to get the memory requirements of\n \\param[in] device - Device to get the memory requirements for\n \\sa ::cuArrayGetMemoryRequirements, ::cuMemMapArrayAsync"]
    pub fn cuMipmappedArrayGetMemoryRequirements(
        memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
        mipmap: CUmipmappedArray,
        device: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets a CUDA array plane from a CUDA array\n\n Returns in \\p pPlaneArray a CUDA array that represents a single format plane\n of the CUDA array \\p hArray.\n\n If \\p planeIdx is greater than the maximum number of planes in this array or if the array does\n not have a multi-planar format e.g: ::CU_AD_FORMAT_NV12, then ::CUDA_ERROR_INVALID_VALUE is returned.\n\n Note that if the \\p hArray has format ::CU_AD_FORMAT_NV12, then passing in 0 for \\p planeIdx returns\n a CUDA array of the same size as \\p hArray but with one channel and ::CU_AD_FORMAT_UNSIGNED_INT8 as its format.\n If 1 is passed for \\p planeIdx, then the returned CUDA array has half the height and width\n of \\p hArray with two channels and ::CU_AD_FORMAT_UNSIGNED_INT8 as its format.\n\n \\param pPlaneArray   - Returned CUDA array referenced by the \\p planeIdx\n \\param hArray        - Multiplanar CUDA array\n \\param planeIdx      - Plane index\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa\n ::cuArrayCreate,\n ::cudaArrayGetPlane"]
    pub fn cuArrayGetPlane(
        pPlaneArray: *mut CUarray,
        hArray: CUarray,
        planeIdx: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a CUDA array\n\n Destroys the CUDA array \\p hArray.\n\n \\param hArray - Array to destroy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_ARRAY_IS_MAPPED,\n ::CUDA_ERROR_CONTEXT_IS_DESTROYED\n \\notefnerr\n\n \\sa ::cuArray3DCreate, ::cuArray3DGetDescriptor, ::cuArrayCreate,\n ::cuArrayGetDescriptor, ::cuMemAlloc, ::cuMemAllocHost,\n ::cuMemAllocPitch, ::cuMemcpy2D, ::cuMemcpy2DAsync, ::cuMemcpy2DUnaligned,\n ::cuMemcpy3D, ::cuMemcpy3DAsync, ::cuMemcpyAtoA, ::cuMemcpyAtoD,\n ::cuMemcpyAtoH, ::cuMemcpyAtoHAsync, ::cuMemcpyDtoA, ::cuMemcpyDtoD, ::cuMemcpyDtoDAsync,\n ::cuMemcpyDtoH, ::cuMemcpyDtoHAsync, ::cuMemcpyHtoA, ::cuMemcpyHtoAAsync,\n ::cuMemcpyHtoD, ::cuMemcpyHtoDAsync, ::cuMemFree, ::cuMemFreeHost,\n ::cuMemGetAddressRange, ::cuMemGetInfo, ::cuMemHostAlloc,\n ::cuMemHostGetDevicePointer, ::cuMemsetD2D8, ::cuMemsetD2D16,\n ::cuMemsetD2D32, ::cuMemsetD8, ::cuMemsetD16, ::cuMemsetD32,\n ::cudaFreeArray"]
    pub fn cuArrayDestroy(hArray: CUarray) -> CUresult;
}
extern "C" {
    pub fn cuArray3DCreate_v2(
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
    ) -> CUresult;
}
extern "C" {
    pub fn cuArray3DGetDescriptor_v2(
        pArrayDescriptor: *mut CUDA_ARRAY3D_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a CUDA mipmapped array\n\n Creates a CUDA mipmapped array according to the ::CUDA_ARRAY3D_DESCRIPTOR structure\n \\p pMipmappedArrayDesc and returns a handle to the new CUDA mipmapped array in \\p *pHandle.\n \\p numMipmapLevels specifies the number of mipmap levels to be allocated. This value is\n clamped to the range [1, 1 + floor(log2(max(width, height, depth)))].\n\n The ::CUDA_ARRAY3D_DESCRIPTOR is defined as:\n\n \\code\ntypedef struct {\nunsigned int Width;\nunsigned int Height;\nunsigned int Depth;\nCUarray_format Format;\nunsigned int NumChannels;\nunsigned int Flags;\n} CUDA_ARRAY3D_DESCRIPTOR;\n \\endcode\n where:\n\n - \\p Width, \\p Height, and \\p Depth are the width, height, and depth of the\n CUDA array (in elements); the following types of CUDA arrays can be allocated:\n     - A 1D mipmapped array is allocated if \\p Height and \\p Depth extents are both zero.\n     - A 2D mipmapped array is allocated if only \\p Depth extent is zero.\n     - A 3D mipmapped array is allocated if all three extents are non-zero.\n     - A 1D layered CUDA mipmapped array is allocated if only \\p Height is zero and the\n       ::CUDA_ARRAY3D_LAYERED flag is set. Each layer is a 1D array. The number\n       of layers is determined by the depth extent.\n     - A 2D layered CUDA mipmapped array is allocated if all three extents are non-zero and\n       the ::CUDA_ARRAY3D_LAYERED flag is set. Each layer is a 2D array. The number\n       of layers is determined by the depth extent.\n     - A cubemap CUDA mipmapped array is allocated if all three extents are non-zero and the\n       ::CUDA_ARRAY3D_CUBEMAP flag is set. \\p Width must be equal to \\p Height, and\n       \\p Depth must be six. A cubemap is a special type of 2D layered CUDA array,\n       where the six layers represent the six faces of a cube. The order of the six\n       layers in memory is the same as that listed in ::CUarray_cubemap_face.\n     - A cubemap layered CUDA mipmapped array is allocated if all three extents are non-zero,\n       and both, ::CUDA_ARRAY3D_CUBEMAP and ::CUDA_ARRAY3D_LAYERED flags are set.\n       \\p Width must be equal to \\p Height, and \\p Depth must be a multiple of six.\n       A cubemap layered CUDA array is a special type of 2D layered CUDA array that\n       consists of a collection of cubemaps. The first six layers represent the first\n       cubemap, the next six layers form the second cubemap, and so on.\n\n - ::Format specifies the format of the elements; ::CUarray_format is\n defined as:\n \\code\ntypedef enum CUarray_format_enum {\nCU_AD_FORMAT_UNSIGNED_INT8 = 0x01,\nCU_AD_FORMAT_UNSIGNED_INT16 = 0x02,\nCU_AD_FORMAT_UNSIGNED_INT32 = 0x03,\nCU_AD_FORMAT_SIGNED_INT8 = 0x08,\nCU_AD_FORMAT_SIGNED_INT16 = 0x09,\nCU_AD_FORMAT_SIGNED_INT32 = 0x0a,\nCU_AD_FORMAT_HALF = 0x10,\nCU_AD_FORMAT_FLOAT = 0x20\n} CUarray_format;\n  \\endcode\n\n - \\p NumChannels specifies the number of packed components per CUDA array\n element; it may be 1, 2, or 4;\n\n - ::Flags may be set to\n   - ::CUDA_ARRAY3D_LAYERED to enable creation of layered CUDA mipmapped arrays. If this flag is set,\n     \\p Depth specifies the number of layers, not the depth of a 3D array.\n   - ::CUDA_ARRAY3D_SURFACE_LDST to enable surface references to be bound to individual mipmap levels of\n     the CUDA mipmapped array. If this flag is not set, ::cuSurfRefSetArray will fail when attempting to\n     bind a mipmap level of the CUDA mipmapped array to a surface reference.\n   - ::CUDA_ARRAY3D_CUBEMAP to enable creation of mipmapped cubemaps. If this flag is set, \\p Width must be\n     equal to \\p Height, and \\p Depth must be six. If the ::CUDA_ARRAY3D_LAYERED flag is also set,\n     then \\p Depth must be a multiple of six.\n   - ::CUDA_ARRAY3D_TEXTURE_GATHER to indicate that the CUDA mipmapped array will be used for texture gather.\n     Texture gather can only be performed on 2D CUDA mipmapped arrays.\n\n \\p Width, \\p Height and \\p Depth must meet certain size requirements as listed in the following table.\n All values are specified in elements. Note that for brevity's sake, the full name of the device attribute\n is not specified. For ex., TEXTURE1D_MIPMAPPED_WIDTH refers to the device attribute\n ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH.\n\n <table>\n <tr><td><b>CUDA array type</b></td>\n <td><b>Valid extents that must always be met<br>{(width range in elements), (height range),\n (depth range)}</b></td>\n <td><b>Valid extents with CUDA_ARRAY3D_SURFACE_LDST set<br>\n {(width range in elements), (height range), (depth range)}</b></td></tr>\n <tr><td>1D</td>\n <td><small>{ (1,TEXTURE1D_MIPMAPPED_WIDTH), 0, 0 }</small></td>\n <td><small>{ (1,SURFACE1D_WIDTH), 0, 0 }</small></td></tr>\n <tr><td>2D</td>\n <td><small>{ (1,TEXTURE2D_MIPMAPPED_WIDTH), (1,TEXTURE2D_MIPMAPPED_HEIGHT), 0 }</small></td>\n <td><small>{ (1,SURFACE2D_WIDTH), (1,SURFACE2D_HEIGHT), 0 }</small></td></tr>\n <tr><td>3D</td>\n <td><small>{ (1,TEXTURE3D_WIDTH), (1,TEXTURE3D_HEIGHT), (1,TEXTURE3D_DEPTH) }\n <br>OR<br>{ (1,TEXTURE3D_WIDTH_ALTERNATE), (1,TEXTURE3D_HEIGHT_ALTERNATE),\n (1,TEXTURE3D_DEPTH_ALTERNATE) }</small></td>\n <td><small>{ (1,SURFACE3D_WIDTH), (1,SURFACE3D_HEIGHT),\n (1,SURFACE3D_DEPTH) }</small></td></tr>\n <tr><td>1D Layered</td>\n <td><small>{ (1,TEXTURE1D_LAYERED_WIDTH), 0,\n (1,TEXTURE1D_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACE1D_LAYERED_WIDTH), 0,\n (1,SURFACE1D_LAYERED_LAYERS) }</small></td></tr>\n <tr><td>2D Layered</td>\n <td><small>{ (1,TEXTURE2D_LAYERED_WIDTH), (1,TEXTURE2D_LAYERED_HEIGHT),\n (1,TEXTURE2D_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACE2D_LAYERED_WIDTH), (1,SURFACE2D_LAYERED_HEIGHT),\n (1,SURFACE2D_LAYERED_LAYERS) }</small></td></tr>\n <tr><td>Cubemap</td>\n <td><small>{ (1,TEXTURECUBEMAP_WIDTH), (1,TEXTURECUBEMAP_WIDTH), 6 }</small></td>\n <td><small>{ (1,SURFACECUBEMAP_WIDTH),\n (1,SURFACECUBEMAP_WIDTH), 6 }</small></td></tr>\n <tr><td>Cubemap Layered</td>\n <td><small>{ (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_WIDTH),\n (1,TEXTURECUBEMAP_LAYERED_LAYERS) }</small></td>\n <td><small>{ (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_WIDTH),\n (1,SURFACECUBEMAP_LAYERED_LAYERS) }</small></td></tr>\n </table>\n\n\n \\param pHandle             - Returned mipmapped array\n \\param pMipmappedArrayDesc - mipmapped array descriptor\n \\param numMipmapLevels     - Number of mipmap levels\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa\n ::cuMipmappedArrayDestroy,\n ::cuMipmappedArrayGetLevel,\n ::cuArrayCreate,\n ::cudaMallocMipmappedArray"]
    pub fn cuMipmappedArrayCreate(
        pHandle: *mut CUmipmappedArray,
        pMipmappedArrayDesc: *const CUDA_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets a mipmap level of a CUDA mipmapped array\n\n Returns in \\p *pLevelArray a CUDA array that represents a single mipmap level\n of the CUDA mipmapped array \\p hMipmappedArray.\n\n If \\p level is greater than the maximum number of levels in this mipmapped array,\n ::CUDA_ERROR_INVALID_VALUE is returned.\n\n \\param pLevelArray     - Returned mipmap level CUDA array\n \\param hMipmappedArray - CUDA mipmapped array\n \\param level           - Mipmap level\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa\n ::cuMipmappedArrayCreate,\n ::cuMipmappedArrayDestroy,\n ::cuArrayCreate,\n ::cudaGetMipmappedArrayLevel"]
    pub fn cuMipmappedArrayGetLevel(
        pLevelArray: *mut CUarray,
        hMipmappedArray: CUmipmappedArray,
        level: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a CUDA mipmapped array\n\n Destroys the CUDA mipmapped array \\p hMipmappedArray.\n\n \\param hMipmappedArray - Mipmapped array to destroy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_ARRAY_IS_MAPPED,\n ::CUDA_ERROR_CONTEXT_IS_DESTROYED\n \\notefnerr\n\n \\sa\n ::cuMipmappedArrayCreate,\n ::cuMipmappedArrayGetLevel,\n ::cuArrayCreate,\n ::cudaFreeMipmappedArray"]
    pub fn cuMipmappedArrayDestroy(hMipmappedArray: CUmipmappedArray) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retrieve handle for an address range\n\n Get a handle of the specified type to an address range. The address range\n must have been obtained by a prior call to either ::cuMemAlloc or ::cuMemAddressReserve.\n If the address range was obtained via ::cuMemAddressReserve, it must also be fully mapped via ::cuMemMap.\n\n Users must ensure the \\p dptr and \\p size are aligned to the host page size.\n\n When requesting CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD,\n users are expected to query for dma_buf support for the platform\n by using ::CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED device attribute before calling\n this API. The \\p handle will be interpreted as a pointer to an integer to store the dma_buf file descriptor.\n Users must ensure the entire address range is backed and mapped when\n the address range is allocated by ::cuMemAddressReserve. All the physical\n allocations backing the address range must be resident on the same device and\n have identical allocation properties. Users are also expected to retrieve a\n new handle every time the underlying physical allocation(s) corresponding\n to a previously queried VA range are changed.\n\n \\param[out] handle     - Pointer to the location where the returned handle will be stored.\n \\param[in] dptr        - Pointer to a valid CUDA device allocation. Must be aligned to host page size.\n \\param[in] size        - Length of the address range. Must be aligned to host page size.\n \\param[in] handleType  - Type of handle requested (defines type and size of the \\p handle output parameter)\n \\param[in] flags       - Reserved, must be zero\n\n \\return\n CUDA_SUCCESS\n CUDA_ERROR_INVALID_VALUE\n CUDA_ERROR_NOT_SUPPORTED"]
    pub fn cuMemGetHandleForAddressRange(
        handle: *mut ::std::os::raw::c_void,
        dptr: CUdeviceptr,
        size: usize,
        handleType: CUmemRangeHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocate an address range reservation.\n\n Reserves a virtual address range based on the given parameters, giving\n the starting address of the range in \\p ptr.  This API requires a system that\n supports UVA.  The size and address parameters must be a multiple of the\n host page size and the alignment must be a power of two or zero for default\n alignment.\n\n \\param[out] ptr       - Resulting pointer to start of virtual address range allocated\n \\param[in]  size      - Size of the reserved virtual address range requested\n \\param[in]  alignment - Alignment of the reserved virtual address range requested\n \\param[in]  addr      - Fixed starting address range requested\n \\param[in]  flags     - Currently unused, must be zero\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuMemAddressFree"]
    pub fn cuMemAddressReserve(
        ptr: *mut CUdeviceptr,
        size: usize,
        alignment: usize,
        addr: CUdeviceptr,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Free an address range reservation.\n\n Frees a virtual address range reserved by cuMemAddressReserve.  The size\n must match what was given to memAddressReserve and the ptr given must\n match what was returned from memAddressReserve.\n\n \\param[in] ptr  - Starting address of the virtual address range to free\n \\param[in] size - Size of the virtual address region to free\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuMemAddressReserve"]
    pub fn cuMemAddressFree(ptr: CUdeviceptr, size: usize) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a CUDA memory handle representing a memory allocation of a given size described by the given properties\n\n This creates a memory allocation on the target device specified through the\n \\p prop strcuture. The created allocation will not have any device or host\n mappings. The generic memory \\p handle for the allocation can be\n mapped to the address space of calling process via ::cuMemMap. This handle\n cannot be transmitted directly to other processes (see\n ::cuMemExportToShareableHandle).  On Windows, the caller must also pass\n an LPSECURITYATTRIBUTE in \\p prop to be associated with this handle which\n limits or allows access to this handle for a recepient process (see\n ::CUmemAllocationProp::win32HandleMetaData for more).  The \\p size of this\n allocation must be a multiple of the the value given via\n ::cuMemGetAllocationGranularity with the ::CU_MEM_ALLOC_GRANULARITY_MINIMUM\n flag.\n If ::CUmemAllocationProp::allocFlags::usage contains ::CU_MEM_CREATE_USAGE_TILE_POOL flag then\n the memory allocation is intended only to be used as backing tile pool for sparse CUDA arrays\n and sparse CUDA mipmapped arrays.\n (see ::cuMemMapArrayAsync).\n\n \\param[out] handle - Value of handle returned. All operations on this allocation are to be performed using this handle.\n \\param[in]  size   - Size of the allocation requested\n \\param[in]  prop   - Properties of the allocation to create.\n \\param[in]  flags  - flags for future use, must be zero now.\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\notefnerr\n\n \\sa ::cuMemRelease, ::cuMemExportToShareableHandle, ::cuMemImportFromShareableHandle"]
    pub fn cuMemCreate(
        handle: *mut CUmemGenericAllocationHandle,
        size: usize,
        prop: *const CUmemAllocationProp,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.\n\n Frees the memory that was allocated on a device through cuMemCreate.\n\n The memory allocation will be freed when all outstanding mappings to the memory\n are unmapped and when all outstanding references to the handle (including it's\n shareable counterparts) are also released. The generic memory handle can be\n freed when there are still outstanding mappings made with this handle. Each\n time a recepient process imports a shareable handle, it needs to pair it with\n ::cuMemRelease for the handle to be freed.  If \\p handle is not a valid handle\n the behavior is undefined.\n\n \\param[in] handle Value of handle which was returned previously by cuMemCreate.\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\notefnerr\n\n \\sa ::cuMemCreate"]
    pub fn cuMemRelease(handle: CUmemGenericAllocationHandle) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Maps an allocation handle to a reserved virtual address range.\n\n Maps bytes of memory represented by \\p handle starting from byte \\p offset to\n \\p size to address range [\\p addr, \\p addr + \\p size]. This range must be an\n address reservation previously reserved with ::cuMemAddressReserve, and\n \\p offset + \\p size must be less than the size of the memory allocation.\n Both \\p ptr, \\p size, and \\p offset must be a multiple of the value given via\n ::cuMemGetAllocationGranularity with the ::CU_MEM_ALLOC_GRANULARITY_MINIMUM flag.\n\n Please note calling ::cuMemMap does not make the address accessible,\n the caller needs to update accessibility of a contiguous mapped VA\n range by calling ::cuMemSetAccess.\n\n Once a recipient process obtains a shareable memory handle\n from ::cuMemImportFromShareableHandle, the process must\n use ::cuMemMap to map the memory into its address ranges before\n setting accessibility with ::cuMemSetAccess.\n\n ::cuMemMap can only create mappings on VA range reservations\n that are not currently mapped.\n\n \\param[in] ptr    - Address where memory will be mapped.\n \\param[in] size   - Size of the memory mapping.\n \\param[in] offset - Offset into the memory represented by\n                   - \\p handle from which to start mapping\n                   - Note: currently must be zero.\n \\param[in] handle - Handle to a shareable memory\n \\param[in] flags  - flags for future use, must be zero now.\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\notefnerr\n\n \\sa ::cuMemUnmap, ::cuMemSetAccess, ::cuMemCreate, ::cuMemAddressReserve, ::cuMemImportFromShareableHandle"]
    pub fn cuMemMap(
        ptr: CUdeviceptr,
        size: usize,
        offset: usize,
        handle: CUmemGenericAllocationHandle,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays\n\n Performs map or unmap operations on subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.\n Each operation is specified by a ::CUarrayMapInfo entry in the \\p mapInfoList array of size \\p count.\n The structure ::CUarrayMapInfo is defined as follow:\n\\code\ntypedef struct CUarrayMapInfo_st {\nCUresourcetype resourceType;\nunion {\nCUmipmappedArray mipmap;\nCUarray array;\n} resource;\n\nCUarraySparseSubresourceType subresourceType;\nunion {\nstruct {\nunsigned int level;\nunsigned int layer;\nunsigned int offsetX;\nunsigned int offsetY;\nunsigned int offsetZ;\nunsigned int extentWidth;\nunsigned int extentHeight;\nunsigned int extentDepth;\n} sparseLevel;\nstruct {\nunsigned int layer;\nunsigned long long offset;\nunsigned long long size;\n} miptail;\n} subresource;\n\nCUmemOperationType memOperationType;\n\nCUmemHandleType memHandleType;\nunion {\nCUmemGenericAllocationHandle memHandle;\n} memHandle;\n\nunsigned long long offset;\nunsigned int deviceBitMask;\nunsigned int flags;\nunsigned int reserved[2];\n} CUarrayMapInfo;\n\\endcode\n\n where ::CUarrayMapInfo::resourceType specifies the type of resource to be operated on.\n If ::CUarrayMapInfo::resourceType is set to ::CUresourcetype::CU_RESOURCE_TYPE_ARRAY then\n ::CUarrayMapInfo::resource::array must be set to a valid sparse CUDA array handle.\n The CUDA array must be either a 2D, 2D layered or 3D CUDA array and must have been allocated using\n ::cuArrayCreate or ::cuArray3DCreate with the flag ::CUDA_ARRAY3D_SPARSE\n or ::CUDA_ARRAY3D_DEFERRED_MAPPING.\n For CUDA arrays obtained using ::cuMipmappedArrayGetLevel, ::CUDA_ERROR_INVALID_VALUE will be returned.\n If ::CUarrayMapInfo::resourceType is set to ::CUresourcetype::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY\n then ::CUarrayMapInfo::resource::mipmap must be set to a valid sparse CUDA mipmapped array handle.\n The CUDA mipmapped array must be either a 2D, 2D layered or 3D CUDA mipmapped array and must have been\n allocated using ::cuMipmappedArrayCreate with the flag ::CUDA_ARRAY3D_SPARSE\n or ::CUDA_ARRAY3D_DEFERRED_MAPPING.\n\n ::CUarrayMapInfo::subresourceType specifies the type of subresource within the resource.\n ::CUarraySparseSubresourceType_enum is defined as:\n\\code\ntypedef enum CUarraySparseSubresourceType_enum {\nCU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,\nCU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1\n} CUarraySparseSubresourceType;\n\\endcode\n\n where ::CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL indicates a\n sparse-miplevel which spans at least one tile in every dimension. The remaining miplevels which\n are too small to span at least one tile in any dimension constitute the mip tail region as indicated by\n ::CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL subresource type.\n\n If ::CUarrayMapInfo::subresourceType is set to ::CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL\n then ::CUarrayMapInfo::subresource::sparseLevel struct must contain valid array subregion offsets and extents.\n The ::CUarrayMapInfo::subresource::sparseLevel::offsetX, ::CUarrayMapInfo::subresource::sparseLevel::offsetY\n and ::CUarrayMapInfo::subresource::sparseLevel::offsetZ must specify valid X, Y and Z offsets respectively.\n The ::CUarrayMapInfo::subresource::sparseLevel::extentWidth, ::CUarrayMapInfo::subresource::sparseLevel::extentHeight\n and ::CUarrayMapInfo::subresource::sparseLevel::extentDepth must specify valid width, height and depth extents respectively.\n These offsets and extents must be aligned to the corresponding tile dimension.\n For CUDA mipmapped arrays ::CUarrayMapInfo::subresource::sparseLevel::level must specify a valid mip level index. Otherwise,\n must be zero.\n For layered CUDA arrays and layered CUDA mipmapped arrays ::CUarrayMapInfo::subresource::sparseLevel::layer must specify a valid layer index. Otherwise,\n must be zero.\n ::CUarrayMapInfo::subresource::sparseLevel::offsetZ must be zero and ::CUarrayMapInfo::subresource::sparseLevel::extentDepth\n must be set to 1 for 2D and 2D layered CUDA arrays and CUDA mipmapped arrays.\n Tile extents can be obtained by calling ::cuArrayGetSparseProperties and ::cuMipmappedArrayGetSparseProperties\n\n If ::CUarrayMapInfo::subresourceType is set to ::CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL\n then ::CUarrayMapInfo::subresource::miptail struct must contain valid mip tail offset in\n ::CUarrayMapInfo::subresource::miptail::offset and size in ::CUarrayMapInfo::subresource::miptail::size.\n Both, mip tail offset and mip tail size must be aligned to the tile size.\n For layered CUDA mipmapped arrays which don't have the flag ::CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL set in ::CUDA_ARRAY_SPARSE_PROPERTIES::flags\n as returned by ::cuMipmappedArrayGetSparseProperties, ::CUarrayMapInfo::subresource::miptail::layer must specify a valid layer index.\n Otherwise, must be zero.\n\n If ::CUarrayMapInfo::resource::array or ::CUarrayMapInfo::resource::mipmap was created with ::CUDA_ARRAY3D_DEFERRED_MAPPING\n flag set the ::CUarrayMapInfo::subresourceType and the contents of ::CUarrayMapInfo::subresource will be ignored.\n\n ::CUarrayMapInfo::memOperationType specifies the type of operation. ::CUmemOperationType is defined as:\n\\code\ntypedef enum CUmemOperationType_enum {\nCU_MEM_OPERATION_TYPE_MAP = 1,\nCU_MEM_OPERATION_TYPE_UNMAP = 2\n} CUmemOperationType;\n\\endcode\n If ::CUarrayMapInfo::memOperationType is set to ::CUmemOperationType::CU_MEM_OPERATION_TYPE_MAP then the subresource\n will be mapped onto the tile pool memory specified by ::CUarrayMapInfo::memHandle at offset ::CUarrayMapInfo::offset.\n The tile pool allocation has to be created by specifying the ::CU_MEM_CREATE_USAGE_TILE_POOL flag when calling ::cuMemCreate. Also,\n ::CUarrayMapInfo::memHandleType must be set to ::CUmemHandleType::CU_MEM_HANDLE_TYPE_GENERIC.\n\n If ::CUarrayMapInfo::memOperationType is set to ::CUmemOperationType::CU_MEM_OPERATION_TYPE_UNMAP then an unmapping operation\n is performed. ::CUarrayMapInfo::memHandle must be NULL.\n\n ::CUarrayMapInfo::deviceBitMask specifies the list of devices that must map or unmap physical memory.\n Currently, this mask must have exactly one bit set, and the corresponding device must match the device associated with the stream.\n If ::CUarrayMapInfo::memOperationType is set to ::CUmemOperationType::CU_MEM_OPERATION_TYPE_MAP, the device must also match\n the device associated with the tile pool memory allocation as specified by ::CUarrayMapInfo::memHandle.\n\n ::CUarrayMapInfo::flags and ::CUarrayMapInfo::reserved[] are unused and must be set to zero.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n\n \\param[in] mapInfoList - List of ::CUarrayMapInfo\n \\param[in] count       - Count of ::CUarrayMapInfo  in \\p mapInfoList\n \\param[in] hStream     - Stream identifier for the stream to use for map or unmap operations\n\n \\sa ::cuMipmappedArrayCreate, ::cuArrayCreate, ::cuArray3DCreate, ::cuMemCreate, ::cuArrayGetSparseProperties, ::cuMipmappedArrayGetSparseProperties"]
    pub fn cuMemMapArrayAsync(
        mapInfoList: *mut CUarrayMapInfo,
        count: ::std::os::raw::c_uint,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unmap the backing memory of a given address range.\n\n The range must be the entire contiguous address range that was mapped to.  In\n other words, ::cuMemUnmap cannot unmap a sub-range of an address range mapped\n by ::cuMemCreate / ::cuMemMap.  Any backing memory allocations will be freed\n if there are no existing mappings and there are no unreleased memory handles.\n\n When ::cuMemUnmap returns successfully the address range is converted to an\n address reservation and can be used for a future calls to ::cuMemMap.  Any new\n mapping to this virtual address will need to have access granted through\n ::cuMemSetAccess, as all mappings start with no accessibility setup.\n\n \\param[in] ptr  - Starting address for the virtual address range to unmap\n \\param[in] size - Size of the virtual address range to unmap\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\notefnerr\n \\note_sync\n\n \\sa ::cuMemCreate, ::cuMemAddressReserve"]
    pub fn cuMemUnmap(ptr: CUdeviceptr, size: usize) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Set the access flags for each location specified in \\p desc for the given virtual address range\n\n Given the virtual address range via \\p ptr and \\p size, and the locations\n in the array given by \\p desc and \\p count, set the access flags for the\n target locations.  The range must be a fully mapped address range\n containing all allocations created by ::cuMemMap / ::cuMemCreate.\n\n \\param[in] ptr   - Starting address for the virtual address range\n \\param[in] size  - Length of the virtual address range\n \\param[in] desc  - Array of ::CUmemAccessDesc that describe how to change the\n                  - mapping for each location specified\n \\param[in] count - Number of ::CUmemAccessDesc in \\p desc\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\notefnerr\n \\note_sync\n\n \\sa ::cuMemSetAccess, ::cuMemCreate, :cuMemMap"]
    pub fn cuMemSetAccess(
        ptr: CUdeviceptr,
        size: usize,
        desc: *const CUmemAccessDesc,
        count: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Get the access \\p flags set for the given \\p location and \\p ptr\n\n \\param[out] flags   - Flags set for this location\n \\param[in] location - Location in which to check the flags for\n \\param[in] ptr      - Address in which to check the access flags for\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuMemSetAccess"]
    pub fn cuMemGetAccess(
        flags: *mut ::std::os::raw::c_ulonglong,
        location: *const CUmemLocation,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Exports an allocation to a requested shareable handle type\n\n Given a CUDA memory handle, create a shareable memory\n allocation handle that can be used to share the memory with other\n processes. The recipient process can convert the shareable handle back into a\n CUDA memory handle using ::cuMemImportFromShareableHandle and map\n it with ::cuMemMap. The implementation of what this handle is and how it\n can be transferred is defined by the requested handle type in \\p handleType\n\n Once all shareable handles are closed and the allocation is released, the allocated\n memory referenced will be released back to the OS and uses of the CUDA handle afterward\n will lead to undefined behavior.\n\n This API can also be used in conjunction with other APIs (e.g. Vulkan, OpenGL)\n that support importing memory from the shareable type\n\n \\param[out] shareableHandle - Pointer to the location in which to store the requested handle type\n \\param[in] handle           - CUDA handle for the memory allocation\n \\param[in] handleType       - Type of shareable handle requested (defines type and size of the \\p shareableHandle output parameter)\n \\param[in] flags            - Reserved, must be zero\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuMemImportFromShareableHandle"]
    pub fn cuMemExportToShareableHandle(
        shareableHandle: *mut ::std::os::raw::c_void,
        handle: CUmemGenericAllocationHandle,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Imports an allocation from a requested shareable handle type.\n\n If the current process cannot support the memory described by this shareable\n handle, this API will error as CUDA_ERROR_NOT_SUPPORTED.\n\n \\note Importing shareable handles exported from some graphics APIs(VUlkan, OpenGL, etc)\n created on devices under an SLI group may not be supported, and thus this API will\n return CUDA_ERROR_NOT_SUPPORTED.\n There is no guarantee that the contents of \\p handle will be the same CUDA memory handle\n for the same given OS shareable handle, or the same underlying allocation.\n\n \\param[out] handle       - CUDA Memory handle for the memory allocation.\n \\param[in]  osHandle     - Shareable Handle representing the memory allocation that is to be imported.\n \\param[in]  shHandleType - handle type of the exported handle ::CUmemAllocationHandleType.\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuMemExportToShareableHandle, ::cuMemMap, ::cuMemRelease"]
    pub fn cuMemImportFromShareableHandle(
        handle: *mut CUmemGenericAllocationHandle,
        osHandle: *mut ::std::os::raw::c_void,
        shHandleType: CUmemAllocationHandleType,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Calculates either the minimal or recommended granularity\n\n Calculates either the minimal or recommended granularity\n for a given allocation specification and returns it in granularity.  This\n granularity can be used as a multiple for alignment, size, or address mapping.\n\n \\param[out] granularity Returned granularity.\n \\param[in]  prop Property for which to determine the granularity for\n \\param[in]  option Determines which granularity to return\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuMemCreate, ::cuMemMap"]
    pub fn cuMemGetAllocationGranularity(
        granularity: *mut usize,
        prop: *const CUmemAllocationProp,
        option: CUmemAllocationGranularity_flags,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retrieve the contents of the property structure defining properties for this handle\n\n \\param[out] prop  - Pointer to a properties structure which will hold the information about this handle\n \\param[in] handle - Handle which to perform the query on\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuMemCreate, ::cuMemImportFromShareableHandle"]
    pub fn cuMemGetAllocationPropertiesFromHandle(
        prop: *mut CUmemAllocationProp,
        handle: CUmemGenericAllocationHandle,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Given an address \\p addr, returns the allocation handle of the backing memory allocation.\n\n The handle is guaranteed to be the same handle value used to map the memory. If the address\n requested is not mapped, the function will fail. The returned handle must be released with\n corresponding number of calls to ::cuMemRelease.\n\n \\note The address \\p addr, can be any address in a range previously mapped\n by ::cuMemMap, and not necessarily the start address.\n\n \\param[out] handle CUDA Memory handle for the backing memory allocation.\n \\param[in] addr Memory address to query, that has been mapped previously.\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_PERMITTED,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuMemCreate, ::cuMemRelease, ::cuMemMap"]
    pub fn cuMemRetainAllocationHandle(
        handle: *mut CUmemGenericAllocationHandle,
        addr: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Frees memory with stream ordered semantics\n\n Inserts a free operation into \\p hStream.\n The allocation must not be accessed after stream execution reaches the free.\n After this API returns, accessing the memory from any subsequent work launched on the GPU\n or querying its pointer attributes results in undefined behavior.\n\n \\note During stream capture, this function results in the creation of a free node and\n       must therefore be passed the address of a graph allocation.\n\n \\param dptr - memory to free\n \\param hStream - The stream establishing the stream ordering contract.\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT (default stream specified with no current context),\n ::CUDA_ERROR_NOT_SUPPORTED"]
    pub fn cuMemFreeAsync(dptr: CUdeviceptr, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocates memory with stream ordered semantics\n\n Inserts an allocation operation into \\p hStream.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the memory pool current to the stream's device.\n\n \\note The default memory pool of a device contains device memory from that device.\n \\note Basic stream ordering allows future work submitted into the same stream to use the allocation.\n       Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation\n       operation completes before work submitted in a separate stream runs.\n \\note During stream capture, this function results in the creation of an allocation node.  In this case,\n       the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n       are used to set the node's creation parameters.\n\n \\param[out] dptr    - Returned device pointer\n \\param[in] bytesize - Number of bytes to allocate\n \\param[in] hStream  - The stream establishing the stream ordering contract and the memory pool to allocate from\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT (default stream specified with no current context),\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuMemAllocFromPoolAsync, ::cuMemFreeAsync, ::cuDeviceSetMemPool,\n     ::cuDeviceGetDefaultMemPool, ::cuDeviceGetMemPool, ::cuMemPoolCreate,\n     ::cuMemPoolSetAccess, ::cuMemPoolSetAttribute"]
    pub fn cuMemAllocAsync(dptr: *mut CUdeviceptr, bytesize: usize, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Tries to release memory back to the OS\n\n Releases memory back to the OS until the pool contains fewer than minBytesToKeep\n reserved bytes, or there is no more memory that the allocator can safely release.\n The allocator cannot release OS allocations that back outstanding asynchronous allocations.\n The OS allocations may happen at different granularity from the user allocations.\n\n \\note: Allocations that have not been freed count as outstanding.\n \\note: Allocations that have been asynchronously freed but whose completion has\n        not been observed on the host (eg. by a synchronize) can count as outstanding.\n\n \\param[in] pool           - The memory pool to trim\n \\param[in] minBytesToKeep - If the pool has less than minBytesToKeep reserved,\n the TrimTo operation is a no-op.  Otherwise the pool will be guaranteed to have\n at least minBytesToKeep bytes reserved after the operation.\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,\n     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolTrimTo(pool: CUmemoryPool, minBytesToKeep: usize) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets attributes of a memory pool\n\n Supported attributes are:\n - ::CU_MEMPOOL_ATTR_RELEASE_THRESHOLD: (value type = cuuint64_t)\n                    Amount of reserved memory in bytes to hold onto before trying\n                    to release memory back to the OS. When more than the release\n                    threshold bytes of memory are held by the memory pool, the\n                    allocator will try to release memory back to the OS on the\n                    next call to stream, event or context synchronize. (default 0)\n - ::CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES: (value type = int)\n                    Allow ::cuMemAllocAsync to use memory asynchronously freed\n                    in another stream as long as a stream ordering dependency\n                    of the allocating stream on the free action exists.\n                    Cuda events and null stream interactions can create the required\n                    stream ordered dependencies. (default enabled)\n - ::CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC: (value type = int)\n                    Allow reuse of already completed frees when there is no dependency\n                    between the free and allocation. (default enabled)\n - ::CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES: (value type = int)\n                    Allow ::cuMemAllocAsync to insert new stream dependencies\n                    in order to establish the stream ordering required to reuse\n                    a piece of memory released by ::cuMemFreeAsync (default enabled).\n - ::CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH: (value type = cuuint64_t)\n                    Reset the high watermark that tracks the amount of backing memory that was\n                    allocated for the memory pool. It is illegal to set this attribute to a non-zero value.\n - ::CU_MEMPOOL_ATTR_USED_MEM_HIGH: (value type = cuuint64_t)\n                    Reset the high watermark that tracks the amount of used memory that was\n                    allocated for the memory pool.\n\n \\param[in] pool  - The memory pool to modify\n \\param[in] attr  - The attribute to modify\n \\param[in] value - Pointer to the value to assign\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,\n     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolSetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets attributes of a memory pool\n\n Supported attributes are:\n - ::CU_MEMPOOL_ATTR_RELEASE_THRESHOLD: (value type = cuuint64_t)\n                    Amount of reserved memory in bytes to hold onto before trying\n                    to release memory back to the OS. When more than the release\n                    threshold bytes of memory are held by the memory pool, the\n                    allocator will try to release memory back to the OS on the\n                    next call to stream, event or context synchronize. (default 0)\n - ::CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES: (value type = int)\n                    Allow ::cuMemAllocAsync to use memory asynchronously freed\n                    in another stream as long as a stream ordering dependency\n                    of the allocating stream on the free action exists.\n                    Cuda events and null stream interactions can create the required\n                    stream ordered dependencies. (default enabled)\n - ::CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC: (value type = int)\n                    Allow reuse of already completed frees when there is no dependency\n                    between the free and allocation. (default enabled)\n - ::CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES: (value type = int)\n                    Allow ::cuMemAllocAsync to insert new stream dependencies\n                    in order to establish the stream ordering required to reuse\n                    a piece of memory released by ::cuMemFreeAsync (default enabled).\n - ::CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT: (value type = cuuint64_t)\n                    Amount of backing memory currently allocated for the mempool\n - ::CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH: (value type = cuuint64_t)\n                    High watermark of backing memory allocated for the mempool since the\n                    last time it was reset.\n - ::CU_MEMPOOL_ATTR_USED_MEM_CURRENT: (value type = cuuint64_t)\n                    Amount of memory from the pool that is currently in use by the application.\n - ::CU_MEMPOOL_ATTR_USED_MEM_HIGH: (value type = cuuint64_t)\n                    High watermark of the amount of memory from the pool that was in use by the application.\n\n \\param[in] pool   - The memory pool to get attributes of\n \\param[in] attr   - The attribute to get\n \\param[out] value - Retrieved value\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,\n     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolGetAttribute(
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Controls visibility of pools between devices\n\n \\param[in] pool  - The pool being modified\n \\param[in] map   - Array of access descriptors. Each descriptor instructs the access to enable for a single gpu.\n \\param[in] count - Number of descriptors in the map array.\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,\n     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolSetAccess(
        pool: CUmemoryPool,
        map: *const CUmemAccessDesc,
        count: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the accessibility of a pool from a device\n\n Returns the accessibility of the pool's memory from the specified location.\n\n \\param[out] flags   - the accessibility of the pool from the specified location\n \\param[in] memPool  - the pool being queried\n \\param[in] location - the location accessing the pool\n\n \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,\n     ::cuDeviceGetMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolGetAccess(
        flags: *mut CUmemAccess_flags,
        memPool: CUmemoryPool,
        location: *mut CUmemLocation,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a memory pool\n\n Creates a CUDA memory pool and returns the handle in \\p pool.  The \\p poolProps determines\n the properties of the pool such as the backing device and IPC capabilities.\n\n By default, the pool's memory will be accessible from the device it is allocated on.\n\n \\note Specifying CU_MEM_HANDLE_TYPE_NONE creates a memory pool that will not support IPC.\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY,\n ::CUDA_ERROR_NOT_SUPPORTED\n\n \\sa ::cuDeviceSetMemPool, ::cuDeviceGetMemPool, ::cuDeviceGetDefaultMemPool,\n     ::cuMemAllocFromPoolAsync, ::cuMemPoolExportToShareableHandle"]
    pub fn cuMemPoolCreate(pool: *mut CUmemoryPool, poolProps: *const CUmemPoolProps) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys the specified memory pool\n\n If any pointers obtained from this pool haven't been freed or\n the pool has free operations that haven't completed\n when ::cuMemPoolDestroy is invoked, the function will return immediately and the\n resources associated with the pool will be released automatically\n once there are no more outstanding allocations.\n\n Destroying the current mempool of a device sets the default mempool of\n that device as the current mempool for that device.\n\n \\note A device's default memory pool cannot be destroyed.\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuMemFreeAsync, ::cuDeviceSetMemPool, ::cuDeviceGetMemPool,\n     ::cuDeviceGetDefaultMemPool, ::cuMemPoolCreate"]
    pub fn cuMemPoolDestroy(pool: CUmemoryPool) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Allocates memory from a specified pool with stream ordered semantics.\n\n Inserts an allocation operation into \\p hStream.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the the allocation operation completes.\n The allocation comes from the specified memory pool.\n\n \\note\n    -  The specified memory pool may be from a device different than that of the specified \\p hStream.\n\n    -  Basic stream ordering allows future work submitted into the same stream to use the allocation.\n       Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation\n       operation completes before work submitted in a separate stream runs.\n\n \\note During stream capture, this function results in the creation of an allocation node.  In this case,\n       the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n       are used to set the node's creation parameters.\n\n \\param[out] dptr    - Returned device pointer\n \\param[in] bytesize - Number of bytes to allocate\n \\param[in] pool     - The pool to allocate from\n \\param[in] hStream  - The stream establishing the stream ordering semantic\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT (default stream specified with no current context),\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuMemAllocAsync, ::cuMemFreeAsync, ::cuDeviceGetDefaultMemPool,\n     ::cuDeviceGetMemPool, ::cuMemPoolCreate, ::cuMemPoolSetAccess,\n     ::cuMemPoolSetAttribute"]
    pub fn cuMemAllocFromPoolAsync(
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        pool: CUmemoryPool,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Exports a memory pool to the requested handle type.\n\n Given an IPC capable mempool, create an OS handle to share the pool with another process.\n A recipient process can convert the shareable handle into a mempool with ::cuMemPoolImportFromShareableHandle.\n Individual pointers can then be shared with the ::cuMemPoolExportPointer and ::cuMemPoolImportPointer APIs.\n The implementation of what the shareable handle is and how it can be transferred is defined by the requested\n handle type.\n\n \\note: To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than CU_MEM_HANDLE_TYPE_NONE.\n\n \\param[out] handle_out  - Returned OS handle\n \\param[in] pool         - pool to export\n \\param[in] handleType   - the type of handle to create\n \\param[in] flags        - must be 0\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuMemPoolImportFromShareableHandle, ::cuMemPoolExportPointer,\n     ::cuMemPoolImportPointer, ::cuMemAllocAsync, ::cuMemFreeAsync,\n     ::cuDeviceGetDefaultMemPool, ::cuDeviceGetMemPool, ::cuMemPoolCreate,\n     ::cuMemPoolSetAccess, ::cuMemPoolSetAttribute"]
    pub fn cuMemPoolExportToShareableHandle(
        handle_out: *mut ::std::os::raw::c_void,
        pool: CUmemoryPool,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief imports a memory pool from a shared handle.\n\n Specific allocations can be imported from the imported pool with cuMemPoolImportPointer.\n\n \\note Imported memory pools do not support creating new allocations.\n       As such imported memory pools may not be used in cuDeviceSetMemPool\n       or ::cuMemAllocFromPoolAsync calls.\n\n \\param[out] pool_out    - Returned memory pool\n \\param[in] handle       - OS handle of the pool to open\n \\param[in] handleType   - The type of handle being imported\n \\param[in] flags        - must be 0\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuMemPoolExportToShareableHandle, ::cuMemPoolExportPointer, ::cuMemPoolImportPointer"]
    pub fn cuMemPoolImportFromShareableHandle(
        pool_out: *mut CUmemoryPool,
        handle: *mut ::std::os::raw::c_void,
        handleType: CUmemAllocationHandleType,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Export data to share a memory pool allocation between processes.\n\n Constructs \\p shareData_out for sharing a specific allocation from an already shared memory pool.\n The recipient process can import the allocation with the ::cuMemPoolImportPointer api.\n The data is not a handle and may be shared through any IPC mechanism.\n\n \\param[out] shareData_out - Returned export data\n \\param[in] ptr            - pointer to memory being exported\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuMemPoolExportToShareableHandle, ::cuMemPoolImportFromShareableHandle, ::cuMemPoolImportPointer"]
    pub fn cuMemPoolExportPointer(
        shareData_out: *mut CUmemPoolPtrExportData,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Import a memory pool allocation from another process.\n\n Returns in \\p ptr_out a pointer to the imported memory.\n The imported memory must not be accessed before the allocation operation completes\n in the exporting process. The imported memory must be freed from all importing processes before\n being freed in the exporting process. The pointer may be freed with cuMemFree\n or cuMemFreeAsync.  If cuMemFreeAsync is used, the free must be completed\n on the importing process before the free operation on the exporting process.\n\n \\note The cuMemFreeAsync api may be used in the exporting process before\n       the cuMemFreeAsync operation completes in its stream as long as the\n       cuMemFreeAsync in the exporting process specifies a stream with\n       a stream dependency on the importing process's cuMemFreeAsync.\n\n \\param[out] ptr_out  - pointer to imported memory\n \\param[in] pool      - pool from which to import\n \\param[in] shareData - data specifying the memory to import\n\n \\returns\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_OUT_OF_MEMORY\n\n \\sa ::cuMemPoolExportToShareableHandle, ::cuMemPoolImportFromShareableHandle, ::cuMemPoolExportPointer"]
    pub fn cuMemPoolImportPointer(
        ptr_out: *mut CUdeviceptr,
        pool: CUmemoryPool,
        shareData: *mut CUmemPoolPtrExportData,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about a pointer\n\n The supported attributes are:\n\n - ::CU_POINTER_ATTRIBUTE_CONTEXT:\n\n      Returns in \\p *data the ::CUcontext in which \\p ptr was allocated or\n      registered.\n      The type of \\p data must be ::CUcontext *.\n\n      If \\p ptr was not allocated by, mapped by, or registered with\n      a ::CUcontext which uses unified virtual addressing then\n      ::CUDA_ERROR_INVALID_VALUE is returned.\n\n - ::CU_POINTER_ATTRIBUTE_MEMORY_TYPE:\n\n      Returns in \\p *data the physical memory type of the memory that\n      \\p ptr addresses as a ::CUmemorytype enumerated value.\n      The type of \\p data must be unsigned int.\n\n      If \\p ptr addresses device memory then \\p *data is set to\n      ::CU_MEMORYTYPE_DEVICE.  The particular ::CUdevice on which the\n      memory resides is the ::CUdevice of the ::CUcontext returned by the\n      ::CU_POINTER_ATTRIBUTE_CONTEXT attribute of \\p ptr.\n\n      If \\p ptr addresses host memory then \\p *data is set to\n      ::CU_MEMORYTYPE_HOST.\n\n      If \\p ptr was not allocated by, mapped by, or registered with\n      a ::CUcontext which uses unified virtual addressing then\n      ::CUDA_ERROR_INVALID_VALUE is returned.\n\n      If the current ::CUcontext does not support unified virtual\n      addressing then ::CUDA_ERROR_INVALID_CONTEXT is returned.\n\n - ::CU_POINTER_ATTRIBUTE_DEVICE_POINTER:\n\n      Returns in \\p *data the device pointer value through which\n      \\p ptr may be accessed by kernels running in the current\n      ::CUcontext.\n      The type of \\p data must be CUdeviceptr *.\n\n      If there exists no device pointer value through which\n      kernels running in the current ::CUcontext may access\n      \\p ptr then ::CUDA_ERROR_INVALID_VALUE is returned.\n\n      If there is no current ::CUcontext then\n      ::CUDA_ERROR_INVALID_CONTEXT is returned.\n\n      Except in the exceptional disjoint addressing cases discussed\n      below, the value returned in \\p *data will equal the input\n      value \\p ptr.\n\n - ::CU_POINTER_ATTRIBUTE_HOST_POINTER:\n\n      Returns in \\p *data the host pointer value through which\n      \\p ptr may be accessed by by the host program.\n      The type of \\p data must be void **.\n      If there exists no host pointer value through which\n      the host program may directly access \\p ptr then\n      ::CUDA_ERROR_INVALID_VALUE is returned.\n\n      Except in the exceptional disjoint addressing cases discussed\n      below, the value returned in \\p *data will equal the input\n      value \\p ptr.\n\n - ::CU_POINTER_ATTRIBUTE_P2P_TOKENS:\n\n      Returns in \\p *data two tokens for use with the nv-p2p.h Linux\n      kernel interface. \\p data must be a struct of type\n      CUDA_POINTER_ATTRIBUTE_P2P_TOKENS.\n\n      \\p ptr must be a pointer to memory obtained from :cuMemAlloc().\n      Note that p2pToken and vaSpaceToken are only valid for the\n      lifetime of the source allocation. A subsequent allocation at\n      the same address may return completely different tokens.\n      Querying this attribute has a side effect of setting the attribute\n      ::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS for the region of memory that\n      \\p ptr points to.\n\n - ::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS:\n\n      A boolean attribute which when set, ensures that synchronous memory operations\n      initiated on the region of memory that \\p ptr points to will always synchronize.\n      See further documentation in the section titled \"API synchronization behavior\"\n      to learn more about cases when synchronous memory operations can\n      exhibit asynchronous behavior.\n\n - ::CU_POINTER_ATTRIBUTE_BUFFER_ID:\n\n      Returns in \\p *data a buffer ID which is guaranteed to be unique within the process.\n      \\p data must point to an unsigned long long.\n\n      \\p ptr must be a pointer to memory obtained from a CUDA memory allocation API.\n      Every memory allocation from any of the CUDA memory allocation APIs will\n      have a unique ID over a process lifetime. Subsequent allocations do not reuse IDs\n      from previous freed allocations. IDs are only unique within a single process.\n\n\n - ::CU_POINTER_ATTRIBUTE_IS_MANAGED:\n\n      Returns in \\p *data a boolean that indicates whether the pointer points to\n      managed memory or not.\n\n      If \\p ptr is not a valid CUDA pointer then ::CUDA_ERROR_INVALID_VALUE is returned.\n\n - ::CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL:\n\n      Returns in \\p *data an integer representing a device ordinal of a device against\n      which the memory was allocated or registered.\n\n - ::CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE:\n\n      Returns in \\p *data a boolean that indicates if this pointer maps to\n      an allocation that is suitable for ::cudaIpcGetMemHandle.\n\n - ::CU_POINTER_ATTRIBUTE_RANGE_START_ADDR:\n\n      Returns in \\p *data the starting address for the allocation referenced\n      by the device pointer \\p ptr.  Note that this is not necessarily the\n      address of the mapped region, but the address of the mappable address\n      range \\p ptr references (e.g. from ::cuMemAddressReserve).\n\n - ::CU_POINTER_ATTRIBUTE_RANGE_SIZE:\n\n      Returns in \\p *data the size for the allocation referenced by the device\n      pointer \\p ptr.  Note that this is not necessarily the size of the mapped\n      region, but the size of the mappable address range \\p ptr references\n      (e.g. from ::cuMemAddressReserve).  To retrieve the size of the mapped\n      region, see ::cuMemGetAddressRange\n\n - ::CU_POINTER_ATTRIBUTE_MAPPED:\n\n      Returns in \\p *data a boolean that indicates if this pointer is in a\n      valid address range that is mapped to a backing allocation.\n\n - ::CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES:\n\n      Returns a bitmask of the allowed handle types for an allocation that may\n      be passed to ::cuMemExportToShareableHandle.\n\n - ::CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE:\n\n      Returns in \\p *data the handle to the mempool that the allocation was obtained from.\n\n \\par\n\n Note that for most allocations in the unified virtual address space\n the host and device pointer for accessing the allocation will be the\n same.  The exceptions to this are\n  - user memory registered using ::cuMemHostRegister\n  - host memory allocated using ::cuMemHostAlloc with the\n    ::CU_MEMHOSTALLOC_WRITECOMBINED flag\n For these types of allocation there will exist separate, disjoint host\n and device addresses for accessing the allocation.  In particular\n  - The host address will correspond to an invalid unmapped device address\n    (which will result in an exception if accessed from the device)\n  - The device address will correspond to an invalid unmapped host address\n    (which will result in an exception if accessed from the host).\n For these types of allocations, querying ::CU_POINTER_ATTRIBUTE_HOST_POINTER\n and ::CU_POINTER_ATTRIBUTE_DEVICE_POINTER may be used to retrieve the host\n and device addresses from either address.\n\n \\param data      - Returned pointer attribute value\n \\param attribute - Pointer attribute to query\n \\param ptr       - Pointer\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuPointerSetAttribute,\n ::cuMemAlloc,\n ::cuMemFree,\n ::cuMemAllocHost,\n ::cuMemFreeHost,\n ::cuMemHostAlloc,\n ::cuMemHostRegister,\n ::cuMemHostUnregister,\n ::cudaPointerGetAttributes"]
    pub fn cuPointerGetAttribute(
        data: *mut ::std::os::raw::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Prefetches memory to the specified destination device\n\n Prefetches memory to the specified destination device.  \\p devPtr is the\n base device pointer of the memory to be prefetched and \\p dstDevice is the\n destination device. \\p count specifies the number of bytes to copy. \\p hStream\n is the stream in which the operation is enqueued. The memory range must refer\n to managed memory allocated via ::cuMemAllocManaged or declared via __managed__ variables.\n\n Passing in CU_DEVICE_CPU for \\p dstDevice will prefetch the data to host memory. If\n \\p dstDevice is a GPU, then the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS\n must be non-zero. Additionally, \\p hStream must be associated with a device that has a\n non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS.\n\n The start address and end address of the memory range will be rounded down and rounded up\n respectively to be aligned to CPU page size before the prefetch operation is enqueued\n in the stream.\n\n If no physical memory has been allocated for this region, then this memory region\n will be populated and mapped on the destination device. If there's insufficient\n memory to prefetch the desired region, the Unified Memory driver may evict pages from other\n ::cuMemAllocManaged allocations to host memory in order to make room. Device memory\n allocated using ::cuMemAlloc or ::cuArrayCreate will not be evicted.\n\n By default, any mappings to the previous location of the migrated pages are removed and\n mappings for the new location are only setup on \\p dstDevice. The exact behavior however\n also depends on the settings applied to this memory range via ::cuMemAdvise as described\n below:\n\n If ::CU_MEM_ADVISE_SET_READ_MOSTLY was set on any subset of this memory range,\n then that subset will create a read-only copy of the pages on \\p dstDevice.\n\n If ::CU_MEM_ADVISE_SET_PREFERRED_LOCATION was called on any subset of this memory\n range, then the pages will be migrated to \\p dstDevice even if \\p dstDevice is not the\n preferred location of any pages in the memory range.\n\n If ::CU_MEM_ADVISE_SET_ACCESSED_BY was called on any subset of this memory range,\n then mappings to those pages from all the appropriate processors are updated to\n refer to the new location if establishing such a mapping is possible. Otherwise,\n those mappings are cleared.\n\n Note that this API is not required for functionality and only serves to improve performance\n by allowing the application to migrate data to a suitable location before it is accessed.\n Memory accesses to this range are always coherent and are allowed even when the data is\n actively being migrated.\n\n Note that this function is asynchronous with respect to the host and all work\n on other devices.\n\n \\param devPtr    - Pointer to be prefetched\n \\param count     - Size in bytes\n \\param dstDevice - Destination device to prefetch to\n \\param hStream    - Stream to enqueue prefetch operation\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n \\note_async\n \\note_null_stream\n\n \\sa ::cuMemcpy, ::cuMemcpyPeer, ::cuMemcpyAsync,\n ::cuMemcpy3DPeerAsync, ::cuMemAdvise,\n ::cudaMemPrefetchAsync"]
    pub fn cuMemPrefetchAsync(
        devPtr: CUdeviceptr,
        count: usize,
        dstDevice: CUdevice,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Advise about the usage of a given memory range\n\n Advise the Unified Memory subsystem about the usage pattern for the memory range\n starting at \\p devPtr with a size of \\p count bytes. The start address and end address of the memory\n range will be rounded down and rounded up respectively to be aligned to CPU page size before the\n advice is applied. The memory range must refer to managed memory allocated via ::cuMemAllocManaged\n or declared via __managed__ variables. The memory range could also refer to system-allocated pageable\n memory provided it represents a valid, host-accessible region of memory and all additional constraints\n imposed by \\p advice as outlined below are also satisfied. Specifying an invalid system-allocated pageable\n memory range results in an error being returned.\n\n The \\p advice parameter can take the following values:\n - ::CU_MEM_ADVISE_SET_READ_MOSTLY: This implies that the data is mostly going to be read\n from and only occasionally written to. Any read accesses from any processor to this region will create a\n read-only copy of at least the accessed pages in that processor's memory. Additionally, if ::cuMemPrefetchAsync\n is called on this region, it will create a read-only copy of the data on the destination processor.\n If any processor writes to this region, all copies of the corresponding page will be invalidated\n except for the one where the write occurred. The \\p device argument is ignored for this advice.\n Note that for a page to be read-duplicated, the accessing processor must either be the CPU or a GPU\n that has a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS.\n Also, if a context is created on a device that does not have the device attribute\n ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS set, then read-duplication will not occur until\n all such contexts are destroyed.\n If the memory region refers to valid system-allocated pageable memory, then the accessing device must\n have a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS for a read-only\n copy to be created on that device. Note however that if the accessing device also has a non-zero value for the\n device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES, then setting this advice\n will not create a read-only copy when that device accesses this memory region.\n\n - ::CU_MEM_ADVISE_UNSET_READ_MOSTLY:  Undoes the effect of ::CU_MEM_ADVISE_SET_READ_MOSTLY and also prevents the\n Unified Memory driver from attempting heuristic read-duplication on the memory range. Any read-duplicated\n copies of the data will be collapsed into a single copy. The location for the collapsed\n copy will be the preferred location if the page has a preferred location and one of the read-duplicated\n copies was resident at that location. Otherwise, the location chosen is arbitrary.\n\n - ::CU_MEM_ADVISE_SET_PREFERRED_LOCATION: This advice sets the preferred location for the\n data to be the memory belonging to \\p device. Passing in CU_DEVICE_CPU for \\p device sets the\n preferred location as host memory. If \\p device is a GPU, then it must have a non-zero value for the\n device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS. Setting the preferred location\n does not cause data to migrate to that location immediately. Instead, it guides the migration policy\n when a fault occurs on that memory region. If the data is already in its preferred location and the\n faulting processor can establish a mapping without requiring the data to be migrated, then\n data migration will be avoided. On the other hand, if the data is not in its preferred location\n or if a direct mapping cannot be established, then it will be migrated to the processor accessing\n it. It is important to note that setting the preferred location does not prevent data prefetching\n done using ::cuMemPrefetchAsync.\n Having a preferred location can override the page thrash detection and resolution logic in the Unified\n Memory driver. Normally, if a page is detected to be constantly thrashing between for example host and device\n memory, the page may eventually be pinned to host memory by the Unified Memory driver. But\n if the preferred location is set as device memory, then the page will continue to thrash indefinitely.\n If ::CU_MEM_ADVISE_SET_READ_MOSTLY is also set on this memory region or any subset of it, then the\n policies associated with that advice will override the policies of this advice, unless read accesses from\n \\p device will not result in a read-only copy being created on that device as outlined in description for\n the advice ::CU_MEM_ADVISE_SET_READ_MOSTLY.\n If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero\n value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS. Additionally, if \\p device has\n a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES,\n then this call has no effect. Note however that this behavior may change in the future.\n\n - ::CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION: Undoes the effect of ::CU_MEM_ADVISE_SET_PREFERRED_LOCATION\n and changes the preferred location to none.\n\n - ::CU_MEM_ADVISE_SET_ACCESSED_BY: This advice implies that the data will be accessed by \\p device.\n Passing in ::CU_DEVICE_CPU for \\p device will set the advice for the CPU. If \\p device is a GPU, then\n the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS must be non-zero.\n This advice does not cause data migration and has no impact on the location of the data per se. Instead,\n it causes the data to always be mapped in the specified processor's page tables, as long as the\n location of the data permits a mapping to be established. If the data gets migrated for any reason,\n the mappings are updated accordingly.\n This advice is recommended in scenarios where data locality is not important, but avoiding faults is.\n Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the\n data located on one GPU is occasionally accessed by peer GPUs. In such scenarios, migrating data\n over to the other GPUs is not as important because the accesses are infrequent and the overhead of\n migration may be too high. But preventing faults can still help improve performance, and so having\n a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated\n to host memory because the CPU typically cannot access device memory directly. Any GPU that had the\n ::CU_MEM_ADVISE_SET_ACCESSED_BY flag set for this data will now have its mapping updated to point to the\n page in host memory.\n If ::CU_MEM_ADVISE_SET_READ_MOSTLY is also set on this memory region or any subset of it, then the\n policies associated with that advice will override the policies of this advice. Additionally, if the\n preferred location of this memory region or any subset of it is also \\p device, then the policies\n associated with ::CU_MEM_ADVISE_SET_PREFERRED_LOCATION will override the policies of this advice.\n If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero\n value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS. Additionally, if \\p device has\n a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES,\n then this call has no effect.\n\n - ::CU_MEM_ADVISE_UNSET_ACCESSED_BY: Undoes the effect of ::CU_MEM_ADVISE_SET_ACCESSED_BY. Any mappings to\n the data from \\p device may be removed at any time causing accesses to result in non-fatal page faults.\n If the memory region refers to valid system-allocated pageable memory, then \\p device must have a non-zero\n value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS. Additionally, if \\p device has\n a non-zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES,\n then this call has no effect.\n\n \\param devPtr - Pointer to memory to set the advice for\n \\param count  - Size in bytes of the memory range\n \\param advice - Advice to be applied for the specified memory range\n \\param device - Device to apply the advice for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n \\note_async\n \\note_null_stream\n\n \\sa ::cuMemcpy, ::cuMemcpyPeer, ::cuMemcpyAsync,\n ::cuMemcpy3DPeerAsync, ::cuMemPrefetchAsync,\n ::cudaMemAdvise"]
    pub fn cuMemAdvise(
        devPtr: CUdeviceptr,
        count: usize,
        advice: CUmem_advise,
        device: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query an attribute of a given memory range\n\n Query an attribute about the memory range starting at \\p devPtr with a size of \\p count bytes. The\n memory range must refer to managed memory allocated via ::cuMemAllocManaged or declared via\n __managed__ variables.\n\n The \\p attribute parameter can take the following values:\n - ::CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY: If this attribute is specified, \\p data will be interpreted\n as a 32-bit integer, and \\p dataSize must be 4. The result returned will be 1 if all pages in the given\n memory range have read-duplication enabled, or 0 otherwise.\n - ::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION: If this attribute is specified, \\p data will be\n interpreted as a 32-bit integer, and \\p dataSize must be 4. The result returned will be a GPU device\n id if all pages in the memory range have that GPU as their preferred location, or it will be CU_DEVICE_CPU\n if all pages in the memory range have the CPU as their preferred location, or it will be CU_DEVICE_INVALID\n if either all the pages don't have the same preferred location or some of the pages don't have a\n preferred location at all. Note that the actual location of the pages in the memory range at the time of\n the query may be different from the preferred location.\n - ::CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY: If this attribute is specified, \\p data will be interpreted\n as an array of 32-bit integers, and \\p dataSize must be a non-zero multiple of 4. The result returned\n will be a list of device ids that had ::CU_MEM_ADVISE_SET_ACCESSED_BY set for that entire memory range.\n If any device does not have that advice set for the entire memory range, that device will not be included.\n If \\p data is larger than the number of devices that have that advice set for that memory range,\n CU_DEVICE_INVALID will be returned in all the extra space provided. For ex., if \\p dataSize is 12\n (i.e. \\p data has 3 elements) and only device 0 has the advice set, then the result returned will be\n { 0, CU_DEVICE_INVALID, CU_DEVICE_INVALID }. If \\p data is smaller than the number of devices that have\n that advice set, then only as many devices will be returned as can fit in the array. There is no\n guarantee on which specific devices will be returned, however.\n - ::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION: If this attribute is specified, \\p data will be\n interpreted as a 32-bit integer, and \\p dataSize must be 4. The result returned will be the last location\n to which all pages in the memory range were prefetched explicitly via ::cuMemPrefetchAsync. This will either be\n a GPU id or CU_DEVICE_CPU depending on whether the last location for prefetch was a GPU or the CPU\n respectively. If any page in the memory range was never explicitly prefetched or if all pages were not\n prefetched to the same location, CU_DEVICE_INVALID will be returned. Note that this simply returns the\n last location that the applicaton requested to prefetch the memory range to. It gives no indication as to\n whether the prefetch operation to that location has completed or even begun.\n\n \\param data      - A pointers to a memory location where the result\n                    of each attribute query will be written to.\n \\param dataSize  - Array containing the size of data\n \\param attribute - The attribute to query\n \\param devPtr    - Start of the range to query\n \\param count     - Size of the range to query\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n \\note_async\n \\note_null_stream\n\n \\sa ::cuMemRangeGetAttributes, ::cuMemPrefetchAsync,\n ::cuMemAdvise,\n ::cudaMemRangeGetAttribute"]
    pub fn cuMemRangeGetAttribute(
        data: *mut ::std::os::raw::c_void,
        dataSize: usize,
        attribute: CUmem_range_attribute,
        devPtr: CUdeviceptr,
        count: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query attributes of a given memory range.\n\n Query attributes of the memory range starting at \\p devPtr with a size of \\p count bytes. The\n memory range must refer to managed memory allocated via ::cuMemAllocManaged or declared via\n __managed__ variables. The \\p attributes array will be interpreted to have \\p numAttributes\n entries. The \\p dataSizes array will also be interpreted to have \\p numAttributes entries.\n The results of the query will be stored in \\p data.\n\n The list of supported attributes are given below. Please refer to ::cuMemRangeGetAttribute for\n attribute descriptions and restrictions.\n\n - ::CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY\n - ::CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION\n - ::CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY\n - ::CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION\n\n \\param data          - A two-dimensional array containing pointers to memory\n                        locations where the result of each attribute query will be written to.\n \\param dataSizes     - Array containing the sizes of each result\n \\param attributes    - An array of attributes to query\n                        (numAttributes and the number of attributes in this array should match)\n \\param numAttributes - Number of attributes to query\n \\param devPtr        - Start of the range to query\n \\param count         - Size of the range to query\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa ::cuMemRangeGetAttribute, ::cuMemAdvise,\n ::cuMemPrefetchAsync,\n ::cudaMemRangeGetAttributes"]
    pub fn cuMemRangeGetAttributes(
        data: *mut *mut ::std::os::raw::c_void,
        dataSizes: *mut usize,
        attributes: *mut CUmem_range_attribute,
        numAttributes: usize,
        devPtr: CUdeviceptr,
        count: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Set attributes on a previously allocated memory region\n\n The supported attributes are:\n\n - ::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS:\n\n      A boolean attribute that can either be set (1) or unset (0). When set,\n      the region of memory that \\p ptr points to is guaranteed to always synchronize\n      memory operations that are synchronous. If there are some previously initiated\n      synchronous memory operations that are pending when this attribute is set, the\n      function does not return until those memory operations are complete.\n      See further documentation in the section titled \"API synchronization behavior\"\n      to learn more about cases when synchronous memory operations can\n      exhibit asynchronous behavior.\n      \\p value will be considered as a pointer to an unsigned integer to which this attribute is to be set.\n\n \\param value     - Pointer to memory containing the value to be set\n \\param attribute - Pointer attribute to set\n \\param ptr       - Pointer to a memory region allocated using CUDA memory allocation APIs\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa ::cuPointerGetAttribute,\n ::cuPointerGetAttributes,\n ::cuMemAlloc,\n ::cuMemFree,\n ::cuMemAllocHost,\n ::cuMemFreeHost,\n ::cuMemHostAlloc,\n ::cuMemHostRegister,\n ::cuMemHostUnregister"]
    pub fn cuPointerSetAttribute(
        value: *const ::std::os::raw::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about a pointer.\n\n The supported attributes are (refer to ::cuPointerGetAttribute for attribute descriptions and restrictions):\n\n - ::CU_POINTER_ATTRIBUTE_CONTEXT\n - ::CU_POINTER_ATTRIBUTE_MEMORY_TYPE\n - ::CU_POINTER_ATTRIBUTE_DEVICE_POINTER\n - ::CU_POINTER_ATTRIBUTE_HOST_POINTER\n - ::CU_POINTER_ATTRIBUTE_SYNC_MEMOPS\n - ::CU_POINTER_ATTRIBUTE_BUFFER_ID\n - ::CU_POINTER_ATTRIBUTE_IS_MANAGED\n - ::CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL\n - ::CU_POINTER_ATTRIBUTE_RANGE_START_ADDR\n - ::CU_POINTER_ATTRIBUTE_RANGE_SIZE\n - ::CU_POINTER_ATTRIBUTE_MAPPED\n - ::CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE\n - ::CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES\n - ::CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE\n\n \\param numAttributes - Number of attributes to query\n \\param attributes    - An array of attributes to query\n                      (numAttributes and the number of attributes in this array should match)\n \\param data          - A two-dimensional array containing pointers to memory\n                      locations where the result of each attribute query will be written to.\n \\param ptr           - Pointer to query\n\n Unlike ::cuPointerGetAttribute, this function will not return an error when the \\p ptr\n encountered is not a valid CUDA pointer. Instead, the attributes are assigned default NULL values\n and CUDA_SUCCESS is returned.\n\n If \\p ptr was not allocated by, mapped by, or registered with a ::CUcontext which uses UVA\n (Unified Virtual Addressing), ::CUDA_ERROR_INVALID_CONTEXT is returned.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuPointerGetAttribute,\n ::cuPointerSetAttribute,\n ::cudaPointerGetAttributes"]
    pub fn cuPointerGetAttributes(
        numAttributes: ::std::os::raw::c_uint,
        attributes: *mut CUpointer_attribute,
        data: *mut *mut ::std::os::raw::c_void,
        ptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a stream\n\n Creates a stream and returns a handle in \\p phStream.  The \\p Flags argument\n determines behaviors of the stream.\n\n Valid values for \\p Flags are:\n - ::CU_STREAM_DEFAULT: Default stream creation flag.\n - ::CU_STREAM_NON_BLOCKING: Specifies that work running in the created\n   stream may run concurrently with work in stream 0 (the NULL stream), and that\n   the created stream should perform no implicit synchronization with stream 0.\n\n \\param phStream - Returned newly created stream\n \\param Flags    - Parameters for stream creation\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\notefnerr\n\n \\sa ::cuStreamDestroy,\n ::cuStreamCreateWithPriority,\n ::cuStreamGetPriority,\n ::cuStreamGetFlags,\n ::cuStreamWaitEvent,\n ::cuStreamQuery,\n ::cuStreamSynchronize,\n ::cuStreamAddCallback,\n ::cudaStreamCreate,\n ::cudaStreamCreateWithFlags"]
    pub fn cuStreamCreate(phStream: *mut CUstream, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a stream with the given priority\n\n Creates a stream with the specified priority and returns a handle in \\p phStream.\n This API alters the scheduler priority of work in the stream. Work in a higher\n priority stream may preempt work already executing in a low priority stream.\n\n \\p priority follows a convention where lower numbers represent higher priorities.\n '0' represents default priority. The range of meaningful numerical priorities can\n be queried using ::cuCtxGetStreamPriorityRange. If the specified priority is\n outside the numerical range returned by ::cuCtxGetStreamPriorityRange,\n it will automatically be clamped to the lowest or the highest number in the range.\n\n \\param phStream    - Returned newly created stream\n \\param flags       - Flags for stream creation. See ::cuStreamCreate for a list of\n                      valid flags\n \\param priority    - Stream priority. Lower numbers represent higher priorities.\n                      See ::cuCtxGetStreamPriorityRange for more information about\n                      meaningful stream priorities that can be passed.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\notefnerr\n\n \\note Stream priorities are supported only on GPUs\n with compute capability 3.5 or higher.\n\n \\note In the current implementation, only compute kernels launched in\n priority streams are affected by the stream's priority. Stream priorities have\n no effect on host-to-device and device-to-host memory operations.\n\n \\sa ::cuStreamDestroy,\n ::cuStreamCreate,\n ::cuStreamGetPriority,\n ::cuCtxGetStreamPriorityRange,\n ::cuStreamGetFlags,\n ::cuStreamWaitEvent,\n ::cuStreamQuery,\n ::cuStreamSynchronize,\n ::cuStreamAddCallback,\n ::cudaStreamCreateWithPriority"]
    pub fn cuStreamCreateWithPriority(
        phStream: *mut CUstream,
        flags: ::std::os::raw::c_uint,
        priority: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query the priority of a given stream\n\n Query the priority of a stream created using ::cuStreamCreate or ::cuStreamCreateWithPriority\n and return the priority in \\p priority. Note that if the stream was created with a\n priority outside the numerical range returned by ::cuCtxGetStreamPriorityRange,\n this function returns the clamped priority.\n See ::cuStreamCreateWithPriority for details about priority clamping.\n\n \\param hStream    - Handle to the stream to be queried\n \\param priority   - Pointer to a signed integer in which the stream's priority is returned\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\notefnerr\n\n \\sa ::cuStreamDestroy,\n ::cuStreamCreate,\n ::cuStreamCreateWithPriority,\n ::cuCtxGetStreamPriorityRange,\n ::cuStreamGetFlags,\n ::cudaStreamGetPriority"]
    pub fn cuStreamGetPriority(hStream: CUstream, priority: *mut ::std::os::raw::c_int)
        -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query the flags of a given stream\n\n Query the flags of a stream created using ::cuStreamCreate or ::cuStreamCreateWithPriority\n and return the flags in \\p flags.\n\n \\param hStream    - Handle to the stream to be queried\n \\param flags      - Pointer to an unsigned integer in which the stream's flags are returned\n                     The value returned in \\p flags is a logical 'OR' of all flags that\n                     were used while creating this stream. See ::cuStreamCreate for the list\n                     of valid flags\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\notefnerr\n\n \\sa ::cuStreamDestroy,\n ::cuStreamCreate,\n ::cuStreamGetPriority,\n ::cudaStreamGetFlags"]
    pub fn cuStreamGetFlags(hStream: CUstream, flags: *mut ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the unique Id associated with the stream handle supplied\n\n Returns in \\p streamId the unique Id which is associated with the given stream handle.\n The Id is unique for the life of the program for this instance of CUDA.\n\n The stream handle \\p hStream can refer to any of the following:\n <ul>\n   <li>a stream created via any of the CUDA driver APIs such as ::cuStreamCreate\n   and ::cuStreamCreateWithPriority, or their runtime API equivalents such as\n   ::cudaStreamCreate, ::cudaStreamCreateWithFlags and ::cudaStreamCreateWithPriority.\n   Passing an invalid handle will result in undefined behavior.</li>\n   <li>any of the special streams such as the NULL stream, ::CU_STREAM_LEGACY and\n   ::CU_STREAM_PER_THREAD. The runtime API equivalents of these are also accepted,\n   which are NULL, ::cudaStreamLegacy and ::cudaStreamPerThread respectively.</li>\n </ul>\n\n \\param hStream    - Handle to the stream to be queried\n \\param streamId   - Pointer to store the Id of the stream\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa ::cuStreamDestroy,\n ::cuStreamCreate,\n ::cuStreamGetPriority,\n ::cudaStreamGetId"]
    pub fn cuStreamGetId(hStream: CUstream, streamId: *mut ::std::os::raw::c_ulonglong)
        -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query the context associated with a stream\n\n Returns the CUDA context that the stream is associated with.\n\n The stream handle \\p hStream can refer to any of the following:\n <ul>\n   <li>a stream created via any of the CUDA driver APIs such as ::cuStreamCreate\n   and ::cuStreamCreateWithPriority, or their runtime API equivalents such as\n   ::cudaStreamCreate, ::cudaStreamCreateWithFlags and ::cudaStreamCreateWithPriority.\n   The returned context is the context that was active in the calling thread when the\n   stream was created. Passing an invalid handle will result in undefined behavior.</li>\n   <li>any of the special streams such as the NULL stream, ::CU_STREAM_LEGACY and\n   ::CU_STREAM_PER_THREAD. The runtime API equivalents of these are also accepted,\n   which are NULL, ::cudaStreamLegacy and ::cudaStreamPerThread respectively.\n   Specifying any of the special handles will return the context current to the\n   calling thread. If no context is current to the calling thread,\n   ::CUDA_ERROR_INVALID_CONTEXT is returned.</li>\n </ul>\n\n \\param hStream - Handle to the stream to be queried\n \\param pctx    - Returned context associated with the stream\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n \\notefnerr\n\n \\sa ::cuStreamDestroy,\n ::cuStreamCreateWithPriority,\n ::cuStreamGetPriority,\n ::cuStreamGetFlags,\n ::cuStreamWaitEvent,\n ::cuStreamQuery,\n ::cuStreamSynchronize,\n ::cuStreamAddCallback,\n ::cudaStreamCreate,\n ::cudaStreamCreateWithFlags"]
    pub fn cuStreamGetCtx(hStream: CUstream, pctx: *mut CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Make a compute stream wait on an event\n\n Makes all future work submitted to \\p hStream wait for all work captured in\n \\p hEvent.  See ::cuEventRecord() for details on what is captured by an event.\n The synchronization will be performed efficiently on the device when applicable.\n \\p hEvent may be from a different context or device than \\p hStream.\n\n flags include:\n - ::CU_EVENT_WAIT_DEFAULT: Default event creation flag.\n - ::CU_EVENT_WAIT_EXTERNAL: Event is captured in the graph as an external\n   event node when performing stream capture. This flag is invalid outside\n   of stream capture.\n\n \\param hStream - Stream to wait\n \\param hEvent  - Event to wait on (may not be NULL)\n \\param Flags   - See ::CUevent_capture_flags\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuStreamCreate,\n ::cuEventRecord,\n ::cuStreamQuery,\n ::cuStreamSynchronize,\n ::cuStreamAddCallback,\n ::cuStreamDestroy,\n ::cudaStreamWaitEvent"]
    pub fn cuStreamWaitEvent(
        hStream: CUstream,
        hEvent: CUevent,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Add a callback to a compute stream\n\n \\note This function is slated for eventual deprecation and removal. If\n you do not require the callback to execute in case of a device error,\n consider using ::cuLaunchHostFunc. Additionally, this function is not\n supported with ::cuStreamBeginCapture and ::cuStreamEndCapture, unlike\n ::cuLaunchHostFunc.\n\n Adds a callback to be called on the host after all currently enqueued\n items in the stream have completed.  For each\n cuStreamAddCallback call, the callback will be executed exactly once.\n The callback will block later work in the stream until it is finished.\n\n The callback may be passed ::CUDA_SUCCESS or an error code.  In the event\n of a device error, all subsequently executed callbacks will receive an\n appropriate ::CUresult.\n\n Callbacks must not make any CUDA API calls.  Attempting to use a CUDA API\n will result in ::CUDA_ERROR_NOT_PERMITTED.  Callbacks must not perform any\n synchronization that may depend on outstanding device work or other callbacks\n that are not mandated to run earlier.  Callbacks without a mandated order\n (in independent streams) execute in undefined order and may be serialized.\n\n For the purposes of Unified Memory, callback execution makes a number of\n guarantees:\n <ul>\n   <li>The callback stream is considered idle for the duration of the\n   callback.  Thus, for example, a callback may always use memory attached\n   to the callback stream.</li>\n   <li>The start of execution of a callback has the same effect as\n   synchronizing an event recorded in the same stream immediately prior to\n   the callback.  It thus synchronizes streams which have been \"joined\"\n   prior to the callback.</li>\n   <li>Adding device work to any stream does not have the effect of making\n   the stream active until all preceding host functions and stream callbacks\n   have executed.  Thus, for\n   example, a callback might use global attached memory even if work has\n   been added to another stream, if the work has been ordered behind the\n   callback with an event.</li>\n   <li>Completion of a callback does not cause a stream to become\n   active except as described above.  The callback stream will remain idle\n   if no device work follows the callback, and will remain idle across\n   consecutive callbacks without device work in between.  Thus, for example,\n   stream synchronization can be done by signaling from a callback at the\n   end of the stream.</li>\n </ul>\n\n \\param hStream  - Stream to add callback to\n \\param callback - The function to call once preceding stream operations are complete\n \\param userData - User specified data to be passed to the callback function\n \\param flags    - Reserved for future use, must be 0\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuStreamCreate,\n ::cuStreamQuery,\n ::cuStreamSynchronize,\n ::cuStreamWaitEvent,\n ::cuStreamDestroy,\n ::cuMemAllocManaged,\n ::cuStreamAttachMemAsync,\n ::cuLaunchHostFunc,\n ::cudaStreamAddCallback"]
    pub fn cuStreamAddCallback(
        hStream: CUstream,
        callback: CUstreamCallback,
        userData: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamBeginCapture_v2(hStream: CUstream, mode: CUstreamCaptureMode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Swaps the stream capture interaction mode for a thread\n\n Sets the calling thread's stream capture interaction mode to the value contained\n in \\p *mode, and overwrites \\p *mode with the previous mode for the thread. To\n facilitate deterministic behavior across function or module boundaries, callers\n are encouraged to use this API in a push-pop fashion: \\code\nCUstreamCaptureMode mode = desiredMode;\ncuThreadExchangeStreamCaptureMode(&mode);\n...\ncuThreadExchangeStreamCaptureMode(&mode); // restore previous mode\n \\endcode\n\n During stream capture (see ::cuStreamBeginCapture), some actions, such as a call\n to ::cudaMalloc, may be unsafe. In the case of ::cudaMalloc, the operation is\n not enqueued asynchronously to a stream, and is not observed by stream capture.\n Therefore, if the sequence of operations captured via ::cuStreamBeginCapture\n depended on the allocation being replayed whenever the graph is launched, the\n captured graph would be invalid.\n\n Therefore, stream capture places restrictions on API calls that can be made within\n or concurrently to a ::cuStreamBeginCapture-::cuStreamEndCapture sequence. This\n behavior can be controlled via this API and flags to ::cuStreamBeginCapture.\n\n A thread's mode is one of the following:\n - \\p CU_STREAM_CAPTURE_MODE_GLOBAL: This is the default mode. If the local thread has\n   an ongoing capture sequence that was not initiated with\n   \\p CU_STREAM_CAPTURE_MODE_RELAXED at \\p cuStreamBeginCapture, or if any other thread\n   has a concurrent capture sequence initiated with \\p CU_STREAM_CAPTURE_MODE_GLOBAL,\n   this thread is prohibited from potentially unsafe API calls.\n - \\p CU_STREAM_CAPTURE_MODE_THREAD_LOCAL: If the local thread has an ongoing capture\n   sequence not initiated with \\p CU_STREAM_CAPTURE_MODE_RELAXED, it is prohibited\n   from potentially unsafe API calls. Concurrent capture sequences in other threads\n   are ignored.\n - \\p CU_STREAM_CAPTURE_MODE_RELAXED: The local thread is not prohibited from potentially\n   unsafe API calls. Note that the thread is still prohibited from API calls which\n   necessarily conflict with stream capture, for example, attempting ::cuEventQuery\n   on an event that was last recorded inside a capture sequence.\n\n \\param mode - Pointer to mode value to swap with the current mode\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa\n ::cuStreamBeginCapture"]
    pub fn cuThreadExchangeStreamCaptureMode(mode: *mut CUstreamCaptureMode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Ends capture on a stream, returning the captured graph\n\n End capture on \\p hStream, returning the captured graph via \\p phGraph.\n Capture must have been initiated on \\p hStream via a call to ::cuStreamBeginCapture.\n If capture was invalidated, due to a violation of the rules of stream capture, then\n a NULL graph will be returned.\n\n If the \\p mode argument to ::cuStreamBeginCapture was not\n ::CU_STREAM_CAPTURE_MODE_RELAXED, this call must be from the same thread as\n ::cuStreamBeginCapture.\n\n \\param hStream - Stream to query\n \\param phGraph - The captured graph\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD\n \\notefnerr\n\n \\sa\n ::cuStreamCreate,\n ::cuStreamBeginCapture,\n ::cuStreamIsCapturing"]
    pub fn cuStreamEndCapture(hStream: CUstream, phGraph: *mut CUgraph) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a stream's capture status\n\n Return the capture status of \\p hStream via \\p captureStatus. After a successful\n call, \\p *captureStatus will contain one of the following:\n - ::CU_STREAM_CAPTURE_STATUS_NONE: The stream is not capturing.\n - ::CU_STREAM_CAPTURE_STATUS_ACTIVE: The stream is capturing.\n - ::CU_STREAM_CAPTURE_STATUS_INVALIDATED: The stream was capturing but an error\n   has invalidated the capture sequence. The capture sequence must be terminated\n   with ::cuStreamEndCapture on the stream where it was initiated in order to\n   continue using \\p hStream.\n\n Note that, if this is called on ::CU_STREAM_LEGACY (the \"null stream\") while\n a blocking stream in the same context is capturing, it will return\n ::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT and \\p *captureStatus is unspecified\n after the call. The blocking stream capture is not invalidated.\n\n When a blocking stream is capturing, the legacy stream is in an\n unusable state until the blocking stream capture is terminated. The legacy\n stream is not supported for stream capture, but attempted use would have an\n implicit dependency on the capturing stream(s).\n\n \\param hStream       - Stream to query\n \\param captureStatus - Returns the stream's capture status\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_STREAM_CAPTURE_IMPLICIT\n \\notefnerr\n\n \\sa\n ::cuStreamCreate,\n ::cuStreamBeginCapture,\n ::cuStreamEndCapture"]
    pub fn cuStreamIsCapturing(
        hStream: CUstream,
        captureStatus: *mut CUstreamCaptureStatus,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamGetCaptureInfo_v2(
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
        graph_out: *mut CUgraph,
        dependencies_out: *mut *const CUgraphNode,
        numDependencies_out: *mut usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Update the set of dependencies in a capturing stream (11.3+)\n\n Modifies the dependency set of a capturing stream. The dependency set is the set\n of nodes that the next captured node in the stream will depend on.\n\n Valid flags are ::CU_STREAM_ADD_CAPTURE_DEPENDENCIES and\n ::CU_STREAM_SET_CAPTURE_DEPENDENCIES. These control whether the set passed to\n the API is added to the existing set or replaces it. A flags value of 0 defaults\n to ::CU_STREAM_ADD_CAPTURE_DEPENDENCIES.\n\n Nodes that are removed from the dependency set via this API do not result in\n ::CUDA_ERROR_STREAM_CAPTURE_UNJOINED if they are unreachable from the stream at\n ::cuStreamEndCapture.\n\n Returns ::CUDA_ERROR_ILLEGAL_STATE if the stream is not capturing.\n\n This API is new in CUDA 11.3. Developers requiring compatibility across minor\n versions to CUDA 11.0 should not use this API or provide a fallback.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_ILLEGAL_STATE\n\n \\sa\n ::cuStreamBeginCapture,\n ::cuStreamGetCaptureInfo,"]
    pub fn cuStreamUpdateCaptureDependencies(
        hStream: CUstream,
        dependencies: *mut CUgraphNode,
        numDependencies: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Attach memory to a stream asynchronously\n\n Enqueues an operation in \\p hStream to specify stream association of\n \\p length bytes of memory starting from \\p dptr. This function is a\n stream-ordered operation, meaning that it is dependent on, and will\n only take effect when, previous work in stream has completed. Any\n previous association is automatically replaced.\n\n \\p dptr must point to one of the following types of memories:\n - managed memory declared using the __managed__ keyword or allocated with\n   ::cuMemAllocManaged.\n - a valid host-accessible region of system-allocated pageable memory. This\n   type of memory may only be specified if the device associated with the\n   stream reports a non-zero value for the device attribute\n   ::CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS.\n\n For managed allocations, \\p length must be either zero or the entire\n allocation's size. Both indicate that the entire allocation's stream\n association is being changed. Currently, it is not possible to change stream\n association for a portion of a managed allocation.\n\n For pageable host allocations, \\p length must be non-zero.\n\n The stream association is specified using \\p flags which must be\n one of ::CUmemAttach_flags.\n If the ::CU_MEM_ATTACH_GLOBAL flag is specified, the memory can be accessed\n by any stream on any device.\n If the ::CU_MEM_ATTACH_HOST flag is specified, the program makes a guarantee\n that it won't access the memory on the device from any stream on a device that\n has a zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS.\n If the ::CU_MEM_ATTACH_SINGLE flag is specified and \\p hStream is associated with\n a device that has a zero value for the device attribute ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS,\n the program makes a guarantee that it will only access the memory on the device\n from \\p hStream. It is illegal to attach singly to the NULL stream, because the\n NULL stream is a virtual global stream and not a specific stream. An error will\n be returned in this case.\n\n When memory is associated with a single stream, the Unified Memory system will\n allow CPU access to this memory region so long as all operations in \\p hStream\n have completed, regardless of whether other streams are active. In effect,\n this constrains exclusive ownership of the managed memory region by\n an active GPU to per-stream activity instead of whole-GPU activity.\n\n Accessing memory on the device from streams that are not associated with\n it will produce undefined results. No error checking is performed by the\n Unified Memory system to ensure that kernels launched into other streams\n do not access this region.\n\n It is a program's responsibility to order calls to ::cuStreamAttachMemAsync\n via events, synchronization or other means to ensure legal access to memory\n at all times. Data visibility and coherency will be changed appropriately\n for all kernels which follow a stream-association change.\n\n If \\p hStream is destroyed while data is associated with it, the association is\n removed and the association reverts to the default visibility of the allocation\n as specified at ::cuMemAllocManaged. For __managed__ variables, the default\n association is always ::CU_MEM_ATTACH_GLOBAL. Note that destroying a stream is an\n asynchronous operation, and as a result, the change to default association won't\n happen until all work in the stream has completed.\n\n \\param hStream - Stream in which to enqueue the attach operation\n \\param dptr    - Pointer to memory (must be a pointer to managed memory or\n                  to a valid host-accessible region of system-allocated\n                  pageable memory)\n \\param length  - Length of memory\n \\param flags   - Must be one of ::CUmemAttach_flags\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuStreamCreate,\n ::cuStreamQuery,\n ::cuStreamSynchronize,\n ::cuStreamWaitEvent,\n ::cuStreamDestroy,\n ::cuMemAllocManaged,\n ::cudaStreamAttachMemAsync"]
    pub fn cuStreamAttachMemAsync(
        hStream: CUstream,
        dptr: CUdeviceptr,
        length: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Determine status of a compute stream\n\n Returns ::CUDA_SUCCESS if all operations in the stream specified by\n \\p hStream have completed, or ::CUDA_ERROR_NOT_READY if not.\n\n For the purposes of Unified Memory, a return value of ::CUDA_SUCCESS\n is equivalent to having called ::cuStreamSynchronize().\n\n \\param hStream - Stream to query status of\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_READY\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuStreamCreate,\n ::cuStreamWaitEvent,\n ::cuStreamDestroy,\n ::cuStreamSynchronize,\n ::cuStreamAddCallback,\n ::cudaStreamQuery"]
    pub fn cuStreamQuery(hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Wait until a stream's tasks are completed\n\n Waits until the device has completed all operations in the stream specified\n by \\p hStream. If the context was created with the\n ::CU_CTX_SCHED_BLOCKING_SYNC flag, the CPU thread will block until the\n stream is finished with all of its tasks.\n\n \\param hStream - Stream to wait for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE\n\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuStreamCreate,\n ::cuStreamDestroy,\n ::cuStreamWaitEvent,\n ::cuStreamQuery,\n ::cuStreamAddCallback,\n ::cudaStreamSynchronize"]
    pub fn cuStreamSynchronize(hStream: CUstream) -> CUresult;
}
extern "C" {
    pub fn cuStreamDestroy_v2(hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies attributes from source stream to destination stream.\n\n Copies attributes from source stream \\p src to destination stream \\p dst.\n Both streams must have the same context.\n\n \\param[out] dst Destination stream\n \\param[in] src Source stream\n For list of attributes see ::CUstreamAttrID\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa\n ::CUaccessPolicyWindow"]
    pub fn cuStreamCopyAttributes(dst: CUstream, src: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries stream attribute.\n\n Queries attribute \\p attr from \\p hStream and stores it in corresponding\n member of \\p value_out.\n\n \\param[in] hStream\n \\param[in] attr\n \\param[out] value_out\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa\n ::CUaccessPolicyWindow"]
    pub fn cuStreamGetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value_out: *mut CUstreamAttrValue,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets stream attribute.\n\n Sets attribute \\p attr on \\p hStream from corresponding attribute of\n \\p value. The updated attribute will be applied to subsequent work\n submitted to the stream. It will not affect previously submitted work.\n\n \\param[out] hStream\n \\param[in] attr\n \\param[in] value\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa\n ::CUaccessPolicyWindow"]
    pub fn cuStreamSetAttribute(
        hStream: CUstream,
        attr: CUstreamAttrID,
        value: *const CUstreamAttrValue,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an event\n\n Creates an event *phEvent for the current context with the flags specified via\n \\p Flags. Valid flags include:\n - ::CU_EVENT_DEFAULT: Default event creation flag.\n - ::CU_EVENT_BLOCKING_SYNC: Specifies that the created event should use blocking\n   synchronization.  A CPU thread that uses ::cuEventSynchronize() to wait on\n   an event created with this flag will block until the event has actually\n   been recorded.\n - ::CU_EVENT_DISABLE_TIMING: Specifies that the created event does not need\n   to record timing data.  Events created with this flag specified and\n   the ::CU_EVENT_BLOCKING_SYNC flag not specified will provide the best\n   performance when used with ::cuStreamWaitEvent() and ::cuEventQuery().\n - ::CU_EVENT_INTERPROCESS: Specifies that the created event may be used as an\n   interprocess event by ::cuIpcGetEventHandle(). ::CU_EVENT_INTERPROCESS must\n   be specified along with ::CU_EVENT_DISABLE_TIMING.\n\n \\param phEvent - Returns newly created event\n \\param Flags   - Event creation flags\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\notefnerr\n\n \\sa\n ::cuEventRecord,\n ::cuEventQuery,\n ::cuEventSynchronize,\n ::cuEventDestroy,\n ::cuEventElapsedTime,\n ::cudaEventCreate,\n ::cudaEventCreateWithFlags"]
    pub fn cuEventCreate(phEvent: *mut CUevent, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Records an event\n\n Captures in \\p hEvent the contents of \\p hStream at the time of this call.\n \\p hEvent and \\p hStream must be from the same context.\n Calls such as ::cuEventQuery() or ::cuStreamWaitEvent() will then\n examine or wait for completion of the work that was captured. Uses of\n \\p hStream after this call do not modify \\p hEvent. See note on default\n stream behavior for what is captured in the default case.\n\n ::cuEventRecord() can be called multiple times on the same event and\n will overwrite the previously captured state. Other APIs such as\n ::cuStreamWaitEvent() use the most recently captured state at the time\n of the API call, and are not affected by later calls to\n ::cuEventRecord(). Before the first call to ::cuEventRecord(), an\n event represents an empty set of work, so for example ::cuEventQuery()\n would return ::CUDA_SUCCESS.\n\n \\param hEvent  - Event to record\n \\param hStream - Stream to record event for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuEventCreate,\n ::cuEventQuery,\n ::cuEventSynchronize,\n ::cuStreamWaitEvent,\n ::cuEventDestroy,\n ::cuEventElapsedTime,\n ::cudaEventRecord,\n ::cuEventRecordWithFlags"]
    pub fn cuEventRecord(hEvent: CUevent, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Records an event\n\n Captures in \\p hEvent the contents of \\p hStream at the time of this call.\n \\p hEvent and \\p hStream must be from the same context.\n Calls such as ::cuEventQuery() or ::cuStreamWaitEvent() will then\n examine or wait for completion of the work that was captured. Uses of\n \\p hStream after this call do not modify \\p hEvent. See note on default\n stream behavior for what is captured in the default case.\n\n ::cuEventRecordWithFlags() can be called multiple times on the same event and\n will overwrite the previously captured state. Other APIs such as\n ::cuStreamWaitEvent() use the most recently captured state at the time\n of the API call, and are not affected by later calls to\n ::cuEventRecordWithFlags(). Before the first call to ::cuEventRecordWithFlags(), an\n event represents an empty set of work, so for example ::cuEventQuery()\n would return ::CUDA_SUCCESS.\n\n flags include:\n - ::CU_EVENT_RECORD_DEFAULT: Default event creation flag.\n - ::CU_EVENT_RECORD_EXTERNAL: Event is captured in the graph as an external\n   event node when performing stream capture. This flag is invalid outside\n   of stream capture.\n\n \\param hEvent  - Event to record\n \\param hStream - Stream to record event for\n \\param flags   - See ::CUevent_capture_flags\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuEventCreate,\n ::cuEventQuery,\n ::cuEventSynchronize,\n ::cuStreamWaitEvent,\n ::cuEventDestroy,\n ::cuEventElapsedTime,\n ::cuEventRecord,\n ::cudaEventRecord"]
    pub fn cuEventRecordWithFlags(
        hEvent: CUevent,
        hStream: CUstream,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries an event's status\n\n Queries the status of all work currently captured by \\p hEvent. See\n ::cuEventRecord() for details on what is captured by an event.\n\n Returns ::CUDA_SUCCESS if all captured work has been completed, or\n ::CUDA_ERROR_NOT_READY if any captured work is incomplete.\n\n For the purposes of Unified Memory, a return value of ::CUDA_SUCCESS\n is equivalent to having called ::cuEventSynchronize().\n\n \\param hEvent - Event to query\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_READY\n \\notefnerr\n\n \\sa ::cuEventCreate,\n ::cuEventRecord,\n ::cuEventSynchronize,\n ::cuEventDestroy,\n ::cuEventElapsedTime,\n ::cudaEventQuery"]
    pub fn cuEventQuery(hEvent: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Waits for an event to complete\n\n Waits until the completion of all work currently captured in \\p hEvent.\n See ::cuEventRecord() for details on what is captured by an event.\n\n Waiting for an event that was created with the ::CU_EVENT_BLOCKING_SYNC\n flag will cause the calling CPU thread to block until the event has\n been completed by the device.  If the ::CU_EVENT_BLOCKING_SYNC flag has\n not been set, then the CPU thread will busy-wait until the event has\n been completed by the device.\n\n \\param hEvent - Event to wait for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa ::cuEventCreate,\n ::cuEventRecord,\n ::cuEventQuery,\n ::cuEventDestroy,\n ::cuEventElapsedTime,\n ::cudaEventSynchronize"]
    pub fn cuEventSynchronize(hEvent: CUevent) -> CUresult;
}
extern "C" {
    pub fn cuEventDestroy_v2(hEvent: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Computes the elapsed time between two events\n\n Computes the elapsed time between two events (in milliseconds with a\n resolution of around 0.5 microseconds).\n\n If either event was last recorded in a non-NULL stream, the resulting time\n may be greater than expected (even if both used the same stream handle). This\n happens because the ::cuEventRecord() operation takes place asynchronously\n and there is no guarantee that the measured latency is actually just between\n the two events. Any number of other different stream operations could execute\n in between the two measured events, thus altering the timing in a significant\n way.\n\n If ::cuEventRecord() has not been called on either event then\n ::CUDA_ERROR_INVALID_HANDLE is returned. If ::cuEventRecord() has been called\n on both events but one or both of them has not yet been completed (that is,\n ::cuEventQuery() would return ::CUDA_ERROR_NOT_READY on at least one of the\n events), ::CUDA_ERROR_NOT_READY is returned. If either event was created with\n the ::CU_EVENT_DISABLE_TIMING flag, then this function will return\n ::CUDA_ERROR_INVALID_HANDLE.\n\n \\param pMilliseconds - Time between \\p hStart and \\p hEnd in ms\n \\param hStart        - Starting event\n \\param hEnd          - Ending event\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_READY,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa ::cuEventCreate,\n ::cuEventRecord,\n ::cuEventQuery,\n ::cuEventSynchronize,\n ::cuEventDestroy,\n ::cudaEventElapsedTime"]
    pub fn cuEventElapsedTime(pMilliseconds: *mut f32, hStart: CUevent, hEnd: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Imports an external memory object\n\n Imports an externally allocated memory object and returns\n a handle to that in \\p extMem_out.\n\n The properties of the handle being imported must be described in\n \\p memHandleDesc. The ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC structure\n is defined as follows:\n\n \\code\ntypedef struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {\nCUexternalMemoryHandleType type;\nunion {\nint fd;\nstruct {\nvoid *handle;\nconst void *name;\n} win32;\nconst void *nvSciBufObject;\n} handle;\nunsigned long long size;\nunsigned int flags;\n} CUDA_EXTERNAL_MEMORY_HANDLE_DESC;\n \\endcode\n\n where ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type specifies the type\n of handle being imported. ::CUexternalMemoryHandleType is\n defined as:\n\n \\code\ntypedef enum CUexternalMemoryHandleType_enum {\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD          = 1,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32       = 2,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT   = 3,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP         = 4,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE     = 5,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE     = 6,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7,\nCU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF           = 8\n} CUexternalMemoryHandleType;\n \\endcode\n\n If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD, then\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::fd must be a valid\n file descriptor referencing a memory object. Ownership of\n the file descriptor is transferred to the CUDA driver when the\n handle is imported successfully. Performing any operations on the\n file descriptor after it is imported results in undefined behavior.\n\n If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32, then exactly one\n of ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be\n NULL. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n references a memory object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a memory object.\n\n If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT, then\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must\n be non-NULL and\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name\n must be NULL. The handle specified must be a globally shared KMT\n handle. This handle does not hold a reference to the underlying\n object, and thus will be invalid when all references to the\n memory object are destroyed.\n\n If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP, then exactly one\n of ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be\n NULL. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device::CreateSharedHandle when referring to a\n ID3D12Heap object. This handle holds a reference to the underlying\n object. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D12Heap object.\n\n If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE, then exactly one\n of ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be\n NULL. If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device::CreateSharedHandle when referring to a\n ID3D12Resource object. This handle holds a reference to the\n underlying object. If\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D12Resource object.\n\n If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE, then\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must\n represent a valid shared NT handle that is returned by\n IDXGIResource1::CreateSharedHandle when referring to a\n ID3D11Resource object. If\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name\n is not NULL, then it must point to a NULL-terminated array of\n UTF-16 characters that refers to a ID3D11Resource object.\n\n If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT, then\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must\n represent a valid shared KMT handle that is returned by\n IDXGIResource::GetSharedHandle when referring to a\n ID3D11Resource object and\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name\n must be NULL.\n\n If ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type is\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF, then\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::nvSciBufObject must be non-NULL\n and reference a valid NvSciBuf object.\n If the NvSciBuf object imported into CUDA is also mapped by other drivers, then the\n application must use ::cuWaitExternalSemaphoresAsync or ::cuSignalExternalSemaphoresAsync\n as appropriate barriers to maintain coherence between CUDA and the other drivers.\n See ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC and ::CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC\n for memory synchronization.\n\n\n The size of the memory object must be specified in\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::size.\n\n Specifying the flag ::CUDA_EXTERNAL_MEMORY_DEDICATED in\n ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::flags indicates that the\n resource is a dedicated resource. The definition of what a\n dedicated resource is outside the scope of this extension.\n This flag must be set if ::CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type\n is one of the following:\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT\n\n \\param extMem_out    - Returned handle to an external memory object\n \\param memHandleDesc - Memory import handle descriptor\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OPERATING_SYSTEM\n \\notefnerr\n\n \\note If the Vulkan memory imported into CUDA is mapped on the CPU then the\n application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges\n as well as appropriate Vulkan pipeline barriers to maintain coherence between\n CPU and GPU. For more information on these APIs, please refer to \"Synchronization\n and Cache Control\" chapter from Vulkan specification.\n\n \\sa ::cuDestroyExternalMemory,\n ::cuExternalMemoryGetMappedBuffer,\n ::cuExternalMemoryGetMappedMipmappedArray"]
    pub fn cuImportExternalMemory(
        extMem_out: *mut CUexternalMemory,
        memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Maps a buffer onto an imported memory object\n\n Maps a buffer onto an imported memory object and returns a device\n pointer in \\p devPtr.\n\n The properties of the buffer being mapped must be described in\n \\p bufferDesc. The ::CUDA_EXTERNAL_MEMORY_BUFFER_DESC structure is\n defined as follows:\n\n \\code\ntypedef struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {\nunsigned long long offset;\nunsigned long long size;\nunsigned int flags;\n} CUDA_EXTERNAL_MEMORY_BUFFER_DESC;\n \\endcode\n\n where ::CUDA_EXTERNAL_MEMORY_BUFFER_DESC::offset is the offset in\n the memory object where the buffer's base address is.\n ::CUDA_EXTERNAL_MEMORY_BUFFER_DESC::size is the size of the buffer.\n ::CUDA_EXTERNAL_MEMORY_BUFFER_DESC::flags must be zero.\n\n The offset and size have to be suitably aligned to match the\n requirements of the external API. Mapping two buffers whose ranges\n overlap may or may not result in the same virtual address being\n returned for the overlapped portion. In such cases, the application\n must ensure that all accesses to that region from the GPU are\n volatile. Otherwise writes made via one address are not guaranteed\n to be visible via the other address, even if they're issued by the\n same thread. It is recommended that applications map the combined\n range instead of mapping separate buffers and then apply the\n appropriate offsets to the returned pointer to derive the\n individual buffers.\n\n The returned pointer \\p devPtr must be freed using ::cuMemFree.\n\n \\param devPtr     - Returned device pointer to buffer\n \\param extMem     - Handle to external memory object\n \\param bufferDesc - Buffer descriptor\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa ::cuImportExternalMemory,\n ::cuDestroyExternalMemory,\n ::cuExternalMemoryGetMappedMipmappedArray"]
    pub fn cuExternalMemoryGetMappedBuffer(
        devPtr: *mut CUdeviceptr,
        extMem: CUexternalMemory,
        bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Maps a CUDA mipmapped array onto an external memory object\n\n Maps a CUDA mipmapped array onto an external object and returns a\n handle to it in \\p mipmap.\n\n The properties of the CUDA mipmapped array being mapped must be\n described in \\p mipmapDesc. The structure\n ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC is defined as follows:\n\n \\code\ntypedef struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {\nunsigned long long offset;\nCUDA_ARRAY3D_DESCRIPTOR arrayDesc;\nunsigned int numLevels;\n} CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC;\n \\endcode\n\n where ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::offset is the\n offset in the memory object where the base level of the mipmap\n chain is.\n ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::arrayDesc describes\n the format, dimensions and type of the base level of the mipmap\n chain. For further details on these parameters, please refer to the\n documentation for ::cuMipmappedArrayCreate. Note that if the mipmapped\n array is bound as a color target in the graphics API, then the flag\n ::CUDA_ARRAY3D_COLOR_ATTACHMENT must be specified in\n ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::arrayDesc::Flags.\n ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::numLevels specifies\n the total number of levels in the mipmap chain.\n\n If \\p extMem was imported from a handle of type ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF, then\n ::CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::numLevels must be equal to 1.\n\n The returned CUDA mipmapped array must be freed using ::cuMipmappedArrayDestroy.\n\n \\param mipmap     - Returned CUDA mipmapped array\n \\param extMem     - Handle to external memory object\n \\param mipmapDesc - CUDA array descriptor\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa ::cuImportExternalMemory,\n ::cuDestroyExternalMemory,\n ::cuExternalMemoryGetMappedBuffer"]
    pub fn cuExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut CUmipmappedArray,
        extMem: CUexternalMemory,
        mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys an external memory object.\n\n Destroys the specified external memory object. Any existing buffers\n and CUDA mipmapped arrays mapped onto this object must no longer be\n used and must be explicitly freed using ::cuMemFree and\n ::cuMipmappedArrayDestroy respectively.\n\n \\param extMem - External memory object to be destroyed\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa ::cuImportExternalMemory,\n ::cuExternalMemoryGetMappedBuffer,\n ::cuExternalMemoryGetMappedMipmappedArray"]
    pub fn cuDestroyExternalMemory(extMem: CUexternalMemory) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Imports an external semaphore\n\n Imports an externally allocated synchronization object and returns\n a handle to that in \\p extSem_out.\n\n The properties of the handle being imported must be described in\n \\p semHandleDesc. The ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC is\n defined as follows:\n\n \\code\ntypedef struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {\nCUexternalSemaphoreHandleType type;\nunion {\nint fd;\nstruct {\nvoid *handle;\nconst void *name;\n} win32;\nconst void* NvSciSyncObj;\n} handle;\nunsigned int flags;\n} CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC;\n \\endcode\n\n where ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type specifies the type of\n handle being imported. ::CUexternalSemaphoreHandleType is defined\n as:\n\n \\code\ntypedef enum CUexternalSemaphoreHandleType_enum {\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD                = 1,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32             = 2,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT         = 3,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE              = 4,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE              = 5,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC                = 6,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX        = 7,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT    = 8,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD    = 9,\nCU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10\n} CUexternalSemaphoreHandleType;\n \\endcode\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD, then\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::fd must be a valid\n file descriptor referencing a synchronization object. Ownership of\n the file descriptor is transferred to the CUDA driver when the\n handle is imported successfully. Performing any operations on the\n file descriptor after it is imported results in undefined behavior.\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32, then exactly one\n of ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be\n NULL. If\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n references a synchronization object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name\n is not NULL, then it must name a valid synchronization object.\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT, then\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle must\n be non-NULL and\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name\n must be NULL. The handle specified must be a globally shared KMT\n handle. This handle does not hold a reference to the underlying\n object, and thus will be invalid when all references to the\n synchronization object are destroyed.\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE, then exactly one\n of ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be\n NULL. If\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n is returned by ID3D12Device::CreateSharedHandle when referring to a\n ID3D12Fence object. This handle holds a reference to the underlying\n object. If\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name\n is not NULL, then it must name a valid synchronization object that\n refers to a valid ID3D12Fence object.\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE, then\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle\n represents a valid shared NT handle that is returned by\n ID3D11Fence::CreateSharedHandle. If\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name\n is not NULL, then it must name a valid synchronization object that\n refers to a valid ID3D11Fence object.\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, then\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::nvSciSyncObj\n represents a valid NvSciSyncObj.\n\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX, then\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle\n represents a valid shared NT handle that\n is returned by IDXGIResource1::CreateSharedHandle when referring to\n a IDXGIKeyedMutex object. If\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name\n is not NULL, then it must name a valid synchronization object that\n refers to a valid IDXGIKeyedMutex object.\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT, then\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle\n represents a valid shared KMT handle that\n is returned by IDXGIResource::GetSharedHandle when referring to\n a IDXGIKeyedMutex object and\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must be NULL.\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD, then\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::fd must be a valid\n file descriptor referencing a synchronization object. Ownership of\n the file descriptor is transferred to the CUDA driver when the\n handle is imported successfully. Performing any operations on the\n file descriptor after it is imported results in undefined behavior.\n\n If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type is\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32, then exactly one\n of ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be\n NULL. If\n ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle\n is not NULL, then it must represent a valid shared NT handle that\n references a synchronization object. Ownership of this handle is\n not transferred to CUDA after the import operation, so the\n application must release the handle using the appropriate system\n call. If ::CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name\n is not NULL, then it must name a valid synchronization object.\n\n \\param extSem_out    - Returned handle to an external semaphore\n \\param semHandleDesc - Semaphore import handle descriptor\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OPERATING_SYSTEM\n \\notefnerr\n\n \\sa ::cuDestroyExternalSemaphore,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync"]
    pub fn cuImportExternalSemaphore(
        extSem_out: *mut CUexternalSemaphore,
        semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Signals a set of external semaphore objects\n\n Enqueues a signal operation on a set of externally allocated\n semaphore object in the specified stream. The operations will be\n executed when all prior operations in the stream complete.\n\n The exact semantics of signaling a semaphore depends on the type of\n the object.\n\n If the semaphore object is any one of the following types:\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT\n then signaling the semaphore will set it to the signaled state.\n\n If the semaphore object is any one of the following types:\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32\n then the semaphore will be set to the value specified in\n ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::fence::value.\n\n If the semaphore object is of the type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC\n this API sets ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence\n to a value that can be used by subsequent waiters of the same NvSciSync object\n to order operations with those currently submitted in \\p stream. Such an update\n will overwrite previous contents of\n ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence. By default,\n signaling such an external semaphore object causes appropriate memory synchronization\n operations to be performed over all external memory objects that are imported as\n ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF. This ensures that any subsequent accesses\n made by other importers of the same set of NvSciBuf memory object(s) are coherent.\n These operations can be skipped by specifying the flag\n ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC, which can be used as a\n performance optimization when data coherency is not required. But specifying this\n flag in scenarios where data coherency is required results in undefined behavior.\n Also, for semaphore object of the type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC,\n if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in\n ::cuDeviceGetNvSciSyncAttributes to CUDA_NVSCISYNC_ATTR_SIGNAL, this API will return\n CUDA_ERROR_NOT_SUPPORTED.\n NvSciSyncFence associated with semaphore object of the type\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC can be deterministic. For this the\n NvSciSyncAttrList used to create the semaphore object must have value of\n NvSciSyncAttrKey_RequireDeterministicFences key set to true. Deterministic fences\n allow users to enqueue a wait over the semaphore object even before corresponding\n signal is enqueued. For such a semaphore object, CUDA guarantees that each signal\n operation will increment the fence value by '1'. Users are expected to track count\n of signals enqueued on the semaphore object and insert waits accordingly. When such\n a semaphore object is signaled from multiple streams, due to concurrent stream\n execution, it is possible that the order in which the semaphore gets signaled is\n indeterministic. This could lead to waiters of the semaphore getting unblocked\n incorrectly. Users are expected to handle such situations, either by not using the\n same semaphore object with deterministic fence support enabled in different streams\n or by adding explicit dependency amongst such streams so that the semaphore is\n signaled in order.\n\n If the semaphore object is any one of the following types:\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT\n then the keyed mutex will be released with the key specified in\n ::CUDA_EXTERNAL_SEMAPHORE_PARAMS::params::keyedmutex::key.\n\n \\param extSemArray - Set of external semaphores to be signaled\n \\param paramsArray - Array of semaphore parameters\n \\param numExtSems  - Number of semaphores to signal\n \\param stream      - Stream to enqueue the signal operations in\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\notefnerr\n\n \\sa ::cuImportExternalSemaphore,\n ::cuDestroyExternalSemaphore,\n ::cuWaitExternalSemaphoresAsync"]
    pub fn cuSignalExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Waits on a set of external semaphore objects\n\n Enqueues a wait operation on a set of externally allocated\n semaphore object in the specified stream. The operations will be\n executed when all prior operations in the stream complete.\n\n The exact semantics of waiting on a semaphore depends on the type\n of the object.\n\n If the semaphore object is any one of the following types:\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT\n then waiting on the semaphore will wait until the semaphore reaches\n the signaled state. The semaphore will then be reset to the\n unsignaled state. Therefore for every signal operation, there can\n only be one wait operation.\n\n If the semaphore object is any one of the following types:\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32\n then waiting on the semaphore will wait until the value of the\n semaphore is greater than or equal to\n ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::fence::value.\n\n If the semaphore object is of the type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC\n then, waiting on the semaphore will wait until the\n ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence is signaled by the\n signaler of the NvSciSyncObj that was associated with this semaphore object.\n By default, waiting on such an external semaphore object causes appropriate\n memory synchronization operations to be performed over all external memory objects\n that are imported as ::CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF. This ensures that\n any subsequent accesses made by other importers of the same set of NvSciBuf memory\n object(s) are coherent. These operations can be skipped by specifying the flag\n ::CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC, which can be used as a\n performance optimization when data coherency is not required. But specifying this\n flag in scenarios where data coherency is required results in undefined behavior.\n Also, for semaphore object of the type ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC,\n if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in\n ::cuDeviceGetNvSciSyncAttributes to CUDA_NVSCISYNC_ATTR_WAIT, this API will return\n CUDA_ERROR_NOT_SUPPORTED.\n\n If the semaphore object is any one of the following types:\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX,\n ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT\n then the keyed mutex will be acquired when it is released with the key\n specified in ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::keyedmutex::key\n or until the timeout specified by\n ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::keyedmutex::timeoutMs\n has lapsed. The timeout interval can either be a finite value\n specified in milliseconds or an infinite value. In case an infinite\n value is specified the timeout never elapses. The windows INFINITE\n macro must be used to specify infinite timeout.\n\n \\param extSemArray - External semaphores to be waited on\n \\param paramsArray - Array of semaphore parameters\n \\param numExtSems  - Number of semaphores to wait on\n \\param stream      - Stream to enqueue the wait operations in\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_TIMEOUT\n \\notefnerr\n\n \\sa ::cuImportExternalSemaphore,\n ::cuDestroyExternalSemaphore,\n ::cuSignalExternalSemaphoresAsync"]
    pub fn cuWaitExternalSemaphoresAsync(
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
        numExtSems: ::std::os::raw::c_uint,
        stream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys an external semaphore\n\n Destroys an external semaphore object and releases any references\n to the underlying resource. Any outstanding signals or waits must\n have completed before the semaphore is destroyed.\n\n \\param extSem - External semaphore to be destroyed\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa ::cuImportExternalSemaphore,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync"]
    pub fn cuDestroyExternalSemaphore(extSem: CUexternalSemaphore) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitValue32_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWaitValue64_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWriteValue32_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamWriteValue64_v2(
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuStreamBatchMemOp_v2(
        stream: CUstream,
        count: ::std::os::raw::c_uint,
        paramArray: *mut CUstreamBatchMemOpParams,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns information about a function\n\n Returns in \\p *pi the integer value of the attribute \\p attrib on the kernel\n given by \\p hfunc. The supported attributes are:\n - ::CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK: The maximum number of threads\n   per block, beyond which a launch of the function would fail. This number\n   depends on both the function and the device on which the function is\n   currently loaded.\n - ::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES: The size in bytes of\n   statically-allocated shared memory per block required by this function.\n   This does not include dynamically-allocated shared memory requested by\n   the user at runtime.\n - ::CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES: The size in bytes of user-allocated\n   constant memory required by this function.\n - ::CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES: The size in bytes of local memory\n   used by each thread of this function.\n - ::CU_FUNC_ATTRIBUTE_NUM_REGS: The number of registers used by each thread\n   of this function.\n - ::CU_FUNC_ATTRIBUTE_PTX_VERSION: The PTX virtual architecture version for\n   which the function was compiled. This value is the major PTX version * 10\n   + the minor PTX version, so a PTX version 1.3 function would return the\n   value 13. Note that this may return the undefined value of 0 for cubins\n   compiled prior to CUDA 3.0.\n - ::CU_FUNC_ATTRIBUTE_BINARY_VERSION: The binary architecture version for\n   which the function was compiled. This value is the major binary\n   version * 10 + the minor binary version, so a binary version 1.3 function\n   would return the value 13. Note that this will return a value of 10 for\n   legacy cubins that do not have a properly-encoded binary architecture\n   version.\n - ::CU_FUNC_CACHE_MODE_CA: The attribute to indicate whether the function has\n   been compiled with user specified option \"-Xptxas --dlcm=ca\" set .\n - ::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES: The maximum size in bytes of\n   dynamically-allocated shared memory.\n - ::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: Preferred shared memory-L1\n   cache split ratio in percent of total shared memory.\n - ::CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET: If this attribute is set, the\n   kernel must launch with a valid cluster size specified.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH: The required cluster width in\n   blocks.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT: The required cluster height in\n   blocks.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH: The required cluster depth in\n   blocks.\n - ::CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED: Indicates whether\n   the function can be launched with non-portable cluster size. 1 is allowed,\n   0 is disallowed. A non-portable cluster size may only function on the\n   specific SKUs the program is tested on. The launch might fail if the\n   program is run on a different hardware platform. CUDA API provides\n   cudaOccupancyMaxActiveClusters to assist with checking whether the desired\n   size can be launched on the current device. A portable cluster size is\n   guaranteed to be functional on all compute capabilities higher than the\n   target compute capability. The portable cluster size for sm_90 is 8 blocks\n   per cluster. This value may increase for future compute capabilities. The\n   specific hardware unit may support higher cluster sizes thats not\n   guaranteed to be portable.\n - ::CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: The block\n   scheduling policy of a function. The value type is CUclusterSchedulingPolicy.\n\n \\param pi     - Returned attribute value\n \\param attrib - Attribute requested\n \\param hfunc  - Function to query attribute of\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuCtxGetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuFuncSetCacheConfig,\n ::cuLaunchKernel,\n ::cudaFuncGetAttributes,\n ::cudaFuncSetAttribute,\n ::cuKernelGetAttribute"]
    pub fn cuFuncGetAttribute(
        pi: *mut ::std::os::raw::c_int,
        attrib: CUfunction_attribute,
        hfunc: CUfunction,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets information about a function\n\n This call sets the value of a specified attribute \\p attrib on the kernel given\n by \\p hfunc to an integer value specified by \\p val\n This function returns CUDA_SUCCESS if the new value of the attribute could be\n successfully set. If the set fails, this call will return an error.\n Not all attributes can have values set. Attempting to set a value on a read-only\n attribute will result in an error (CUDA_ERROR_INVALID_VALUE)\n\n Supported attributes for the cuFuncSetAttribute call are:\n - ::CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES: This maximum size in bytes of\n   dynamically-allocated shared memory. The value should contain the requested\n   maximum size of dynamically-allocated shared memory. The sum of this value and\n   the function attribute ::CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES cannot exceed the\n   device attribute ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN.\n   The maximal size of requestable dynamic shared memory may differ by GPU\n   architecture.\n - ::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: On devices where the L1\n   cache and shared memory use the same hardware resources, this sets the shared memory\n   carveout preference, in percent of the total shared memory.\n   See ::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR\n   This is only a hint, and the driver can choose a different ratio if required to execute the function.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH: The required cluster width in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT: The required cluster height in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - ::CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH: The required cluster depth in\n   blocks. The width, height, and depth values must either all be 0 or all be\n   positive. The validity of the cluster dimensions is checked at launch time.\n   If the value is set during compile time, it cannot be set at runtime.\n   Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.\n - ::CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: The block\n   scheduling policy of a function. The value type is CUclusterSchedulingPolicy.\n\n \\param hfunc  - Function to query attribute of\n \\param attrib - Attribute requested\n \\param value   - The value to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuCtxGetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuFuncSetCacheConfig,\n ::cuLaunchKernel,\n ::cudaFuncGetAttributes,\n ::cudaFuncSetAttribute,\n ::cuKernelSetAttribute"]
    pub fn cuFuncSetAttribute(
        hfunc: CUfunction,
        attrib: CUfunction_attribute,
        value: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the preferred cache configuration for a device function\n\n On devices where the L1 cache and shared memory use the same hardware\n resources, this sets through \\p config the preferred cache configuration for\n the device function \\p hfunc. This is only a preference. The driver will use\n the requested configuration if possible, but it is free to choose a different\n configuration if required to execute \\p hfunc.  Any context-wide preference\n set via ::cuCtxSetCacheConfig() will be overridden by this per-function\n setting unless the per-function setting is ::CU_FUNC_CACHE_PREFER_NONE. In\n that case, the current context-wide setting will be used.\n\n This setting does nothing on devices where the size of the L1 cache and\n shared memory are fixed.\n\n Launching a kernel with a different preference than the most recent\n preference setting may insert a device-side synchronization point.\n\n\n The supported cache configurations are:\n - ::CU_FUNC_CACHE_PREFER_NONE: no preference for shared memory or L1 (default)\n - ::CU_FUNC_CACHE_PREFER_SHARED: prefer larger shared memory and smaller L1 cache\n - ::CU_FUNC_CACHE_PREFER_L1: prefer larger L1 cache and smaller shared memory\n - ::CU_FUNC_CACHE_PREFER_EQUAL: prefer equal sized L1 cache and shared memory\n\n \\param hfunc  - Kernel to configure cache for\n \\param config - Requested cache configuration\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT\n \\notefnerr\n\n \\sa ::cuCtxGetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuFuncGetAttribute,\n ::cuLaunchKernel,\n ::cudaFuncSetCacheConfig,\n ::cuKernelSetCacheConfig"]
    pub fn cuFuncSetCacheConfig(hfunc: CUfunction, config: CUfunc_cache) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the shared memory configuration for a device function.\n\n On devices with configurable shared memory banks, this function will\n force all subsequent launches of the specified device function to have\n the given shared memory bank size configuration. On any given launch of the\n function, the shared memory configuration of the device will be temporarily\n changed if needed to suit the function's preferred configuration. Changes in\n shared memory configuration between subsequent launches of functions,\n may introduce a device side synchronization point.\n\n Any per-function setting of shared memory bank size set via\n ::cuFuncSetSharedMemConfig will override the context wide setting set with\n ::cuCtxSetSharedMemConfig.\n\n Changing the shared memory bank size will not increase shared memory usage\n or affect occupancy of kernels, but may have major effects on performance.\n Larger bank sizes will allow for greater potential bandwidth to shared memory,\n but will change what kinds of accesses to shared memory will result in bank\n conflicts.\n\n This function will do nothing on devices with fixed shared memory bank size.\n\n The supported bank configurations are:\n - ::CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE: use the context's shared memory\n   configuration when launching this function.\n - ::CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE: set shared memory bank width to\n   be natively four bytes when launching this function.\n - ::CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE: set shared memory bank width to\n   be natively eight bytes when launching this function.\n\n \\param hfunc  - kernel to be given a shared memory config\n \\param config - requested shared memory configuration\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT\n \\notefnerr\n\n \\sa ::cuCtxGetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuCtxGetSharedMemConfig,\n ::cuCtxSetSharedMemConfig,\n ::cuFuncGetAttribute,\n ::cuLaunchKernel,\n ::cudaFuncSetSharedMemConfig"]
    pub fn cuFuncSetSharedMemConfig(hfunc: CUfunction, config: CUsharedconfig) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a module handle\n\n Returns in \\p *hmod the handle of the module that function \\p hfunc\n is located in. The lifetime of the module corresponds to the lifetime of\n the context it was loaded in or until the module is explicitly unloaded.\n\n The CUDA runtime manages its own modules loaded into the primary context.\n If the handle returned by this API refers to a module loaded by the CUDA runtime,\n calling ::cuModuleUnload() on that module will result in undefined behavior.\n\n \\param hmod - Returned module handle\n \\param hfunc   - Function to retrieve module for\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_NOT_FOUND\n \\notefnerr\n"]
    pub fn cuFuncGetModule(hmod: *mut CUmodule, hfunc: CUfunction) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function ::CUfunction or a CUDA kernel ::CUkernel\n\n Invokes the function ::CUfunction or the kernel ::CUkernel \\p f\n on a \\p gridDimX x \\p gridDimY x \\p gridDimZ grid of blocks.\n Each block contains \\p blockDimX x \\p blockDimY x\n \\p blockDimZ threads.\n\n \\p sharedMemBytes sets the amount of dynamic shared memory that will be\n available to each thread block.\n\n Kernel parameters to \\p f can be specified in one of two ways:\n\n 1) Kernel parameters can be specified via \\p kernelParams.  If \\p f\n has N parameters, then \\p kernelParams needs to be an array of N\n pointers.  Each of \\p kernelParams[0] through \\p kernelParams[N-1]\n must point to a region of memory from which the actual kernel\n parameter will be copied.  The number of kernel parameters and their\n offsets and sizes do not need to be specified as that information is\n retrieved directly from the kernel's image.\n\n 2) Kernel parameters can also be packaged by the application into\n a single buffer that is passed in via the \\p extra parameter.\n This places the burden on the application of knowing each kernel\n parameter's size and alignment/padding within the buffer.  Here is\n an example of using the \\p extra parameter in this manner:\n \\code\nsize_t argBufferSize;\nchar argBuffer[256];\n\n// populate argBuffer and argBufferSize\n\nvoid *config[] = {\nCU_LAUNCH_PARAM_BUFFER_POINTER, argBuffer,\nCU_LAUNCH_PARAM_BUFFER_SIZE,    &argBufferSize,\nCU_LAUNCH_PARAM_END\n};\nstatus = cuLaunchKernel(f, gx, gy, gz, bx, by, bz, sh, s, NULL, config);\n \\endcode\n\n The \\p extra parameter exists to allow ::cuLaunchKernel to take\n additional less commonly used arguments.  \\p extra specifies a list of\n names of extra settings and their corresponding values.  Each extra\n setting name is immediately followed by the corresponding value.  The\n list must be terminated with either NULL or ::CU_LAUNCH_PARAM_END.\n\n - ::CU_LAUNCH_PARAM_END, which indicates the end of the \\p extra\n   array;\n - ::CU_LAUNCH_PARAM_BUFFER_POINTER, which specifies that the next\n   value in \\p extra will be a pointer to a buffer containing all\n   the kernel parameters for launching kernel \\p f;\n - ::CU_LAUNCH_PARAM_BUFFER_SIZE, which specifies that the next\n   value in \\p extra will be a pointer to a size_t containing the\n   size of the buffer specified with ::CU_LAUNCH_PARAM_BUFFER_POINTER;\n\n The error ::CUDA_ERROR_INVALID_VALUE will be returned if kernel\n parameters are specified with both \\p kernelParams and \\p extra\n (i.e. both \\p kernelParams and \\p extra are non-NULL).\n\n Calling ::cuLaunchKernel() invalidates the persistent function state\n set through the following deprecated APIs:\n  ::cuFuncSetBlockShape(),\n  ::cuFuncSetSharedSize(),\n  ::cuParamSetSize(),\n  ::cuParamSeti(),\n  ::cuParamSetf(),\n  ::cuParamSetv().\n\n Note that to use ::cuLaunchKernel(), the kernel \\p f must either have\n been compiled with toolchain version 3.2 or later so that it will\n contain kernel parameter information, or have no kernel parameters.\n If either of these conditions is not met, then ::cuLaunchKernel() will\n return ::CUDA_ERROR_INVALID_IMAGE.\n\n Note that the API can also be used to launch context-less kernel ::CUkernel\n by querying the handle using ::cuLibraryGetKernel() and then passing it\n to the API by casting to ::CUfunction. Here, the context to launch\n the kernel on will either be taken from the specified stream \\p hStream\n or the current context in case of NULL stream.\n\n \\param f              - Function ::CUfunction or Kernel ::CUkernel to launch\n \\param gridDimX       - Width of grid in blocks\n \\param gridDimY       - Height of grid in blocks\n \\param gridDimZ       - Depth of grid in blocks\n \\param blockDimX      - X dimension of each thread block\n \\param blockDimY      - Y dimension of each thread block\n \\param blockDimZ      - Z dimension of each thread block\n \\param sharedMemBytes - Dynamic shared-memory size per thread block in bytes\n \\param hStream        - Stream identifier\n \\param kernelParams   - Array of pointers to kernel parameters\n \\param extra          - Extra options\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_IMAGE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_LAUNCH_FAILED,\n ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,\n ::CUDA_ERROR_LAUNCH_TIMEOUT,\n ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_NOT_FOUND\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuCtxGetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuFuncSetCacheConfig,\n ::cuFuncGetAttribute,\n ::cudaLaunchKernel,\n ::cuLibraryGetKernel,\n ::cuKernelSetCacheConfig,\n ::cuKernelGetAttribute,\n ::cuKernelSetAttribute"]
    pub fn cuLaunchKernel(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function ::CUfunction or a CUDA kernel ::CUkernel with launch-time configuration\n\n Invokes the function ::CUfunction or the kernel ::CUkernel \\p f with the specified launch-time configuration\n \\p config.\n\n The ::CUlaunchConfig structure is defined as:\n \\code\ntypedef struct CUlaunchConfig_st {\nunsigned int gridDimX;\nunsigned int gridDimY;\nunsigned int gridDimZ;\nunsigned int blockDimX;\nunsigned int blockDimY;\nunsigned int blockDimZ;\nunsigned int sharedMemBytes;\nCUstream hStream;\nCUlaunchAttribute *attrs;\nunsigned int numAttrs;\n} CUlaunchConfig;\n \\endcode\n where:\n - ::CUlaunchConfig::gridDimX is the width of the grid in blocks.\n - ::CUlaunchConfig::gridDimY is the height of the grid in blocks.\n - ::CUlaunchConfig::gridDimZ is the depth of the grid in blocks.\n - ::CUlaunchConfig::blockDimX is the X dimension of each thread block.\n - ::CUlaunchConfig::blockDimX is the Y dimension of each thread block.\n - ::CUlaunchConfig::blockDimZ is the Z dimension of each thread block.\n - ::CUlaunchConfig::sharedMemBytes is the dynamic shared-memory size per\n   thread block in bytes.\n - ::CUlaunchConfig::hStream is the handle to the stream to perform the launch\n   in. The CUDA context associated with this stream must match that associated\n   with function f.\n - ::CUlaunchConfig::attrs is an array of ::CUlaunchConfig::numAttrs\n   continguous ::CUlaunchAttribute elements. The value of this pointer is not\n   considered if ::CUlaunchConfig::numAttrs is zero. However, in that case, it\n   is recommended to set the pointer to NULL.\n - ::CUlaunchConfig::numAttrs is the numbers of attributes populating the\n   first ::CUlaunchConfig::numAttrs positions of the ::CUlaunchConfig::attrs\n   array.\n\n Launch-time configuration is specified by adding entries to\n ::CUlaunchConfig::attrs. Each entry is an attribute ID and a corresponding\n attribute value.\n\n The ::CUlaunchAttribute structure is defined as:\n \\code\ntypedef struct CUlaunchAttribute_st {\nCUlaunchAttributeID id;\nCUlaunchAttributeValue value;\n} CUlaunchAttribute;\n \\endcode\n where:\n - ::CUlaunchAttribute::id is a unique enum identifying the attribute.\n - ::CUlaunchAttribute::value is a union that hold the attribute value.\n\n An example of using the \\p config parameter:\n \\code\nCUlaunchAttribute coopAttr = {.id = CU_LAUNCH_ATTRIBUTE_COOPERATIVE,\n.value = 1};\nCUlaunchConfig config = {... // set block and grid dimensions\n.attrs = &coopAttr,\n.numAttrs = 1};\n\ncuLaunchKernelEx(&config, kernel, NULL, NULL);\n \\endcode\n\n The ::CUlaunchAttributeID enum is defined as:\n \\code\ntypedef enum CUlaunchAttributeID_enum {\nCU_LAUNCH_ATTRIBUTE_IGNORE = 0,\nCU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW   = 1,\nCU_LAUNCH_ATTRIBUTE_COOPERATIVE            = 2,\nCU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = 3,\nCU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION                    = 4,\nCU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 5,\nCU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION    = 6,\nCU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT                   = 7,\n} CUlaunchAttributeID;\n \\endcode\n\n and the corresponding ::CUlaunchAttributeValue union as :\n \\code\ntypedef union CUlaunchAttributeValue_union {\ncuuint64_t pad[8];\nCUaccessPolicyWindow accessPolicyWindow;\nint cooperative;\nCUsynchronizationPolicy syncPolicy;\nstruct {\nunsigned int x;\nunsigned int y;\nunsigned int z;\n} clusterDim;\nCUclusterSchedulingPolicy clusterSchedulingPolicyPreference;\nint programmaticStreamSerializationAllowed;\nstruct {\nCUevent event;\nint flags;\nint triggerAtBlockStart;\n} programmaticEvent;\n} CUlaunchAttributeValue;\n \\endcode\n\n Setting ::CU_LAUNCH_ATTRIBUTE_COOPERATIVE to a non-zero value causes the\n kernel launch to be a cooperative launch, with exactly the same usage and\n semantics of ::cuLaunchCooperativeKernel.\n\n Setting ::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION to a non-zero\n values causes the kernel to use programmatic means to resolve its stream\n dependency -- enabling the CUDA runtime to opportunistically allow the grid's\n execution to overlap with the previous kernel in the stream, if that kernel\n requests the overlap.\n\n ::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT records an event along with the\n kernel launch. Event recorded through this launch attribute is guaranteed to\n only trigger after all block in the associated kernel trigger the event. A\n block can trigger the event through PTX launchdep.release or CUDA builtin\n function cudaTriggerProgrammaticLaunchCompletion(). A trigger can also be\n inserted at the beginning of each block's execution if triggerAtBlockStart is\n set to non-0. Note that dependents (including the CPU thread calling\n cuEventSynchronize()) are not guaranteed to observe the release precisely\n when it is released. For example, cuEventSynchronize() may only observe the\n event trigger long after the associated kernel has completed. This recording\n type is primarily meant for establishing programmatic dependency between\n device tasks. The event supplied must not be an interprocess or interop\n event. The event must disable timing (i.e. created with\n ::CU_EVENT_DISABLE_TIMING flag set).\n\n The effect of other attributes is consistent with their effect when set via\n persistent APIs.\n\n See ::cuStreamSetAttribute for\n - ::CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW\n - ::CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY\n\n See ::cuFunctionSetAttribute for\n - ::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION\n - ::CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE\n\n Kernel parameters to \\p f can be specified in the same ways that they can be\n using ::cuLaunchKernel.\n\n Note that the API can also be used to launch context-less kernel ::CUkernel\n by querying the handle using ::cuLibraryGetKernel() and then passing it\n to the API by casting to ::CUfunction. Here, the context to launch\n the kernel on will either be taken from the specified stream ::CUlaunchConfig::hStream\n or the current context in case of NULL stream.\n\n \\param config         - Config to launch\n \\param f              - Function ::CUfunction or Kernel ::CUkernel to launch\n \\param kernelParams   - Array of pointers to kernel parameters\n \\param extra          - Extra options\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_IMAGE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_LAUNCH_FAILED,\n ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,\n ::CUDA_ERROR_LAUNCH_TIMEOUT,\n ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,\n ::CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_NOT_FOUND\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuCtxGetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuFuncSetCacheConfig,\n ::cuFuncGetAttribute,\n ::cudaLaunchKernel,\n ::cudaLaunchKernelEx,\n ::cuLibraryGetKernel,\n ::cuKernelSetCacheConfig,\n ::cuKernelGetAttribute,\n ::cuKernelSetAttribute"]
    pub fn cuLaunchKernelEx(
        config: *const CUlaunchConfig,
        f: CUfunction,
        kernelParams: *mut *mut ::std::os::raw::c_void,
        extra: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function ::CUfunction or a CUDA kernel ::CUkernel where thread blocks\n can cooperate and synchronize as they execute\n\n Invokes the function ::CUfunction or the kernel ::CUkernel \\p f on a \\p gridDimX x \\p gridDimY x \\p gridDimZ\n grid of blocks. Each block contains \\p blockDimX x \\p blockDimY x\n \\p blockDimZ threads.\n\n Note that the API can also be used to launch context-less kernel ::CUkernel\n by querying the handle using ::cuLibraryGetKernel() and then passing it\n to the API by casting to ::CUfunction. Here, the context to launch\n the kernel on will either be taken from the specified stream \\p hStream\n or the current context in case of NULL stream.\n\n \\p sharedMemBytes sets the amount of dynamic shared memory that will be\n available to each thread block.\n\n The device on which this kernel is invoked must have a non-zero value for\n the device attribute ::CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH.\n\n The total number of blocks launched cannot exceed the maximum number of blocks per\n multiprocessor as returned by ::cuOccupancyMaxActiveBlocksPerMultiprocessor (or\n ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) times the number of multiprocessors\n as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT.\n\n The kernel cannot make use of CUDA dynamic parallelism.\n\n Kernel parameters must be specified via \\p kernelParams.  If \\p f\n has N parameters, then \\p kernelParams needs to be an array of N\n pointers.  Each of \\p kernelParams[0] through \\p kernelParams[N-1]\n must point to a region of memory from which the actual kernel\n parameter will be copied.  The number of kernel parameters and their\n offsets and sizes do not need to be specified as that information is\n retrieved directly from the kernel's image.\n\n Calling ::cuLaunchCooperativeKernel() sets persistent function state that is\n the same as function state set through ::cuLaunchKernel API\n\n When the kernel \\p f is launched via ::cuLaunchCooperativeKernel(), the previous\n block shape, shared size and parameter info associated with \\p f\n is overwritten.\n\n Note that to use ::cuLaunchCooperativeKernel(), the kernel \\p f must either have\n been compiled with toolchain version 3.2 or later so that it will\n contain kernel parameter information, or have no kernel parameters.\n If either of these conditions is not met, then ::cuLaunchCooperativeKernel() will\n return ::CUDA_ERROR_INVALID_IMAGE.\n\n Note that the API can also be used to launch context-less kernel ::CUkernel\n by querying the handle using ::cuLibraryGetKernel() and then passing it\n to the API by casting to ::CUfunction. Here, the context to launch\n the kernel on will either be taken from the specified stream \\p hStream\n or the current context in case of NULL stream.\n\n \\param f              - Function ::CUfunction or Kernel ::CUkernel to launch\n \\param gridDimX       - Width of grid in blocks\n \\param gridDimY       - Height of grid in blocks\n \\param gridDimZ       - Depth of grid in blocks\n \\param blockDimX      - X dimension of each thread block\n \\param blockDimY      - Y dimension of each thread block\n \\param blockDimZ      - Z dimension of each thread block\n \\param sharedMemBytes - Dynamic shared-memory size per thread block in bytes\n \\param hStream        - Stream identifier\n \\param kernelParams   - Array of pointers to kernel parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_IMAGE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_LAUNCH_FAILED,\n ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,\n ::CUDA_ERROR_LAUNCH_TIMEOUT,\n ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,\n ::CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED,\n ::CUDA_ERROR_NOT_FOUND\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuCtxGetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuFuncSetCacheConfig,\n ::cuFuncGetAttribute,\n ::cuLaunchCooperativeKernelMultiDevice,\n ::cudaLaunchCooperativeKernel,\n ::cuLibraryGetKernel,\n ::cuKernelSetCacheConfig,\n ::cuKernelGetAttribute,\n ::cuKernelSetAttribute"]
    pub fn cuLaunchCooperativeKernel(
        f: CUfunction,
        gridDimX: ::std::os::raw::c_uint,
        gridDimY: ::std::os::raw::c_uint,
        gridDimZ: ::std::os::raw::c_uint,
        blockDimX: ::std::os::raw::c_uint,
        blockDimY: ::std::os::raw::c_uint,
        blockDimZ: ::std::os::raw::c_uint,
        sharedMemBytes: ::std::os::raw::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute\n\n \\deprecated This function is deprecated as of CUDA 11.3.\n\n Invokes kernels as specified in the \\p launchParamsList array where each element\n of the array specifies all the parameters required to perform a single kernel launch.\n These kernels can cooperate and synchronize as they execute. The size of the array is\n specified by \\p numDevices.\n\n No two kernels can be launched on the same device. All the devices targeted by this\n multi-device launch must be identical. All devices must have a non-zero value for the\n device attribute ::CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH.\n\n All kernels launched must be identical with respect to the compiled code. Note that\n any __device__, __constant__ or __managed__ variables present in the module that owns\n the kernel launched on each device, are independently instantiated on every device.\n It is the application's responsiblity to ensure these variables are initialized and\n used appropriately.\n\n The size of the grids as specified in blocks, the size of the blocks themselves\n and the amount of shared memory used by each thread block must also match across\n all launched kernels.\n\n The streams used to launch these kernels must have been created via either ::cuStreamCreate\n or ::cuStreamCreateWithPriority. The NULL stream or ::CU_STREAM_LEGACY or ::CU_STREAM_PER_THREAD\n cannot be used.\n\n The total number of blocks launched per kernel cannot exceed the maximum number of blocks\n per multiprocessor as returned by ::cuOccupancyMaxActiveBlocksPerMultiprocessor (or\n ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags) times the number of multiprocessors\n as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT. Since the\n total number of blocks launched per device has to match across all devices, the maximum\n number of blocks that can be launched per device will be limited by the device with the\n least number of multiprocessors.\n\n The kernels cannot make use of CUDA dynamic parallelism.\n\n The ::CUDA_LAUNCH_PARAMS structure is defined as:\n \\code\ntypedef struct CUDA_LAUNCH_PARAMS_st\n{\nCUfunction function;\nunsigned int gridDimX;\nunsigned int gridDimY;\nunsigned int gridDimZ;\nunsigned int blockDimX;\nunsigned int blockDimY;\nunsigned int blockDimZ;\nunsigned int sharedMemBytes;\nCUstream hStream;\nvoid **kernelParams;\n} CUDA_LAUNCH_PARAMS;\n \\endcode\n where:\n - ::CUDA_LAUNCH_PARAMS::function specifies the kernel to be launched. All functions must\n   be identical with respect to the compiled code.\n   Note that you can also specify context-less kernel ::CUkernel by querying the handle\n   using ::cuLibraryGetKernel() and then casting to ::CUfunction. In this case, the context to\n   launch the kernel on be taken from the specified stream ::CUDA_LAUNCH_PARAMS::hStream.\n - ::CUDA_LAUNCH_PARAMS::gridDimX is the width of the grid in blocks. This must match across\n   all kernels launched.\n - ::CUDA_LAUNCH_PARAMS::gridDimY is the height of the grid in blocks. This must match across\n   all kernels launched.\n - ::CUDA_LAUNCH_PARAMS::gridDimZ is the depth of the grid in blocks. This must match across\n   all kernels launched.\n - ::CUDA_LAUNCH_PARAMS::blockDimX is the X dimension of each thread block. This must match across\n   all kernels launched.\n - ::CUDA_LAUNCH_PARAMS::blockDimX is the Y dimension of each thread block. This must match across\n   all kernels launched.\n - ::CUDA_LAUNCH_PARAMS::blockDimZ is the Z dimension of each thread block. This must match across\n   all kernels launched.\n - ::CUDA_LAUNCH_PARAMS::sharedMemBytes is the dynamic shared-memory size per thread block in bytes.\n   This must match across all kernels launched.\n - ::CUDA_LAUNCH_PARAMS::hStream is the handle to the stream to perform the launch in. This cannot\n   be the NULL stream or ::CU_STREAM_LEGACY or ::CU_STREAM_PER_THREAD. The CUDA context associated\n   with this stream must match that associated with ::CUDA_LAUNCH_PARAMS::function.\n - ::CUDA_LAUNCH_PARAMS::kernelParams is an array of pointers to kernel parameters. If\n   ::CUDA_LAUNCH_PARAMS::function has N parameters, then ::CUDA_LAUNCH_PARAMS::kernelParams\n   needs to be an array of N pointers. Each of ::CUDA_LAUNCH_PARAMS::kernelParams[0] through\n   ::CUDA_LAUNCH_PARAMS::kernelParams[N-1] must point to a region of memory from which the actual\n   kernel parameter will be copied. The number of kernel parameters and their offsets and sizes\n   do not need to be specified as that information is retrieved directly from the kernel's image.\n\n By default, the kernel won't begin execution on any GPU until all prior work in all the specified\n streams has completed. This behavior can be overridden by specifying the flag\n ::CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC. When this flag is specified, each kernel\n will only wait for prior work in the stream corresponding to that GPU to complete before it begins\n execution.\n\n Similarly, by default, any subsequent work pushed in any of the specified streams will not begin\n execution until the kernels on all GPUs have completed. This behavior can be overridden by specifying\n the flag ::CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC. When this flag is specified,\n any subsequent work pushed in any of the specified streams will only wait for the kernel launched\n on the GPU corresponding to that stream to complete before it begins execution.\n\n Calling ::cuLaunchCooperativeKernelMultiDevice() sets persistent function state that is\n the same as function state set through ::cuLaunchKernel API when called individually for each\n element in \\p launchParamsList.\n\n When kernels are launched via ::cuLaunchCooperativeKernelMultiDevice(), the previous\n block shape, shared size and parameter info associated with each ::CUDA_LAUNCH_PARAMS::function\n in \\p launchParamsList is overwritten.\n\n Note that to use ::cuLaunchCooperativeKernelMultiDevice(), the kernels must either have\n been compiled with toolchain version 3.2 or later so that it will\n contain kernel parameter information, or have no kernel parameters.\n If either of these conditions is not met, then ::cuLaunchCooperativeKernelMultiDevice() will\n return ::CUDA_ERROR_INVALID_IMAGE.\n\n \\param launchParamsList - List of launch parameters, one per device\n \\param numDevices       - Size of the \\p launchParamsList array\n \\param flags            - Flags to control launch behavior\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_IMAGE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_LAUNCH_FAILED,\n ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,\n ::CUDA_ERROR_LAUNCH_TIMEOUT,\n ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,\n ::CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuCtxGetCacheConfig,\n ::cuCtxSetCacheConfig,\n ::cuFuncSetCacheConfig,\n ::cuFuncGetAttribute,\n ::cuLaunchCooperativeKernel,\n ::cudaLaunchCooperativeKernelMultiDevice"]
    pub fn cuLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut CUDA_LAUNCH_PARAMS,
        numDevices: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Enqueues a host function call in a stream\n\n Enqueues a host function to run in a stream.  The function will be called\n after currently enqueued work and will block work added after it.\n\n The host function must not make any CUDA API calls.  Attempting to use a\n CUDA API may result in ::CUDA_ERROR_NOT_PERMITTED, but this is not required.\n The host function must not perform any synchronization that may depend on\n outstanding CUDA work not mandated to run earlier.  Host functions without a\n mandated order (such as in independent streams) execute in undefined order\n and may be serialized.\n\n For the purposes of Unified Memory, execution makes a number of guarantees:\n <ul>\n   <li>The stream is considered idle for the duration of the function's\n   execution.  Thus, for example, the function may always use memory attached\n   to the stream it was enqueued in.</li>\n   <li>The start of execution of the function has the same effect as\n   synchronizing an event recorded in the same stream immediately prior to\n   the function.  It thus synchronizes streams which have been \"joined\"\n   prior to the function.</li>\n   <li>Adding device work to any stream does not have the effect of making\n   the stream active until all preceding host functions and stream callbacks\n   have executed.  Thus, for\n   example, a function might use global attached memory even if work has\n   been added to another stream, if the work has been ordered behind the\n   function call with an event.</li>\n   <li>Completion of the function does not cause a stream to become\n   active except as described above.  The stream will remain idle\n   if no device work follows the function, and will remain idle across\n   consecutive host functions or stream callbacks without device work in\n   between.  Thus, for example,\n   stream synchronization can be done by signaling from a host function at the\n   end of the stream.</li>\n </ul>\n\n Note that, in contrast to ::cuStreamAddCallback, the function will not be\n called in the event of an error in the CUDA context.\n\n \\param hStream  - Stream to enqueue function call in\n \\param fn       - The function to call once preceding stream operations are complete\n \\param userData - User-specified data to be passed to the function\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_SUPPORTED\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuStreamCreate,\n ::cuStreamQuery,\n ::cuStreamSynchronize,\n ::cuStreamWaitEvent,\n ::cuStreamDestroy,\n ::cuMemAllocManaged,\n ::cuStreamAttachMemAsync,\n ::cuStreamAddCallback"]
    pub fn cuLaunchHostFunc(
        hStream: CUstream,
        fn_: CUhostFn,
        userData: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the block-dimensions for the function\n\n \\deprecated\n\n Specifies the \\p x, \\p y, and \\p z dimensions of the thread blocks that are\n created when the kernel given by \\p hfunc is launched.\n\n \\param hfunc - Kernel to specify dimensions of\n \\param x     - X dimension\n \\param y     - Y dimension\n \\param z     - Z dimension\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuFuncSetSharedSize,\n ::cuFuncSetCacheConfig,\n ::cuFuncGetAttribute,\n ::cuParamSetSize,\n ::cuParamSeti,\n ::cuParamSetf,\n ::cuParamSetv,\n ::cuLaunch,\n ::cuLaunchGrid,\n ::cuLaunchGridAsync,\n ::cuLaunchKernel"]
    pub fn cuFuncSetBlockShape(
        hfunc: CUfunction,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the dynamic shared-memory size for the function\n\n \\deprecated\n\n Sets through \\p bytes the amount of dynamic shared memory that will be\n available to each thread block when the kernel given by \\p hfunc is launched.\n\n \\param hfunc - Kernel to specify dynamic shared-memory size for\n \\param bytes - Dynamic shared-memory size per thread in bytes\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuFuncSetBlockShape,\n ::cuFuncSetCacheConfig,\n ::cuFuncGetAttribute,\n ::cuParamSetSize,\n ::cuParamSeti,\n ::cuParamSetf,\n ::cuParamSetv,\n ::cuLaunch,\n ::cuLaunchGrid,\n ::cuLaunchGridAsync,\n ::cuLaunchKernel"]
    pub fn cuFuncSetSharedSize(hfunc: CUfunction, bytes: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameter size for the function\n\n \\deprecated\n\n Sets through \\p numbytes the total size in bytes needed by the function\n parameters of the kernel corresponding to \\p hfunc.\n\n \\param hfunc    - Kernel to set parameter size for\n \\param numbytes - Size of parameter list in bytes\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuFuncSetBlockShape,\n ::cuFuncSetSharedSize,\n ::cuFuncGetAttribute,\n ::cuParamSetf,\n ::cuParamSeti,\n ::cuParamSetv,\n ::cuLaunch,\n ::cuLaunchGrid,\n ::cuLaunchGridAsync,\n ::cuLaunchKernel"]
    pub fn cuParamSetSize(hfunc: CUfunction, numbytes: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds an integer parameter to the function's argument list\n\n \\deprecated\n\n Sets an integer parameter that will be specified the next time the\n kernel corresponding to \\p hfunc will be invoked. \\p offset is a byte offset.\n\n \\param hfunc  - Kernel to add parameter to\n \\param offset - Offset to add parameter to argument list\n \\param value  - Value of parameter\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuFuncSetBlockShape,\n ::cuFuncSetSharedSize,\n ::cuFuncGetAttribute,\n ::cuParamSetSize,\n ::cuParamSetf,\n ::cuParamSetv,\n ::cuLaunch,\n ::cuLaunchGrid,\n ::cuLaunchGridAsync,\n ::cuLaunchKernel"]
    pub fn cuParamSeti(
        hfunc: CUfunction,
        offset: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds a floating-point parameter to the function's argument list\n\n \\deprecated\n\n Sets a floating-point parameter that will be specified the next time the\n kernel corresponding to \\p hfunc will be invoked. \\p offset is a byte offset.\n\n \\param hfunc  - Kernel to add parameter to\n \\param offset - Offset to add parameter to argument list\n \\param value  - Value of parameter\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuFuncSetBlockShape,\n ::cuFuncSetSharedSize,\n ::cuFuncGetAttribute,\n ::cuParamSetSize,\n ::cuParamSeti,\n ::cuParamSetv,\n ::cuLaunch,\n ::cuLaunchGrid,\n ::cuLaunchGridAsync,\n ::cuLaunchKernel"]
    pub fn cuParamSetf(hfunc: CUfunction, offset: ::std::os::raw::c_int, value: f32) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds arbitrary data to the function's argument list\n\n \\deprecated\n\n Copies an arbitrary amount of data (specified in \\p numbytes) from \\p ptr\n into the parameter space of the kernel corresponding to \\p hfunc. \\p offset\n is a byte offset.\n\n \\param hfunc    - Kernel to add data to\n \\param offset   - Offset to add data to argument list\n \\param ptr      - Pointer to arbitrary data\n \\param numbytes - Size of data to copy in bytes\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa ::cuFuncSetBlockShape,\n ::cuFuncSetSharedSize,\n ::cuFuncGetAttribute,\n ::cuParamSetSize,\n ::cuParamSetf,\n ::cuParamSeti,\n ::cuLaunch,\n ::cuLaunchGrid,\n ::cuLaunchGridAsync,\n ::cuLaunchKernel"]
    pub fn cuParamSetv(
        hfunc: CUfunction,
        offset: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
        numbytes: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function\n\n \\deprecated\n\n Invokes the kernel \\p f on a 1 x 1 x 1 grid of blocks. The block\n contains the number of threads specified by a previous call to\n ::cuFuncSetBlockShape().\n\n The block shape, dynamic shared memory size, and parameter information\n must be set using\n  ::cuFuncSetBlockShape(),\n  ::cuFuncSetSharedSize(),\n  ::cuParamSetSize(),\n  ::cuParamSeti(),\n  ::cuParamSetf(), and\n  ::cuParamSetv()\n prior to calling this function.\n\n Launching a function via ::cuLaunchKernel() invalidates the function's\n block shape, dynamic shared memory size, and parameter information. After\n launching via cuLaunchKernel, this state must be re-initialized prior to\n calling this function. Failure to do so results in undefined behavior.\n\n \\param f - Kernel to launch\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_LAUNCH_FAILED,\n ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,\n ::CUDA_ERROR_LAUNCH_TIMEOUT,\n ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED\n \\notefnerr\n\n \\sa ::cuFuncSetBlockShape,\n ::cuFuncSetSharedSize,\n ::cuFuncGetAttribute,\n ::cuParamSetSize,\n ::cuParamSetf,\n ::cuParamSeti,\n ::cuParamSetv,\n ::cuLaunchGrid,\n ::cuLaunchGridAsync,\n ::cuLaunchKernel"]
    pub fn cuLaunch(f: CUfunction) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function\n\n \\deprecated\n\n Invokes the kernel \\p f on a \\p grid_width x \\p grid_height grid of\n blocks. Each block contains the number of threads specified by a previous\n call to ::cuFuncSetBlockShape().\n\n The block shape, dynamic shared memory size, and parameter information\n must be set using\n  ::cuFuncSetBlockShape(),\n  ::cuFuncSetSharedSize(),\n  ::cuParamSetSize(),\n  ::cuParamSeti(),\n  ::cuParamSetf(), and\n  ::cuParamSetv()\n prior to calling this function.\n\n Launching a function via ::cuLaunchKernel() invalidates the function's\n block shape, dynamic shared memory size, and parameter information. After\n launching via cuLaunchKernel, this state must be re-initialized prior to\n calling this function. Failure to do so results in undefined behavior.\n\n \\param f           - Kernel to launch\n \\param grid_width  - Width of grid in blocks\n \\param grid_height - Height of grid in blocks\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_LAUNCH_FAILED,\n ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,\n ::CUDA_ERROR_LAUNCH_TIMEOUT,\n ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED\n \\notefnerr\n\n \\sa ::cuFuncSetBlockShape,\n ::cuFuncSetSharedSize,\n ::cuFuncGetAttribute,\n ::cuParamSetSize,\n ::cuParamSetf,\n ::cuParamSeti,\n ::cuParamSetv,\n ::cuLaunch,\n ::cuLaunchGridAsync,\n ::cuLaunchKernel"]
    pub fn cuLaunchGrid(
        f: CUfunction,
        grid_width: ::std::os::raw::c_int,
        grid_height: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches a CUDA function\n\n \\deprecated\n\n Invokes the kernel \\p f on a \\p grid_width x \\p grid_height grid of\n blocks. Each block contains the number of threads specified by a previous\n call to ::cuFuncSetBlockShape().\n\n The block shape, dynamic shared memory size, and parameter information\n must be set using\n  ::cuFuncSetBlockShape(),\n  ::cuFuncSetSharedSize(),\n  ::cuParamSetSize(),\n  ::cuParamSeti(),\n  ::cuParamSetf(), and\n  ::cuParamSetv()\n prior to calling this function.\n\n Launching a function via ::cuLaunchKernel() invalidates the function's\n block shape, dynamic shared memory size, and parameter information. After\n launching via cuLaunchKernel, this state must be re-initialized prior to\n calling this function. Failure to do so results in undefined behavior.\n\n \\param f           - Kernel to launch\n \\param grid_width  - Width of grid in blocks\n \\param grid_height - Height of grid in blocks\n \\param hStream     - Stream identifier\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_LAUNCH_FAILED,\n ::CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES,\n ::CUDA_ERROR_LAUNCH_TIMEOUT,\n ::CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING,\n ::CUDA_ERROR_SHARED_OBJECT_INIT_FAILED\n\n \\note In certain cases where cubins are created with no ABI (i.e., using \\p ptxas \\p --abi-compile \\p no),\n       this function may serialize kernel launches. The CUDA driver retains asynchronous behavior by\n       growing the per-thread stack as needed per launch and not shrinking it afterwards.\n\n \\note_null_stream\n \\notefnerr\n\n \\sa ::cuFuncSetBlockShape,\n ::cuFuncSetSharedSize,\n ::cuFuncGetAttribute,\n ::cuParamSetSize,\n ::cuParamSetf,\n ::cuParamSeti,\n ::cuParamSetv,\n ::cuLaunch,\n ::cuLaunchGrid,\n ::cuLaunchKernel"]
    pub fn cuLaunchGridAsync(
        f: CUfunction,
        grid_width: ::std::os::raw::c_int,
        grid_height: ::std::os::raw::c_int,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds a texture-reference to the function's argument list\n\n \\deprecated\n\n Makes the CUDA array or linear memory bound to the texture reference\n \\p hTexRef available to a device program as a texture. In this version of\n CUDA, the texture-reference must be obtained via ::cuModuleGetTexRef() and\n the \\p texunit parameter must be set to ::CU_PARAM_TR_DEFAULT.\n\n \\param hfunc   - Kernel to add texture-reference to\n \\param texunit - Texture unit (must be ::CU_PARAM_TR_DEFAULT)\n \\param hTexRef - Texture-reference to add to argument list\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr"]
    pub fn cuParamSetTexRef(
        hfunc: CUfunction,
        texunit: ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a graph\n\n Creates an empty graph, which is returned via \\p phGraph.\n\n \\param phGraph - Returns newly created graph\n \\param flags   - Graph creation flags, must be 0\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddHostNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode,\n ::cuGraphInstantiate,\n ::cuGraphDestroy,\n ::cuGraphGetNodes,\n ::cuGraphGetRootNodes,\n ::cuGraphGetEdges,\n ::cuGraphClone"]
    pub fn cuGraphCreate(phGraph: *mut CUgraph, flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuGraphAddKernelNode_v2(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeGetParams_v2(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphKernelNodeSetParams_v2(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a memcpy node and adds it to a graph\n\n Creates a new memcpy node and adds it to \\p hGraph with \\p numDependencies\n dependencies specified via \\p dependencies.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p phGraphNode.\n\n When the graph is launched, the node will perform the memcpy described by \\p copyParams.\n See ::cuMemcpy3D() for a description of the structure and its restrictions.\n\n Memcpy nodes have some additional restrictions with regards to managed memory, if the\n system contains at least one device which has a zero value for the device attribute\n ::CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS. If one or more of the operands refer\n to managed memory, then using the memory type ::CU_MEMORYTYPE_UNIFIED is disallowed\n for those operand(s). The managed memory will be treated as residing on either the\n host or the device, depending on which memory type is specified.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param copyParams      - Parameters for the memory copy\n \\param ctx             - Context on which to run the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuMemcpy3D,\n ::cuGraphMemcpyNodeGetParams,\n ::cuGraphMemcpyNodeSetParams,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddHostNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddMemcpyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a memcpy node's parameters\n\n Returns the parameters of memcpy node \\p hNode in \\p nodeParams.\n\n \\param hNode      - Node to get the parameters for\n \\param nodeParams - Pointer to return the parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuMemcpy3D,\n ::cuGraphAddMemcpyNode,\n ::cuGraphMemcpyNodeSetParams"]
    pub fn cuGraphMemcpyNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMCPY3D,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets a memcpy node's parameters\n\n Sets the parameters of memcpy node \\p hNode to \\p nodeParams.\n\n \\param hNode      - Node to set the parameters for\n \\param nodeParams - Parameters to copy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuMemcpy3D,\n ::cuGraphAddMemcpyNode,\n ::cuGraphMemcpyNodeGetParams"]
    pub fn cuGraphMemcpyNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMCPY3D,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a memset node and adds it to a graph\n\n Creates a new memset node and adds it to \\p hGraph with \\p numDependencies\n dependencies specified via \\p dependencies.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p phGraphNode.\n\n The element size must be 1, 2, or 4 bytes.\n When the graph is launched, the node will perform the memset described by \\p memsetParams.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param memsetParams    - Parameters for the memory set\n \\param ctx             - Context on which to run the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_CONTEXT\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuMemsetD2D32,\n ::cuGraphMemsetNodeGetParams,\n ::cuGraphMemsetNodeSetParams,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddHostNode,\n ::cuGraphAddMemcpyNode"]
    pub fn cuGraphAddMemsetNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a memset node's parameters\n\n Returns the parameters of memset node \\p hNode in \\p nodeParams.\n\n \\param hNode      - Node to get the parameters for\n \\param nodeParams - Pointer to return the parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuMemsetD2D32,\n ::cuGraphAddMemsetNode,\n ::cuGraphMemsetNodeSetParams"]
    pub fn cuGraphMemsetNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets a memset node's parameters\n\n Sets the parameters of memset node \\p hNode to \\p nodeParams.\n\n \\param hNode      - Node to set the parameters for\n \\param nodeParams - Parameters to copy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuMemsetD2D32,\n ::cuGraphAddMemsetNode,\n ::cuGraphMemsetNodeGetParams"]
    pub fn cuGraphMemsetNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a host execution node and adds it to a graph\n\n Creates a new CPU execution node and adds it to \\p hGraph with \\p numDependencies\n dependencies specified via \\p dependencies and arguments specified in \\p nodeParams.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p phGraphNode.\n\n When the graph is launched, the node will invoke the specified CPU function.\n Host nodes are not supported under MPS with pre-Volta GPUs.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param nodeParams      - Parameters for the host node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuLaunchHostFunc,\n ::cuGraphHostNodeGetParams,\n ::cuGraphHostNodeSetParams,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddHostNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a host node's parameters\n\n Returns the parameters of host node \\p hNode in \\p nodeParams.\n\n \\param hNode      - Node to get the parameters for\n \\param nodeParams - Pointer to return the parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuLaunchHostFunc,\n ::cuGraphAddHostNode,\n ::cuGraphHostNodeSetParams"]
    pub fn cuGraphHostNodeGetParams(
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets a host node's parameters\n\n Sets the parameters of host node \\p hNode to \\p nodeParams.\n\n \\param hNode      - Node to set the parameters for\n \\param nodeParams - Parameters to copy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuLaunchHostFunc,\n ::cuGraphAddHostNode,\n ::cuGraphHostNodeGetParams"]
    pub fn cuGraphHostNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a child graph node and adds it to a graph\n\n Creates a new node which executes an embedded graph, and adds it to \\p hGraph with\n \\p numDependencies dependencies specified via \\p dependencies.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p phGraphNode.\n\n If \\p hGraph contains allocation or free nodes, this call will return an error.\n\n The node executes an embedded child graph. The child graph is cloned in this call.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param childGraph      - The graph to clone into this node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphChildGraphNodeGetGraph,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddHostNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode,\n ::cuGraphClone"]
    pub fn cuGraphAddChildGraphNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        childGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets a handle to the embedded graph of a child graph node\n\n Gets a handle to the embedded graph in a child graph node. This call\n does not clone the graph. Changes to the graph will be reflected in\n the node, and the node retains ownership of the graph.\n\n Allocation and free nodes cannot be added to the returned graph.\n Attempting to do so will return an error.\n\n \\param hNode   - Node to get the embedded graph for\n \\param phGraph - Location to store a handle to the graph\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddChildGraphNode,\n ::cuGraphNodeFindInClone"]
    pub fn cuGraphChildGraphNodeGetGraph(hNode: CUgraphNode, phGraph: *mut CUgraph) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an empty node and adds it to a graph\n\n Creates a new node which performs no operation, and adds it to \\p hGraph with\n \\p numDependencies dependencies specified via \\p dependencies.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p phGraphNode.\n\n An empty node performs no operation during execution, but can be used for\n transitive ordering. For example, a phased execution graph with 2 groups of n\n nodes with a barrier between them can be represented using an empty node and\n 2*n dependency edges, rather than no empty node and n^2 dependency edges.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddHostNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddEmptyNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an event record node and adds it to a graph\n\n Creates a new event record node and adds it to \\p hGraph with \\p numDependencies\n dependencies specified via \\p dependencies and event specified in \\p event.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p phGraphNode.\n\n Each launch of the graph will record \\p event to capture execution of the\n node's dependencies.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param event           - Event for the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddEventWaitNode,\n ::cuEventRecordWithFlags,\n ::cuStreamWaitEvent,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddEventRecordNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the event associated with an event record node\n\n Returns the event of event record node \\p hNode in \\p event_out.\n\n \\param hNode     - Node to get the event for\n \\param event_out - Pointer to return the event\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddEventRecordNode,\n ::cuGraphEventRecordNodeSetEvent,\n ::cuGraphEventWaitNodeGetEvent,\n ::cuEventRecordWithFlags,\n ::cuStreamWaitEvent"]
    pub fn cuGraphEventRecordNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets an event record node's event\n\n Sets the event of event record node \\p hNode to \\p event.\n\n \\param hNode - Node to set the event for\n \\param event - Event to use\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddEventRecordNode,\n ::cuGraphEventRecordNodeGetEvent,\n ::cuGraphEventWaitNodeSetEvent,\n ::cuEventRecordWithFlags,\n ::cuStreamWaitEvent"]
    pub fn cuGraphEventRecordNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an event wait node and adds it to a graph\n\n Creates a new event wait node and adds it to \\p hGraph with \\p numDependencies\n dependencies specified via \\p dependencies and event specified in \\p event.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p phGraphNode.\n\n The graph node will wait for all work captured in \\p event.  See ::cuEventRecord()\n for details on what is captured by an event. \\p event may be from a different context\n or device than the launch stream.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param event           - Event for the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddEventRecordNode,\n ::cuEventRecordWithFlags,\n ::cuStreamWaitEvent,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddEventWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns the event associated with an event wait node\n\n Returns the event of event wait node \\p hNode in \\p event_out.\n\n \\param hNode     - Node to get the event for\n \\param event_out - Pointer to return the event\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddEventWaitNode,\n ::cuGraphEventWaitNodeSetEvent,\n ::cuGraphEventRecordNodeGetEvent,\n ::cuEventRecordWithFlags,\n ::cuStreamWaitEvent"]
    pub fn cuGraphEventWaitNodeGetEvent(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets an event wait node's event\n\n Sets the event of event wait node \\p hNode to \\p event.\n\n \\param hNode - Node to set the event for\n \\param event - Event to use\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddEventWaitNode,\n ::cuGraphEventWaitNodeGetEvent,\n ::cuGraphEventRecordNodeSetEvent,\n ::cuEventRecordWithFlags,\n ::cuStreamWaitEvent"]
    pub fn cuGraphEventWaitNodeSetEvent(hNode: CUgraphNode, event: CUevent) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an external semaphore signal node and adds it to a graph\n\n Creates a new external semaphore signal node and adds it to \\p hGraph with \\p\n numDependencies dependencies specified via \\p dependencies and arguments specified\n in \\p nodeParams. It is possible for \\p numDependencies to be 0, in which case the\n node will be placed at the root of the graph. \\p dependencies may not have any\n duplicate entries. A handle to the new node will be returned in \\p phGraphNode.\n\n Performs a signal operation on a set of externally allocated semaphore objects\n when the node is launched.  The operation(s) will occur after all of the node's\n dependencies have completed.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param nodeParams      - Parameters for the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphExternalSemaphoresSignalNodeGetParams,\n ::cuGraphExternalSemaphoresSignalNodeSetParams,\n ::cuGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuImportExternalSemaphore,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddEventRecordNode,\n ::cuGraphAddEventWaitNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddExternalSemaphoresSignalNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns an external semaphore signal node's parameters\n\n Returns the parameters of an external semaphore signal node \\p hNode in \\p params_out.\n The \\p extSemArray and \\p paramsArray returned in \\p params_out,\n are owned by the node.  This memory remains valid until the node is destroyed or its\n parameters are modified, and should not be modified\n directly. Use ::cuGraphExternalSemaphoresSignalNodeSetParams to update the\n parameters of this node.\n\n \\param hNode      - Node to get the parameters for\n \\param params_out - Pointer to return the parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuLaunchKernel,\n ::cuGraphAddExternalSemaphoresSignalNode,\n ::cuGraphExternalSemaphoresSignalNodeSetParams,\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync"]
    pub fn cuGraphExternalSemaphoresSignalNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets an external semaphore signal node's parameters\n\n Sets the parameters of an external semaphore signal node \\p hNode to \\p nodeParams.\n\n \\param hNode      - Node to set the parameters for\n \\param nodeParams - Parameters to copy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddExternalSemaphoresSignalNode,\n ::cuGraphExternalSemaphoresSignalNodeSetParams,\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync"]
    pub fn cuGraphExternalSemaphoresSignalNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an external semaphore wait node and adds it to a graph\n\n Creates a new external semaphore wait node and adds it to \\p hGraph with \\p numDependencies\n dependencies specified via \\p dependencies and arguments specified in \\p nodeParams.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries. A handle\n to the new node will be returned in \\p phGraphNode.\n\n Performs a wait operation on a set of externally allocated semaphore objects\n when the node is launched.  The node's dependencies will not be launched until\n the wait operation has completed.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param nodeParams      - Parameters for the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphExternalSemaphoresWaitNodeGetParams,\n ::cuGraphExternalSemaphoresWaitNodeSetParams,\n ::cuGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cuGraphAddExternalSemaphoresSignalNode,\n ::cuImportExternalSemaphore,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddEventRecordNode,\n ::cuGraphAddEventWaitNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddExternalSemaphoresWaitNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns an external semaphore wait node's parameters\n\n Returns the parameters of an external semaphore wait node \\p hNode in \\p params_out.\n The \\p extSemArray and \\p paramsArray returned in \\p params_out,\n are owned by the node.  This memory remains valid until the node is destroyed or its\n parameters are modified, and should not be modified\n directly. Use ::cuGraphExternalSemaphoresSignalNodeSetParams to update the\n parameters of this node.\n\n \\param hNode      - Node to get the parameters for\n \\param params_out - Pointer to return the parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuLaunchKernel,\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuGraphExternalSemaphoresWaitNodeSetParams,\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync"]
    pub fn cuGraphExternalSemaphoresWaitNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets an external semaphore wait node's parameters\n\n Sets the parameters of an external semaphore wait node \\p hNode to \\p nodeParams.\n\n \\param hNode      - Node to set the parameters for\n \\param nodeParams - Parameters to copy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuGraphExternalSemaphoresWaitNodeSetParams,\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync"]
    pub fn cuGraphExternalSemaphoresWaitNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a batch memory operation node and adds it to a graph\n\n Creates a new batch memory operation node and adds it to \\p hGraph with \\p\n numDependencies dependencies specified via \\p dependencies and arguments specified in \\p nodeParams.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries.\n A handle to the new node will be returned in \\p phGraphNode.\n\n When the node is added, the paramArray inside \\p nodeParams is copied and therefore it can be\n freed after the call returns.\n\n \\note\n Warning:\n Improper use of this API may deadlock the application. Synchronization\n ordering established through this API is not visible to CUDA. CUDA tasks\n that are (even indirectly) ordered by this API should also have that order\n expressed with CUDA-visible dependencies such as events. This ensures that\n the scheduler does not serialize them in an improper order. For more\n information, see the Stream Memory Operations section in the programming\n guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param nodeParams      - Parameters for the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuStreamBatchMemOp,\n ::cuStreamWaitValue32,\n ::cuStreamWriteValue32,\n ::cuStreamWaitValue64,\n ::cuStreamWriteValue64,\n ::cuGraphBatchMemOpNodeGetParams,\n ::cuGraphBatchMemOpNodeSetParams,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddBatchMemOpNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a batch mem op node's parameters\n\n Returns the parameters of batch mem op node \\p hNode in \\p nodeParams_out.\n The \\p paramArray returned in \\p nodeParams_out is owned by the node.\n This memory remains valid until the node is destroyed or its\n parameters are modified, and should not be modified\n directly. Use ::cuGraphBatchMemOpNodeSetParams to update the\n parameters of this node.\n\n \\param hNode          - Node to get the parameters for\n \\param nodeParams_out - Pointer to return the parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuStreamBatchMemOp,\n ::cuGraphAddBatchMemOpNode,\n ::cuGraphBatchMemOpNodeSetParams"]
    pub fn cuGraphBatchMemOpNodeGetParams(
        hNode: CUgraphNode,
        nodeParams_out: *mut CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets a batch mem op node's parameters\n\n Sets the parameters of batch mem op node \\p hNode to \\p nodeParams.\n\n The paramArray inside \\p nodeParams is copied and therefore it can be\n freed after the call returns.\n\n \\param hNode      - Node to set the parameters for\n \\param nodeParams - Parameters to copy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuStreamBatchMemOp,\n ::cuGraphAddBatchMemOpNode,\n ::cuGraphBatchMemOpNodeGetParams"]
    pub fn cuGraphBatchMemOpNodeSetParams(
        hNode: CUgraphNode,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for a batch mem op node in the given graphExec\n\n Sets the parameters of a batch mem op node in an executable graph \\p hGraphExec.\n The node is identified by the corresponding node \\p hNode in the\n non-executable graph, from which the executable graph was instantiated.\n\n The following fields on operations may be modified on an executable graph:\n\n  op.waitValue.address\n  op.waitValue.value[64]\n  op.waitValue.flags bits corresponding to wait type (i.e. CU_STREAM_WAIT_VALUE_FLUSH bit cannot be modified)\n  op.writeValue.address\n  op.writeValue.value[64]\n\n Other fields, such as the context, count or type of operations, and other types of operations such as membars,\n may not be modified.\n\n \\p hNode must not have been removed from the original graph.\n\n The modifications only affect future launches of \\p hGraphExec. Already\n enqueued or running launches of \\p hGraphExec are not affected by this call.\n \\p hNode is also not modified by this call.\n\n The paramArray inside \\p nodeParams is copied and therefore it can be\n freed after the call returns.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - Batch mem op node from the graph from which graphExec was instantiated\n \\param nodeParams - Updated Parameters to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuStreamBatchMemOp,\n ::cuGraphAddBatchMemOpNode,\n ::cuGraphBatchMemOpNodeGetParams,\n ::cuGraphBatchMemOpNodeSetParams,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecBatchMemOpNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an allocation node and adds it to a graph\n\n Creates a new allocation node and adds it to \\p hGraph with \\p numDependencies\n dependencies specified via \\p dependencies and arguments specified in \\p nodeParams.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries. A handle\n to the new node will be returned in \\p phGraphNode.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param nodeParams      - Parameters for the node\n\n When ::cuGraphAddMemAllocNode creates an allocation node, it returns the address of the allocation in\n \\p nodeParams.dptr.  The allocation's address remains fixed across instantiations and launches.\n\n If the allocation is freed in the same graph, by creating a free node using ::cuGraphAddMemFreeNode,\n the allocation can be accessed by nodes ordered after the allocation node but before the free node.\n These allocations cannot be freed outside the owning graph, and they can only be freed once in the\n owning graph.\n\n If the allocation is not freed in the same graph, then it can be accessed not only by nodes in the\n graph which are ordered after the allocation node, but also by stream operations ordered after the\n graph's execution but before the allocation is freed.\n\n Allocations which are not freed in the same graph can be freed by:\n - passing the allocation to ::cuMemFreeAsync or ::cuMemFree;\n - launching a graph with a free node for that allocation; or\n - specifying ::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH during instantiation, which makes\n each launch behave as though it called ::cuMemFreeAsync for every unfreed allocation.\n\n It is not possible to free an allocation in both the owning graph and another graph.  If the allocation\n is freed in the same graph, a free node cannot be added to another graph.  If the allocation is freed\n in another graph, a free node can no longer be added to the owning graph.\n\n The following restrictions apply to graphs which contain allocation and/or memory free nodes:\n - Nodes and edges of the graph cannot be deleted.\n - The graph cannot be used in a child node.\n - Only one instantiation of the graph may exist at any point in time.\n - The graph cannot be cloned.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddMemFreeNode,\n ::cuGraphMemAllocNodeGetParams,\n ::cuDeviceGraphMemTrim,\n ::cuDeviceGetGraphMemAttribute,\n ::cuDeviceSetGraphMemAttribute,\n ::cuMemAllocAsync,\n ::cuMemFreeAsync,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddEventRecordNode,\n ::cuGraphAddEventWaitNode,\n ::cuGraphAddExternalSemaphoresSignalNode,\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddMemAllocNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a memory alloc node's parameters\n\n Returns the parameters of a memory alloc node \\p hNode in \\p params_out.\n The \\p poolProps and \\p accessDescs returned in \\p params_out, are owned by the\n node.  This memory remains valid until the node is destroyed.  The returned\n parameters must not be modified.\n\n \\param hNode      - Node to get the parameters for\n \\param params_out - Pointer to return the parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddMemAllocNode,\n ::cuGraphMemFreeNodeGetParams"]
    pub fn cuGraphMemAllocNodeGetParams(
        hNode: CUgraphNode,
        params_out: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a memory free node and adds it to a graph\n\n Creates a new memory free node and adds it to \\p hGraph with \\p numDependencies\n dependencies specified via \\p dependencies and arguments specified in \\p nodeParams.\n It is possible for \\p numDependencies to be 0, in which case the node will be placed\n at the root of the graph. \\p dependencies may not have any duplicate entries. A handle\n to the new node will be returned in \\p phGraphNode.\n\n \\param phGraphNode     - Returns newly created node\n \\param hGraph          - Graph to which to add the node\n \\param dependencies    - Dependencies of the node\n \\param numDependencies - Number of dependencies\n \\param dptr            - Address of memory to free\n\n ::cuGraphAddMemFreeNode will return ::CUDA_ERROR_INVALID_VALUE if the user attempts to free:\n - an allocation twice in the same graph.\n - an address that was not returned by an allocation node.\n - an invalid address.\n\n The following restrictions apply to graphs which contain allocation and/or memory free nodes:\n - Nodes and edges of the graph cannot be deleted.\n - The graph cannot be used in a child node.\n - Only one instantiation of the graph may exist at any point in time.\n - The graph cannot be cloned.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_NOT_SUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddMemAllocNode,\n ::cuGraphMemFreeNodeGetParams,\n ::cuDeviceGraphMemTrim,\n ::cuDeviceGetGraphMemAttribute,\n ::cuDeviceSetGraphMemAttribute,\n ::cuMemAllocAsync,\n ::cuMemFreeAsync,\n ::cuGraphCreate,\n ::cuGraphDestroyNode,\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddEventRecordNode,\n ::cuGraphAddEventWaitNode,\n ::cuGraphAddExternalSemaphoresSignalNode,\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphAddMemFreeNode(
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        dptr: CUdeviceptr,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a memory free node's parameters\n\n Returns the address of a memory free node \\p hNode in \\p dptr_out.\n\n \\param hNode    - Node to get the parameters for\n \\param dptr_out - Pointer to return the device address\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddMemFreeNode,\n ::cuGraphMemAllocNodeGetParams"]
    pub fn cuGraphMemFreeNodeGetParams(hNode: CUgraphNode, dptr_out: *mut CUdeviceptr) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Free unused memory that was cached on the specified device for use with graphs back to the OS.\n\n Blocks which are not in use by a graph that is either currently executing or scheduled to execute are\n freed back to the operating system.\n\n \\param device - The device for which cached memory should be freed.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_DEVICE\n\n \\sa\n ::cuGraphAddMemAllocNode,\n ::cuGraphAddMemFreeNode,\n ::cuDeviceSetGraphMemAttribute,\n ::cuDeviceGetGraphMemAttribute"]
    pub fn cuDeviceGraphMemTrim(device: CUdevice) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query asynchronous allocation attributes related to graphs\n\n Valid attributes are:\n\n - ::CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT: Amount of memory, in bytes, currently associated with graphs\n - ::CU_GRAPH_MEM_ATTR_USED_MEM_HIGH: High watermark of memory, in bytes, associated with graphs since the\n   last time it was reset.  High watermark can only be reset to zero.\n - ::CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT: Amount of memory, in bytes, currently allocated for use by\n   the CUDA graphs asynchronous allocator.\n - ::CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH: High watermark of memory, in bytes, currently allocated for use by\n   the CUDA graphs asynchronous allocator.\n\n \\param device - Specifies the scope of the query\n \\param attr - attribute to get\n \\param value - retrieved value\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_DEVICE\n\n \\sa\n ::cuDeviceSetGraphMemAttribute,\n ::cuGraphAddMemAllocNode,\n ::cuGraphAddMemFreeNode"]
    pub fn cuDeviceGetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Set asynchronous allocation attributes related to graphs\n\n Valid attributes are:\n\n - ::CU_GRAPH_MEM_ATTR_USED_MEM_HIGH: High watermark of memory, in bytes, associated with graphs since the\n   last time it was reset.  High watermark can only be reset to zero.\n - ::CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH: High watermark of memory, in bytes, currently allocated for use by\n   the CUDA graphs asynchronous allocator.\n\n \\param device - Specifies the scope of the query\n \\param attr - attribute to get\n \\param value - pointer to value to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_DEVICE\n\n \\sa\n ::cuDeviceGetGraphMemAttribute,\n ::cuGraphAddMemAllocNode,\n ::cuGraphAddMemFreeNode"]
    pub fn cuDeviceSetGraphMemAttribute(
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Clones a graph\n\n This function creates a copy of \\p originalGraph and returns it in \\p phGraphClone.\n All parameters are copied into the cloned graph. The original graph may be modified\n after this call without affecting the clone.\n\n Child graph nodes in the original graph are recursively copied into the clone.\n\n \\param phGraphClone  - Returns newly created cloned graph\n \\param originalGraph - Graph to clone\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OUT_OF_MEMORY\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphCreate,\n ::cuGraphNodeFindInClone"]
    pub fn cuGraphClone(phGraphClone: *mut CUgraph, originalGraph: CUgraph) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Finds a cloned version of a node\n\n This function returns the node in \\p hClonedGraph corresponding to \\p hOriginalNode\n in the original graph.\n\n \\p hClonedGraph must have been cloned from \\p hOriginalGraph via ::cuGraphClone.\n \\p hOriginalNode must have been in \\p hOriginalGraph at the time of the call to\n ::cuGraphClone, and the corresponding cloned node in \\p hClonedGraph must not have\n been removed. The cloned node is then returned via \\p phClonedNode.\n\n \\param phNode  - Returns handle to the cloned node\n \\param hOriginalNode - Handle to the original node\n \\param hClonedGraph - Cloned graph to query\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphClone"]
    pub fn cuGraphNodeFindInClone(
        phNode: *mut CUgraphNode,
        hOriginalNode: CUgraphNode,
        hClonedGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a node's type\n\n Returns the node type of \\p hNode in \\p type.\n\n \\param hNode - Node to query\n \\param type  - Pointer to return the node type\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphGetNodes,\n ::cuGraphGetRootNodes,\n ::cuGraphChildGraphNodeGetGraph,\n ::cuGraphKernelNodeGetParams,\n ::cuGraphKernelNodeSetParams,\n ::cuGraphHostNodeGetParams,\n ::cuGraphHostNodeSetParams,\n ::cuGraphMemcpyNodeGetParams,\n ::cuGraphMemcpyNodeSetParams,\n ::cuGraphMemsetNodeGetParams,\n ::cuGraphMemsetNodeSetParams"]
    pub fn cuGraphNodeGetType(hNode: CUgraphNode, type_: *mut CUgraphNodeType) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a graph's nodes\n\n Returns a list of \\p hGraph's nodes. \\p nodes may be NULL, in which case this\n function will return the number of nodes in \\p numNodes. Otherwise,\n \\p numNodes entries will be filled in. If \\p numNodes is higher than the actual\n number of nodes, the remaining entries in \\p nodes will be set to NULL, and the\n number of nodes actually obtained will be returned in \\p numNodes.\n\n \\param hGraph   - Graph to query\n \\param nodes    - Pointer to return the nodes\n \\param numNodes - See description\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphCreate,\n ::cuGraphGetRootNodes,\n ::cuGraphGetEdges,\n ::cuGraphNodeGetType,\n ::cuGraphNodeGetDependencies,\n ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphGetNodes(
        hGraph: CUgraph,
        nodes: *mut CUgraphNode,
        numNodes: *mut usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a graph's root nodes\n\n Returns a list of \\p hGraph's root nodes. \\p rootNodes may be NULL, in which case this\n function will return the number of root nodes in \\p numRootNodes. Otherwise,\n \\p numRootNodes entries will be filled in. If \\p numRootNodes is higher than the actual\n number of root nodes, the remaining entries in \\p rootNodes will be set to NULL, and the\n number of nodes actually obtained will be returned in \\p numRootNodes.\n\n \\param hGraph       - Graph to query\n \\param rootNodes    - Pointer to return the root nodes\n \\param numRootNodes - See description\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphCreate,\n ::cuGraphGetNodes,\n ::cuGraphGetEdges,\n ::cuGraphNodeGetType,\n ::cuGraphNodeGetDependencies,\n ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphGetRootNodes(
        hGraph: CUgraph,
        rootNodes: *mut CUgraphNode,
        numRootNodes: *mut usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a graph's dependency edges\n\n Returns a list of \\p hGraph's dependency edges. Edges are returned via corresponding\n indices in \\p from and \\p to; that is, the node in \\p to[i] has a dependency on the\n node in \\p from[i]. \\p from and \\p to may both be NULL, in which\n case this function only returns the number of edges in \\p numEdges. Otherwise,\n \\p numEdges entries will be filled in. If \\p numEdges is higher than the actual\n number of edges, the remaining entries in \\p from and \\p to will be set to NULL, and\n the number of edges actually returned will be written to \\p numEdges.\n\n \\param hGraph   - Graph to get the edges from\n \\param from     - Location to return edge endpoints\n \\param to       - Location to return edge endpoints\n \\param numEdges - See description\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphGetNodes,\n ::cuGraphGetRootNodes,\n ::cuGraphAddDependencies,\n ::cuGraphRemoveDependencies,\n ::cuGraphNodeGetDependencies,\n ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphGetEdges(
        hGraph: CUgraph,
        from: *mut CUgraphNode,
        to: *mut CUgraphNode,
        numEdges: *mut usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a node's dependencies\n\n Returns a list of \\p node's dependencies. \\p dependencies may be NULL, in which case this\n function will return the number of dependencies in \\p numDependencies. Otherwise,\n \\p numDependencies entries will be filled in. If \\p numDependencies is higher than the actual\n number of dependencies, the remaining entries in \\p dependencies will be set to NULL, and the\n number of nodes actually obtained will be returned in \\p numDependencies.\n\n \\param hNode           - Node to query\n \\param dependencies    - Pointer to return the dependencies\n \\param numDependencies - See description\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphNodeGetDependentNodes,\n ::cuGraphGetNodes,\n ::cuGraphGetRootNodes,\n ::cuGraphGetEdges,\n ::cuGraphAddDependencies,\n ::cuGraphRemoveDependencies"]
    pub fn cuGraphNodeGetDependencies(
        hNode: CUgraphNode,
        dependencies: *mut CUgraphNode,
        numDependencies: *mut usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a node's dependent nodes\n\n Returns a list of \\p node's dependent nodes. \\p dependentNodes may be NULL, in which\n case this function will return the number of dependent nodes in \\p numDependentNodes.\n Otherwise, \\p numDependentNodes entries will be filled in. If \\p numDependentNodes is\n higher than the actual number of dependent nodes, the remaining entries in\n \\p dependentNodes will be set to NULL, and the number of nodes actually obtained will\n be returned in \\p numDependentNodes.\n\n \\param hNode             - Node to query\n \\param dependentNodes    - Pointer to return the dependent nodes\n \\param numDependentNodes - See description\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphNodeGetDependencies,\n ::cuGraphGetNodes,\n ::cuGraphGetRootNodes,\n ::cuGraphGetEdges,\n ::cuGraphAddDependencies,\n ::cuGraphRemoveDependencies"]
    pub fn cuGraphNodeGetDependentNodes(
        hNode: CUgraphNode,
        dependentNodes: *mut CUgraphNode,
        numDependentNodes: *mut usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Adds dependency edges to a graph\n\n The number of dependencies to be added is defined by \\p numDependencies\n Elements in \\p from and \\p to at corresponding indices define a dependency.\n Each node in \\p from and \\p to must belong to \\p hGraph.\n\n If \\p numDependencies is 0, elements in \\p from and \\p to will be ignored.\n Specifying an existing dependency will return an error.\n\n \\param hGraph - Graph to which dependencies are added\n \\param from - Array of nodes that provide the dependencies\n \\param to - Array of dependent nodes\n \\param numDependencies - Number of dependencies to be added\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphRemoveDependencies,\n ::cuGraphGetEdges,\n ::cuGraphNodeGetDependencies,\n ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphAddDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Removes dependency edges from a graph\n\n The number of \\p dependencies to be removed is defined by \\p numDependencies.\n Elements in \\p from and \\p to at corresponding indices define a dependency.\n Each node in \\p from and \\p to must belong to \\p hGraph.\n\n If \\p numDependencies is 0, elements in \\p from and \\p to will be ignored.\n Specifying a non-existing dependency will return an error.\n\n Dependencies cannot be removed from graphs which contain allocation or free nodes.\n Any attempt to do so will return an error.\n\n \\param hGraph - Graph from which to remove dependencies\n \\param from - Array of nodes that provide the dependencies\n \\param to - Array of dependent nodes\n \\param numDependencies - Number of dependencies to be removed\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddDependencies,\n ::cuGraphGetEdges,\n ::cuGraphNodeGetDependencies,\n ::cuGraphNodeGetDependentNodes"]
    pub fn cuGraphRemoveDependencies(
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Remove a node from the graph\n\n Removes \\p hNode from its graph. This operation also severs any dependencies of other nodes\n on \\p hNode and vice versa.\n\n Nodes which belong to a graph which contains allocation or free nodes cannot be destroyed.\n Any attempt to do so will return an error.\n\n \\param hNode  - Node to remove\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddChildGraphNode,\n ::cuGraphAddEmptyNode,\n ::cuGraphAddKernelNode,\n ::cuGraphAddHostNode,\n ::cuGraphAddMemcpyNode,\n ::cuGraphAddMemsetNode"]
    pub fn cuGraphDestroyNode(hNode: CUgraphNode) -> CUresult;
}
extern "C" {
    pub fn cuGraphInstantiateWithFlags(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        flags: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates an executable graph from a graph\n\n Instantiates \\p hGraph as an executable graph according to the \\p instantiateParams structure.\n The graph is validated for any structural constraints or intra-node constraints\n which were not previously validated. If instantiation is successful, a handle to\n the instantiated graph is returned in \\p phGraphExec.\n\n \\p instantiateParams controls the behavior of instantiation and subsequent\n graph launches, as well as returning more detailed information in the event of an error.\n ::CUDA_GRAPH_INSTANTIATE_PARAMS is defined as:\n\n \\code\ntypedef struct {\ncuuint64_t flags;\nCUstream hUploadStream;\nCUgraphNode hErrNode_out;\nCUgraphInstantiateResult result_out;\n} CUDA_GRAPH_INSTANTIATE_PARAMS;\n \\endcode\n\n The \\p flags field controls the behavior of instantiation and subsequent\n graph launches. Valid flags are:\n\n - ::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH, which configures a\n graph containing memory allocation nodes to automatically free any\n unfreed memory allocations before the graph is relaunched.\n\n - ::CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD, which will perform an upload of the graph\n into \\p hUploadStream once the graph has been instantiated.\n\n - ::CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH, which configures the graph for launch\n from the device. If this flag is passed, the executable graph handle returned can be\n used to launch the graph from both the host and device. This flag can only be used\n on platforms which support unified addressing. This flag cannot be used in\n conjunction with ::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH.\n\n - ::CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY, which causes the graph\n to use the priorities from the per-node attributes rather than the priority\n of the launch stream during execution. Note that priorities are only available\n on kernel nodes, and are copied from stream priority during stream capture.\n\n If \\p hGraph contains any allocation or free nodes, there can be at most one\n executable graph in existence for that graph at a time. An attempt to instantiate a\n second executable graph before destroying the first with ::cuGraphExecDestroy will\n result in an error.\n\n If \\p hGraph contains kernels which call device-side cudaGraphLaunch() from multiple\n contexts, this will result in an error.\n\n Graphs instantiated for launch on the device have additional restrictions which do not\n apply to host graphs:\n\n - The graph's nodes must reside on a single context.\n - The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.\n   Operation-specific restrictions are outlined below.\n - Kernel nodes:\n   - Use of CUDA Dynamic Parallelism is not permitted.\n   - Cooperative launches are permitted as long as MPS is not in use.\n - Memcpy nodes:\n   - Only copies involving device memory and/or pinned device-mapped host memory are permitted.\n   - Copies involving CUDA arrays are not permitted.\n   - Both operands must be accessible from the current context, and the current context must\n     match the context of other nodes in the graph.\n\n In the event of an error, the \\p result_out and \\p hErrNode_out fields will contain more\n information about the nature of the error. Possible error reporting includes:\n\n - ::CUDA_GRAPH_INSTANTIATE_ERROR, if passed an invalid value or if an unexpected error occurred\n   which is described by the return value of the function. \\p hErrNode_out will be set to NULL.\n - ::CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE, if the graph structure is invalid. \\p hErrNode_out\n   will be set to one of the offending nodes.\n - ::CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED, if the graph is instantiated for device\n   launch but contains a node of an unsupported node type, or a node which performs unsupported\n   operations, such as use of CUDA dynamic parallelism within a kernel node. \\p hErrNode_out will\n   be set to this node.\n - ::CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED, if the graph is instantiated for device\n   launch but a nodes context differs from that of another node. This error can also be returned\n   if a graph is not instantiated for device launch and it contains kernels which call device-side\n   cudaGraphLaunch() from multiple contexts. \\p hErrNode_out will be set to this node.\n\n If instantiation is successful, \\p result_out will be set to ::CUDA_GRAPH_INSTANTIATE_SUCCESS,\n and \\p hErrNode_out will be set to NULL.\n\n \\param phGraphExec       - Returns instantiated graph\n \\param hGraph            - Graph to instantiate\n \\param instantiateParams - Instantiation parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphCreate,\n ::cuGraphInstantiate,\n ::cuGraphExecDestroy"]
    pub fn cuGraphInstantiateWithParams(
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        instantiateParams: *mut CUDA_GRAPH_INSTANTIATE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query the instantiation flags of an executable graph\n\n Returns the flags that were passed to instantiation for the given executable graph.\n ::CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD will not be returned by this API as it does\n not affect the resulting executable graph.\n\n \\param hGraphExec - The executable graph to query\n \\param flags      - Returns the instantiation flags\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphInstantiate,\n ::cuGraphInstantiateWithParams"]
    pub fn cuGraphExecGetFlags(hGraphExec: CUgraphExec, flags: *mut cuuint64_t) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecKernelNodeSetParams_v2(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for a memcpy node in the given graphExec.\n\n Updates the work represented by \\p hNode in \\p hGraphExec as though \\p hNode had\n contained \\p copyParams at instantiation.  hNode must remain in the graph which was\n used to instantiate \\p hGraphExec.  Changed edges to and from hNode are ignored.\n\n The source and destination memory in \\p copyParams must be allocated from the same\n contexts as the original source and destination memory.  Both the instantiation-time\n memory operands and the memory operands in \\p copyParams must be 1-dimensional.\n Zero-length operations are not supported.\n\n The modifications only affect future launches of \\p hGraphExec.  Already enqueued\n or running launches of \\p hGraphExec are not affected by this call.  hNode is also\n not modified by this call.\n\n Returns CUDA_ERROR_INVALID_VALUE if the memory operands' mappings changed or\n either the original or new memory operands are multidimensional.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - Memcpy node from the graph which was used to instantiate graphExec\n \\param copyParams - The updated parameters to set\n \\param ctx        - Context on which to run the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddMemcpyNode,\n ::cuGraphMemcpyNodeSetParams,\n ::cuGraphExecKernelNodeSetParams,\n ::cuGraphExecMemsetNodeSetParams,\n ::cuGraphExecHostNodeSetParams,\n ::cuGraphExecChildGraphNodeSetParams,\n ::cuGraphExecEventRecordNodeSetEvent,\n ::cuGraphExecEventWaitNodeSetEvent,\n ::cuGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cuGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecMemcpyNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for a memset node in the given graphExec.\n\n Updates the work represented by \\p hNode in \\p hGraphExec as though \\p hNode had\n contained \\p memsetParams at instantiation.  hNode must remain in the graph which was\n used to instantiate \\p hGraphExec.  Changed edges to and from hNode are ignored.\n\n The destination memory in \\p memsetParams must be allocated from the same\n contexts as the original destination memory.  Both the instantiation-time\n memory operand and the memory operand in \\p memsetParams must be 1-dimensional.\n Zero-length operations are not supported.\n\n The modifications only affect future launches of \\p hGraphExec.  Already enqueued\n or running launches of \\p hGraphExec are not affected by this call.  hNode is also\n not modified by this call.\n\n Returns CUDA_ERROR_INVALID_VALUE if the memory operand's mappings changed or\n either the original or new memory operand are multidimensional.\n\n \\param hGraphExec   - The executable graph in which to set the specified node\n \\param hNode        - Memset node from the graph which was used to instantiate graphExec\n \\param memsetParams - The updated parameters to set\n \\param ctx          - Context on which to run the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddMemsetNode,\n ::cuGraphMemsetNodeSetParams,\n ::cuGraphExecKernelNodeSetParams,\n ::cuGraphExecMemcpyNodeSetParams,\n ::cuGraphExecHostNodeSetParams,\n ::cuGraphExecChildGraphNodeSetParams,\n ::cuGraphExecEventRecordNodeSetEvent,\n ::cuGraphExecEventWaitNodeSetEvent,\n ::cuGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cuGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecMemsetNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for a host node in the given graphExec.\n\n Updates the work represented by \\p hNode in \\p hGraphExec as though \\p hNode had\n contained \\p nodeParams at instantiation.  hNode must remain in the graph which was\n used to instantiate \\p hGraphExec.  Changed edges to and from hNode are ignored.\n\n The modifications only affect future launches of \\p hGraphExec.  Already enqueued\n or running launches of \\p hGraphExec are not affected by this call.  hNode is also\n not modified by this call.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - Host node from the graph which was used to instantiate graphExec\n \\param nodeParams - The updated parameters to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddHostNode,\n ::cuGraphHostNodeSetParams,\n ::cuGraphExecKernelNodeSetParams,\n ::cuGraphExecMemcpyNodeSetParams,\n ::cuGraphExecMemsetNodeSetParams,\n ::cuGraphExecChildGraphNodeSetParams,\n ::cuGraphExecEventRecordNodeSetEvent,\n ::cuGraphExecEventWaitNodeSetEvent,\n ::cuGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cuGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecHostNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Updates node parameters in the child graph node in the given graphExec.\n\n Updates the work represented by \\p hNode in \\p hGraphExec as though the nodes contained\n in \\p hNode's graph had the parameters contained in \\p childGraph's nodes at instantiation.\n \\p hNode must remain in the graph which was used to instantiate \\p hGraphExec.\n Changed edges to and from \\p hNode are ignored.\n\n The modifications only affect future launches of \\p hGraphExec.  Already enqueued\n or running launches of \\p hGraphExec are not affected by this call.  \\p hNode is also\n not modified by this call.\n\n The topology of \\p childGraph, as well as the node insertion order,  must match that\n of the graph contained in \\p hNode.  See ::cuGraphExecUpdate() for a list of restrictions\n on what can be updated in an instantiated graph.  The update is recursive, so child graph\n nodes contained within the top level child graph will also be updated.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - Host node from the graph which was used to instantiate graphExec\n \\param childGraph - The graph supplying the updated parameters\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddChildGraphNode,\n ::cuGraphChildGraphNodeGetGraph,\n ::cuGraphExecKernelNodeSetParams,\n ::cuGraphExecMemcpyNodeSetParams,\n ::cuGraphExecMemsetNodeSetParams,\n ::cuGraphExecHostNodeSetParams,\n ::cuGraphExecEventRecordNodeSetEvent,\n ::cuGraphExecEventWaitNodeSetEvent,\n ::cuGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cuGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecChildGraphNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        childGraph: CUgraph,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the event for an event record node in the given graphExec\n\n Sets the event of an event record node in an executable graph \\p hGraphExec.\n The node is identified by the corresponding node \\p hNode in the\n non-executable graph, from which the executable graph was instantiated.\n\n The modifications only affect future launches of \\p hGraphExec. Already\n enqueued or running launches of \\p hGraphExec are not affected by this call.\n \\p hNode is also not modified by this call.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - event record node from the graph from which graphExec was instantiated\n \\param event      - Updated event to use\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddEventRecordNode,\n ::cuGraphEventRecordNodeGetEvent,\n ::cuGraphEventWaitNodeSetEvent,\n ::cuEventRecordWithFlags,\n ::cuStreamWaitEvent,\n ::cuGraphExecKernelNodeSetParams,\n ::cuGraphExecMemcpyNodeSetParams,\n ::cuGraphExecMemsetNodeSetParams,\n ::cuGraphExecHostNodeSetParams,\n ::cuGraphExecChildGraphNodeSetParams,\n ::cuGraphExecEventWaitNodeSetEvent,\n ::cuGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cuGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecEventRecordNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the event for an event wait node in the given graphExec\n\n Sets the event of an event wait node in an executable graph \\p hGraphExec.\n The node is identified by the corresponding node \\p hNode in the\n non-executable graph, from which the executable graph was instantiated.\n\n The modifications only affect future launches of \\p hGraphExec. Already\n enqueued or running launches of \\p hGraphExec are not affected by this call.\n \\p hNode is also not modified by this call.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - event wait node from the graph from which graphExec was instantiated\n \\param event      - Updated event to use\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddEventWaitNode,\n ::cuGraphEventWaitNodeGetEvent,\n ::cuGraphEventRecordNodeSetEvent,\n ::cuEventRecordWithFlags,\n ::cuStreamWaitEvent,\n ::cuGraphExecKernelNodeSetParams,\n ::cuGraphExecMemcpyNodeSetParams,\n ::cuGraphExecMemsetNodeSetParams,\n ::cuGraphExecHostNodeSetParams,\n ::cuGraphExecChildGraphNodeSetParams,\n ::cuGraphExecEventRecordNodeSetEvent,\n ::cuGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cuGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecEventWaitNodeSetEvent(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for an external semaphore signal node in the given graphExec\n\n Sets the parameters of an external semaphore signal node in an executable graph \\p hGraphExec.\n The node is identified by the corresponding node \\p hNode in the\n non-executable graph, from which the executable graph was instantiated.\n\n \\p hNode must not have been removed from the original graph.\n\n The modifications only affect future launches of \\p hGraphExec. Already\n enqueued or running launches of \\p hGraphExec are not affected by this call.\n \\p hNode is also not modified by this call.\n\n Changing \\p nodeParams->numExtSems is not supported.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - semaphore signal node from the graph from which graphExec was instantiated\n \\param nodeParams - Updated Parameters to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddExternalSemaphoresSignalNode,\n ::cuImportExternalSemaphore,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync,\n ::cuGraphExecKernelNodeSetParams,\n ::cuGraphExecMemcpyNodeSetParams,\n ::cuGraphExecMemsetNodeSetParams,\n ::cuGraphExecHostNodeSetParams,\n ::cuGraphExecChildGraphNodeSetParams,\n ::cuGraphExecEventRecordNodeSetEvent,\n ::cuGraphExecEventWaitNodeSetEvent,\n ::cuGraphExecExternalSemaphoresWaitNodeSetParams,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the parameters for an external semaphore wait node in the given graphExec\n\n Sets the parameters of an external semaphore wait node in an executable graph \\p hGraphExec.\n The node is identified by the corresponding node \\p hNode in the\n non-executable graph, from which the executable graph was instantiated.\n\n \\p hNode must not have been removed from the original graph.\n\n The modifications only affect future launches of \\p hGraphExec. Already\n enqueued or running launches of \\p hGraphExec are not affected by this call.\n \\p hNode is also not modified by this call.\n\n Changing \\p nodeParams->numExtSems is not supported.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - semaphore wait node from the graph from which graphExec was instantiated\n \\param nodeParams - Updated Parameters to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphAddExternalSemaphoresWaitNode,\n ::cuImportExternalSemaphore,\n ::cuSignalExternalSemaphoresAsync,\n ::cuWaitExternalSemaphoresAsync,\n ::cuGraphExecKernelNodeSetParams,\n ::cuGraphExecMemcpyNodeSetParams,\n ::cuGraphExecMemsetNodeSetParams,\n ::cuGraphExecHostNodeSetParams,\n ::cuGraphExecChildGraphNodeSetParams,\n ::cuGraphExecEventRecordNodeSetEvent,\n ::cuGraphExecEventWaitNodeSetEvent,\n ::cuGraphExecExternalSemaphoresSignalNodeSetParams,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate"]
    pub fn cuGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Enables or disables the specified node in the given graphExec\n\n Sets \\p hNode to be either enabled or disabled. Disabled nodes are functionally equivalent\n to empty nodes until they are reenabled. Existing node parameters are not affected by\n disabling/enabling the node.\n\n The node is identified by the corresponding node \\p hNode in the non-executable\n graph, from which the executable graph was instantiated.\n\n \\p hNode must not have been removed from the original graph.\n\n The modifications only affect future launches of \\p hGraphExec. Already\n enqueued or running launches of \\p hGraphExec are not affected by this call.\n \\p hNode is also not modified by this call.\n\n \\note Currently only kernel, memset and memcpy nodes are supported.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - Node from the graph from which graphExec was instantiated\n \\param isEnabled  - Node is enabled if != 0, otherwise the node is disabled\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphNodeGetEnabled,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate\n ::cuGraphLaunch"]
    pub fn cuGraphNodeSetEnabled(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        isEnabled: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Query whether a node in the given graphExec is enabled\n\n Sets isEnabled to 1 if \\p hNode is enabled, or 0 if \\p hNode is disabled.\n\n The node is identified by the corresponding node \\p hNode in the non-executable\n graph, from which the executable graph was instantiated.\n\n \\p hNode must not have been removed from the original graph.\n\n \\note Currently only kernel, memset and memcpy nodes are supported.\n\n \\param hGraphExec - The executable graph in which to set the specified node\n \\param hNode      - Node from the graph from which graphExec was instantiated\n \\param isEnabled  - Location to return the enabled status of the node\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphNodeSetEnabled,\n ::cuGraphExecUpdate,\n ::cuGraphInstantiate\n ::cuGraphLaunch"]
    pub fn cuGraphNodeGetEnabled(
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        isEnabled: *mut ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Uploads an executable graph in a stream\n\n Uploads \\p hGraphExec to the device in \\p hStream without executing it. Uploads of\n the same \\p hGraphExec will be serialized. Each upload is ordered behind both any\n previous work in \\p hStream and any previous launches of \\p hGraphExec.\n Uses memory cached by \\p stream to back the allocations owned by \\p hGraphExec.\n\n \\param hGraphExec - Executable graph to upload\n \\param hStream    - Stream in which to upload the graph\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphInstantiate,\n ::cuGraphLaunch,\n ::cuGraphExecDestroy"]
    pub fn cuGraphUpload(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Launches an executable graph in a stream\n\n Executes \\p hGraphExec in \\p hStream. Only one instance of \\p hGraphExec may be executing\n at a time. Each launch is ordered behind both any previous work in \\p hStream\n and any previous launches of \\p hGraphExec. To execute a graph concurrently, it must be\n instantiated multiple times into multiple executable graphs.\n\n If any allocations created by \\p hGraphExec remain unfreed (from a previous launch) and\n \\p hGraphExec was not instantiated with ::CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH,\n the launch will fail with ::CUDA_ERROR_INVALID_VALUE.\n\n \\param hGraphExec - Executable graph to launch\n \\param hStream    - Stream in which to launch the graph\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphInstantiate,\n ::cuGraphUpload,\n ::cuGraphExecDestroy"]
    pub fn cuGraphLaunch(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys an executable graph\n\n Destroys the executable graph specified by \\p hGraphExec, as well\n as all of its executable nodes. If the executable graph is\n in-flight, it will not be terminated, but rather freed\n asynchronously on completion.\n\n \\param hGraphExec - Executable graph to destroy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphInstantiate,\n ::cuGraphUpload,\n ::cuGraphLaunch"]
    pub fn cuGraphExecDestroy(hGraphExec: CUgraphExec) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a graph\n\n Destroys the graph specified by \\p hGraph, as well as all of its nodes.\n\n \\param hGraph - Graph to destroy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_VALUE\n \\note_graph_thread_safety\n \\notefnerr\n\n \\sa\n ::cuGraphCreate"]
    pub fn cuGraphDestroy(hGraph: CUgraph) -> CUresult;
}
extern "C" {
    pub fn cuGraphExecUpdate_v2(
        hGraphExec: CUgraphExec,
        hGraph: CUgraph,
        resultInfo: *mut CUgraphExecUpdateResultInfo,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Copies attributes from source node to destination node.\n\n Copies attributes from source node \\p src to destination node \\p dst.\n Both node must have the same context.\n\n \\param[out] dst Destination node\n \\param[in] src Source node\n For list of attributes see ::CUkernelNodeAttrID\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa\n ::CUaccessPolicyWindow"]
    pub fn cuGraphKernelNodeCopyAttributes(dst: CUgraphNode, src: CUgraphNode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries node attribute.\n\n Queries attribute \\p attr from node \\p hNode and stores it in corresponding\n member of \\p value_out.\n\n \\param[in] hNode\n \\param[in] attr\n \\param[out] value_out\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa\n ::CUaccessPolicyWindow"]
    pub fn cuGraphKernelNodeGetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value_out: *mut CUkernelNodeAttrValue,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets node attribute.\n\n Sets attribute \\p attr on node \\p hNode from corresponding attribute of\n \\p value.\n\n \\param[out] hNode\n \\param[in] attr\n \\param[out] value\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE\n \\notefnerr\n\n \\sa\n ::CUaccessPolicyWindow"]
    pub fn cuGraphKernelNodeSetAttribute(
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value: *const CUkernelNodeAttrValue,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Write a DOT file describing graph structure\n\n Using the provided \\p hGraph, write to \\p path a DOT formatted description of the graph.\n By default this includes the graph topology, node types, node id, kernel names and memcpy direction.\n \\p flags can be specified to write more detailed information about each node type such as\n parameter values, kernel attributes, node and function handles.\n\n \\param hGraph - The graph to create a DOT file from\n \\param path   - The path to write the DOT file to\n \\param flags  - Flags from CUgraphDebugDot_flags for specifying which additional node information to write\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_OPERATING_SYSTEM"]
    pub fn cuGraphDebugDotPrint(
        hGraph: CUgraph,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a user object\n\n Create a user object with the specified destructor callback and initial reference count. The\n initial references are owned by the caller.\n\n Destructor callbacks cannot make CUDA API calls and should avoid blocking behavior, as they\n are executed by a shared internal thread. Another thread may be signaled to perform such\n actions, if it does not block forward progress of tasks scheduled through CUDA.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param object_out      - Location to return the user object handle\n \\param ptr             - The pointer to pass to the destroy function\n \\param destroy         - Callback to free the user object when it is no longer in use\n \\param initialRefcount - The initial refcount to create the object with, typically 1. The\n                          initial references are owned by the calling thread.\n \\param flags           - Currently it is required to pass ::CU_USER_OBJECT_NO_DESTRUCTOR_SYNC,\n                          which is the only defined flag. This indicates that the destroy\n                          callback cannot be waited on by any CUDA API. Users requiring\n                          synchronization of the callback should signal its completion\n                          manually.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuUserObjectRetain,\n ::cuUserObjectRelease,\n ::cuGraphRetainUserObject,\n ::cuGraphReleaseUserObject,\n ::cuGraphCreate"]
    pub fn cuUserObjectCreate(
        object_out: *mut CUuserObject,
        ptr: *mut ::std::os::raw::c_void,
        destroy: CUhostFn,
        initialRefcount: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retain a reference to a user object\n\n Retains new references to a user object. The new references are owned by the caller.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param object - The object to retain\n \\param count  - The number of references to retain, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuUserObjectCreate,\n ::cuUserObjectRelease,\n ::cuGraphRetainUserObject,\n ::cuGraphReleaseUserObject,\n ::cuGraphCreate"]
    pub fn cuUserObjectRetain(object: CUuserObject, count: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Release a reference to a user object\n\n Releases user object references owned by the caller. The object's destructor is invoked if\n the reference count reaches zero.\n\n It is undefined behavior to release references not owned by the caller, or to use a user\n object handle after all references are released.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param object - The object to release\n \\param count  - The number of references to release, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuUserObjectCreate,\n ::cuUserObjectRetain,\n ::cuGraphRetainUserObject,\n ::cuGraphReleaseUserObject,\n ::cuGraphCreate"]
    pub fn cuUserObjectRelease(object: CUuserObject, count: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Retain a reference to a user object from a graph\n\n Creates or moves user object references that will be owned by a CUDA graph.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param graph  - The graph to associate the reference with\n \\param object - The user object to retain a reference for\n \\param count  - The number of references to add to the graph, typically 1. Must be\n                 nonzero and not larger than INT_MAX.\n \\param flags  - The optional flag ::CU_GRAPH_USER_OBJECT_MOVE transfers references\n                 from the calling thread, rather than create new references. Pass 0\n                 to create new references.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuUserObjectCreate,\n ::cuUserObjectRetain,\n ::cuUserObjectRelease,\n ::cuGraphReleaseUserObject,\n ::cuGraphCreate"]
    pub fn cuGraphRetainUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Release a user object reference from a graph\n\n Releases user object references owned by a graph.\n\n See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.\n\n \\param graph  - The graph that will release the reference\n \\param object - The user object to release a reference for\n \\param count  - The number of references to release, typically 1. Must be nonzero\n                 and not larger than INT_MAX.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuUserObjectCreate,\n ::cuUserObjectRetain,\n ::cuUserObjectRelease,\n ::cuGraphRetainUserObject,\n ::cuGraphCreate"]
    pub fn cuGraphReleaseUserObject(
        graph: CUgraph,
        object: CUuserObject,
        count: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns occupancy of a function\n\n Returns in \\p *numBlocks the number of the maximum active blocks per\n streaming multiprocessor.\n\n \\param numBlocks       - Returned occupancy\n \\param func            - Kernel for which occupancy is calculated\n \\param blockSize       - Block size the kernel is intended to be launched with\n \\param dynamicSMemSize - Per-block dynamic shared memory usage intended, in bytes\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa\n ::cudaOccupancyMaxActiveBlocksPerMultiprocessor"]
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns occupancy of a function\n\n Returns in \\p *numBlocks the number of the maximum active blocks per\n streaming multiprocessor.\n\n The \\p Flags parameter controls how special cases are handled. The\n valid flags are:\n\n - ::CU_OCCUPANCY_DEFAULT, which maintains the default behavior as\n   ::cuOccupancyMaxActiveBlocksPerMultiprocessor;\n\n - ::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE, which suppresses the\n   default behavior on platform where global caching affects\n   occupancy. On such platforms, if caching is enabled, but\n   per-block SM resource usage would result in zero occupancy, the\n   occupancy calculator will calculate the occupancy as if caching\n   is disabled. Setting ::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE makes\n   the occupancy calculator to return 0 in such cases. More information\n   can be found about this feature in the \"Unified L1/Texture Cache\"\n   section of the Maxwell tuning guide.\n\n \\param numBlocks       - Returned occupancy\n \\param func            - Kernel for which occupancy is calculated\n \\param blockSize       - Block size the kernel is intended to be launched with\n \\param dynamicSMemSize - Per-block dynamic shared memory usage intended, in bytes\n \\param flags           - Requested behavior for the occupancy calculator\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa\n ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags"]
    pub fn cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSize: ::std::os::raw::c_int,
        dynamicSMemSize: usize,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Suggest a launch configuration with reasonable occupancy\n\n Returns in \\p *blockSize a reasonable block size that can achieve\n the maximum occupancy (or, the maximum number of active warps with\n the fewest blocks per multiprocessor), and in \\p *minGridSize the\n minimum grid size to achieve the maximum occupancy.\n\n If \\p blockSizeLimit is 0, the configurator will use the maximum\n block size permitted by the device / function instead.\n\n If per-block dynamic shared memory allocation is not needed, the\n user should leave both \\p blockSizeToDynamicSMemSize and \\p\n dynamicSMemSize as 0.\n\n If per-block dynamic shared memory allocation is needed, then if\n the dynamic shared memory size is constant regardless of block\n size, the size should be passed through \\p dynamicSMemSize, and \\p\n blockSizeToDynamicSMemSize should be NULL.\n\n Otherwise, if the per-block dynamic shared memory size varies with\n different block sizes, the user needs to provide a unary function\n through \\p blockSizeToDynamicSMemSize that computes the dynamic\n shared memory needed by \\p func for any given block size. \\p\n dynamicSMemSize is ignored. An example signature is:\n\n \\code\n    // Take block size, returns dynamic shared memory needed\n    size_t blockToSmem(int blockSize);\n \\endcode\n\n \\param minGridSize - Returned minimum grid size needed to achieve the maximum occupancy\n \\param blockSize   - Returned maximum block size that can achieve the maximum occupancy\n \\param func        - Kernel for which launch configuration is calculated\n \\param blockSizeToDynamicSMemSize - A function that calculates how much per-block dynamic shared memory \\p func uses based on the block size\n \\param dynamicSMemSize - Dynamic shared memory usage intended, in bytes\n \\param blockSizeLimit  - The maximum block size \\p func is designed to handle\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa\n ::cudaOccupancyMaxPotentialBlockSize"]
    pub fn cuOccupancyMaxPotentialBlockSize(
        minGridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: usize,
        blockSizeLimit: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Suggest a launch configuration with reasonable occupancy\n\n An extended version of ::cuOccupancyMaxPotentialBlockSize. In\n addition to arguments passed to ::cuOccupancyMaxPotentialBlockSize,\n ::cuOccupancyMaxPotentialBlockSizeWithFlags also takes a \\p Flags\n parameter.\n\n The \\p Flags parameter controls how special cases are handled. The\n valid flags are:\n\n - ::CU_OCCUPANCY_DEFAULT, which maintains the default behavior as\n   ::cuOccupancyMaxPotentialBlockSize;\n\n - ::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE, which suppresses the\n   default behavior on platform where global caching affects\n   occupancy. On such platforms, the launch configurations that\n   produces maximal occupancy might not support global\n   caching. Setting ::CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE\n   guarantees that the the produced launch configuration is global\n   caching compatible at a potential cost of occupancy. More information\n   can be found about this feature in the \"Unified L1/Texture Cache\"\n   section of the Maxwell tuning guide.\n\n \\param minGridSize - Returned minimum grid size needed to achieve the maximum occupancy\n \\param blockSize   - Returned maximum block size that can achieve the maximum occupancy\n \\param func        - Kernel for which launch configuration is calculated\n \\param blockSizeToDynamicSMemSize - A function that calculates how much per-block dynamic shared memory \\p func uses based on the block size\n \\param dynamicSMemSize - Dynamic shared memory usage intended, in bytes\n \\param blockSizeLimit  - The maximum block size \\p func is designed to handle\n \\param flags       - Options\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa\n ::cudaOccupancyMaxPotentialBlockSizeWithFlags"]
    pub fn cuOccupancyMaxPotentialBlockSizeWithFlags(
        minGridSize: *mut ::std::os::raw::c_int,
        blockSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: usize,
        blockSizeLimit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns dynamic shared memory available per block when launching \\p numBlocks blocks on SM\n\n Returns in \\p *dynamicSmemSize the maximum size of dynamic shared memory to allow \\p numBlocks blocks per SM.\n\n \\param dynamicSmemSize - Returned maximum dynamic shared memory\n \\param func            - Kernel function for which occupancy is calculated\n \\param numBlocks       - Number of blocks to fit on SM\n \\param blockSize       - Size of the blocks\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr"]
    pub fn cuOccupancyAvailableDynamicSMemPerBlock(
        dynamicSmemSize: *mut usize,
        func: CUfunction,
        numBlocks: ::std::os::raw::c_int,
        blockSize: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Given the kernel function (\\p func) and launch configuration\n (\\p config), return the maximum cluster size in \\p *clusterSize.\n\n The cluster dimensions in \\p config are ignored. If func has a required\n cluster size set (see ::cudaFuncGetAttributes / ::cuFuncGetAttribute),\\p\n *clusterSize will reflect the required cluster size.\n\n By default this function will always return a value that's portable on\n future hardware. A higher value may be returned if the kernel function\n allows non-portable cluster sizes.\n\n This function will respect the compile time launch bounds.\n\n \\param clusterSize - Returned maximum cluster size that can be launched\n                      for the given kernel function and launch configuration\n \\param func        - Kernel function for which maximum cluster\n                      size is calculated\n \\param config      - Launch configuration for the given kernel function\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa\n ::cudaFuncGetAttributes,\n ::cuFuncGetAttribute"]
    pub fn cuOccupancyMaxPotentialClusterSize(
        clusterSize: *mut ::std::os::raw::c_int,
        func: CUfunction,
        config: *const CUlaunchConfig,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Given the kernel function (\\p func) and launch configuration\n (\\p config), return the maximum number of clusters that could co-exist\n on the target device in \\p *numClusters.\n\n If the function has required cluster size already set (see\n ::cudaFuncGetAttributes / ::cuFuncGetAttribute), the cluster size\n from config must either be unspecified or match the required size.\n Without required sizes, the cluster size must be specified in config,\n else the function will return an error.\n\n Note that various attributes of the kernel function may affect occupancy\n calculation. Runtime environment may affect how the hardware schedules\n the clusters, so the calculated occupancy is not guaranteed to be achievable.\n\n \\param numClusters - Returned maximum number of clusters that\n                      could co-exist on the target device\n \\param func        - Kernel function for which maximum number\n                      of clusters are calculated\n \\param config      - Launch configuration for the given kernel function\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_CLUSTER_SIZE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa\n ::cudaFuncGetAttributes,\n ::cuFuncGetAttribute"]
    pub fn cuOccupancyMaxActiveClusters(
        numClusters: *mut ::std::os::raw::c_int,
        func: CUfunction,
        config: *const CUlaunchConfig,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Binds an array as a texture reference\n\n \\deprecated\n\n Binds the CUDA array \\p hArray to the texture reference \\p hTexRef. Any\n previous address or CUDA array state associated with the texture reference\n is superseded by this function. \\p Flags must be set to\n ::CU_TRSA_OVERRIDE_FORMAT. Any CUDA array previously bound to \\p hTexRef is\n unbound.\n\n \\param hTexRef - Texture reference to bind\n \\param hArray  - Array to bind\n \\param Flags   - Options (must be ::CU_TRSA_OVERRIDE_FORMAT)\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetArray(
        hTexRef: CUtexref,
        hArray: CUarray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Binds a mipmapped array to a texture reference\n\n \\deprecated\n\n Binds the CUDA mipmapped array \\p hMipmappedArray to the texture reference \\p hTexRef.\n Any previous address or CUDA array state associated with the texture reference\n is superseded by this function. \\p Flags must be set to ::CU_TRSA_OVERRIDE_FORMAT.\n Any CUDA array previously bound to \\p hTexRef is unbound.\n\n \\param hTexRef         - Texture reference to bind\n \\param hMipmappedArray - Mipmapped array to bind\n \\param Flags           - Options (must be ::CU_TRSA_OVERRIDE_FORMAT)\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetMipmappedArray(
        hTexRef: CUtexref,
        hMipmappedArray: CUmipmappedArray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddress_v2(
        ByteOffset: *mut usize,
        hTexRef: CUtexref,
        dptr: CUdeviceptr,
        bytes: usize,
    ) -> CUresult;
}
extern "C" {
    pub fn cuTexRefSetAddress2D_v3(
        hTexRef: CUtexref,
        desc: *const CUDA_ARRAY_DESCRIPTOR,
        dptr: CUdeviceptr,
        Pitch: usize,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the format for a texture reference\n\n \\deprecated\n\n Specifies the format of the data to be read by the texture reference\n \\p hTexRef. \\p fmt and \\p NumPackedComponents are exactly analogous to the\n ::Format and ::NumChannels members of the ::CUDA_ARRAY_DESCRIPTOR structure:\n They specify the format of each component and the number of components per\n array element.\n\n \\param hTexRef             - Texture reference\n \\param fmt                 - Format to set\n \\param NumPackedComponents - Number of components per array element\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat,\n ::cudaCreateChannelDesc"]
    pub fn cuTexRefSetFormat(
        hTexRef: CUtexref,
        fmt: CUarray_format,
        NumPackedComponents: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the addressing mode for a texture reference\n\n \\deprecated\n\n Specifies the addressing mode \\p am for the given dimension \\p dim of the\n texture reference \\p hTexRef. If \\p dim is zero, the addressing mode is\n applied to the first parameter of the functions used to fetch from the\n texture; if \\p dim is 1, the second, and so on. ::CUaddress_mode is defined\n as:\n \\code\ntypedef enum CUaddress_mode_enum {\nCU_TR_ADDRESS_MODE_WRAP = 0,\nCU_TR_ADDRESS_MODE_CLAMP = 1,\nCU_TR_ADDRESS_MODE_MIRROR = 2,\nCU_TR_ADDRESS_MODE_BORDER = 3\n} CUaddress_mode;\n \\endcode\n\n Note that this call has no effect if \\p hTexRef is bound to linear memory.\n Also, if the flag, ::CU_TRSF_NORMALIZED_COORDINATES, is not set, the only\n supported address mode is ::CU_TR_ADDRESS_MODE_CLAMP.\n\n \\param hTexRef - Texture reference\n \\param dim     - Dimension\n \\param am      - Addressing mode to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetAddressMode(
        hTexRef: CUtexref,
        dim: ::std::os::raw::c_int,
        am: CUaddress_mode,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the filtering mode for a texture reference\n\n \\deprecated\n\n Specifies the filtering mode \\p fm to be used when reading memory through\n the texture reference \\p hTexRef. ::CUfilter_mode_enum is defined as:\n\n \\code\ntypedef enum CUfilter_mode_enum {\nCU_TR_FILTER_MODE_POINT = 0,\nCU_TR_FILTER_MODE_LINEAR = 1\n} CUfilter_mode;\n \\endcode\n\n Note that this call has no effect if \\p hTexRef is bound to linear memory.\n\n \\param hTexRef - Texture reference\n \\param fm      - Filtering mode to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the mipmap filtering mode for a texture reference\n\n \\deprecated\n\n Specifies the mipmap filtering mode \\p fm to be used when reading memory through\n the texture reference \\p hTexRef. ::CUfilter_mode_enum is defined as:\n\n \\code\ntypedef enum CUfilter_mode_enum {\nCU_TR_FILTER_MODE_POINT = 0,\nCU_TR_FILTER_MODE_LINEAR = 1\n} CUfilter_mode;\n \\endcode\n\n Note that this call has no effect if \\p hTexRef is not bound to a mipmapped array.\n\n \\param hTexRef - Texture reference\n \\param fm      - Filtering mode to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetMipmapFilterMode(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the mipmap level bias for a texture reference\n\n \\deprecated\n\n Specifies the mipmap level bias \\p bias to be added to the specified mipmap level when\n reading memory through the texture reference \\p hTexRef.\n\n Note that this call has no effect if \\p hTexRef is not bound to a mipmapped array.\n\n \\param hTexRef - Texture reference\n \\param bias    - Mipmap level bias\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetMipmapLevelBias(hTexRef: CUtexref, bias: f32) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the mipmap min/max mipmap level clamps for a texture reference\n\n \\deprecated\n\n Specifies the min/max mipmap level clamps, \\p minMipmapLevelClamp and \\p maxMipmapLevelClamp\n respectively, to be used when reading memory through the texture reference\n \\p hTexRef.\n\n Note that this call has no effect if \\p hTexRef is not bound to a mipmapped array.\n\n \\param hTexRef        - Texture reference\n \\param minMipmapLevelClamp - Mipmap min level clamp\n \\param maxMipmapLevelClamp - Mipmap max level clamp\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetMipmapLevelClamp(
        hTexRef: CUtexref,
        minMipmapLevelClamp: f32,
        maxMipmapLevelClamp: f32,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the maximum anisotropy for a texture reference\n\n \\deprecated\n\n Specifies the maximum anisotropy \\p maxAniso to be used when reading memory through\n the texture reference \\p hTexRef.\n\n Note that this call has no effect if \\p hTexRef is bound to linear memory.\n\n \\param hTexRef  - Texture reference\n \\param maxAniso - Maximum anisotropy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetMaxAnisotropy(
        hTexRef: CUtexref,
        maxAniso: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the border color for a texture reference\n\n \\deprecated\n\n Specifies the value of the RGBA color via the \\p pBorderColor to the texture reference\n \\p hTexRef. The color value supports only float type and holds color components in\n the following sequence:\n pBorderColor[0] holds 'R' component\n pBorderColor[1] holds 'G' component\n pBorderColor[2] holds 'B' component\n pBorderColor[3] holds 'A' component\n\n Note that the color values can be set only when the Address mode is set to\n CU_TR_ADDRESS_MODE_BORDER using ::cuTexRefSetAddressMode.\n Applications using integer border color values have to \"reinterpret_cast\" their values to float.\n\n \\param hTexRef       - Texture reference\n \\param pBorderColor  - RGBA color\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddressMode,\n ::cuTexRefGetAddressMode, ::cuTexRefGetBorderColor"]
    pub fn cuTexRefSetBorderColor(hTexRef: CUtexref, pBorderColor: *mut f32) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the flags for a texture reference\n\n \\deprecated\n\n Specifies optional flags via \\p Flags to specify the behavior of data\n returned through the texture reference \\p hTexRef. The valid flags are:\n\n - ::CU_TRSF_READ_AS_INTEGER, which suppresses the default behavior of\n   having the texture promote integer data to floating point data in the\n   range [0, 1]. Note that texture with 32-bit integer format\n   would not be promoted, regardless of whether or not this\n   flag is specified;\n - ::CU_TRSF_NORMALIZED_COORDINATES, which suppresses the\n   default behavior of having the texture coordinates range\n   from [0, Dim) where Dim is the width or height of the CUDA\n   array. Instead, the texture coordinates [0, 1.0) reference\n   the entire breadth of the array dimension;\n - ::CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION, which disables any trilinear\n   filtering optimizations. Trilinear optimizations improve texture filtering\n   performance by allowing bilinear filtering on textures in scenarios where\n   it can closely approximate the expected results.\n\n \\param hTexRef - Texture reference\n \\param Flags   - Optional flags to set\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefSetFlags(hTexRef: CUtexref, Flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    pub fn cuTexRefGetAddress_v2(pdptr: *mut CUdeviceptr, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the array bound to a texture reference\n\n \\deprecated\n\n Returns in \\p *phArray the CUDA array bound to the texture reference\n \\p hTexRef, or returns ::CUDA_ERROR_INVALID_VALUE if the texture reference\n is not bound to any CUDA array.\n\n \\param phArray - Returned array\n \\param hTexRef - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetArray(phArray: *mut CUarray, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the mipmapped array bound to a texture reference\n\n \\deprecated\n\n Returns in \\p *phMipmappedArray the CUDA mipmapped array bound to the texture\n reference \\p hTexRef, or returns ::CUDA_ERROR_INVALID_VALUE if the texture reference\n is not bound to any CUDA mipmapped array.\n\n \\param phMipmappedArray - Returned mipmapped array\n \\param hTexRef          - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMipmappedArray(
        phMipmappedArray: *mut CUmipmappedArray,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the addressing mode used by a texture reference\n\n \\deprecated\n\n Returns in \\p *pam the addressing mode corresponding to the\n dimension \\p dim of the texture reference \\p hTexRef. Currently, the only\n valid value for \\p dim are 0 and 1.\n\n \\param pam     - Returned addressing mode\n \\param hTexRef - Texture reference\n \\param dim     - Dimension\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetAddressMode(
        pam: *mut CUaddress_mode,
        hTexRef: CUtexref,
        dim: ::std::os::raw::c_int,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the filter-mode used by a texture reference\n\n \\deprecated\n\n Returns in \\p *pfm the filtering mode of the texture reference\n \\p hTexRef.\n\n \\param pfm     - Returned filtering mode\n \\param hTexRef - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the format used by a texture reference\n\n \\deprecated\n\n Returns in \\p *pFormat and \\p *pNumChannels the format and number\n of components of the CUDA array bound to the texture reference \\p hTexRef.\n If \\p pFormat or \\p pNumChannels is NULL, it will be ignored.\n\n \\param pFormat      - Returned format\n \\param pNumChannels - Returned number of components\n \\param hTexRef      - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags"]
    pub fn cuTexRefGetFormat(
        pFormat: *mut CUarray_format,
        pNumChannels: *mut ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the mipmap filtering mode for a texture reference\n\n \\deprecated\n\n Returns the mipmap filtering mode in \\p pfm that's used when reading memory through\n the texture reference \\p hTexRef.\n\n \\param pfm     - Returned mipmap filtering mode\n \\param hTexRef - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMipmapFilterMode(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the mipmap level bias for a texture reference\n\n \\deprecated\n\n Returns the mipmap level bias in \\p pBias that's added to the specified mipmap\n level when reading memory through the texture reference \\p hTexRef.\n\n \\param pbias   - Returned mipmap level bias\n \\param hTexRef - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMipmapLevelBias(pbias: *mut f32, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the min/max mipmap level clamps for a texture reference\n\n \\deprecated\n\n Returns the min/max mipmap level clamps in \\p pminMipmapLevelClamp and \\p pmaxMipmapLevelClamp\n that's used when reading memory through the texture reference \\p hTexRef.\n\n \\param pminMipmapLevelClamp - Returned mipmap min level clamp\n \\param pmaxMipmapLevelClamp - Returned mipmap max level clamp\n \\param hTexRef              - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the maximum anisotropy for a texture reference\n\n \\deprecated\n\n Returns the maximum anisotropy in \\p pmaxAniso that's used when reading memory through\n the texture reference \\p hTexRef.\n\n \\param pmaxAniso - Returned maximum anisotropy\n \\param hTexRef   - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFlags, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetMaxAnisotropy(
        pmaxAniso: *mut ::std::os::raw::c_int,
        hTexRef: CUtexref,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the border color used by a texture reference\n\n \\deprecated\n\n Returns in \\p pBorderColor, values of the RGBA color used by\n the texture reference \\p hTexRef.\n The color value is of type float and holds color components in\n the following sequence:\n pBorderColor[0] holds 'R' component\n pBorderColor[1] holds 'G' component\n pBorderColor[2] holds 'B' component\n pBorderColor[3] holds 'A' component\n\n \\param hTexRef  - Texture reference\n \\param pBorderColor   - Returned Type and Value of RGBA color\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddressMode,\n ::cuTexRefSetAddressMode, ::cuTexRefSetBorderColor"]
    pub fn cuTexRefGetBorderColor(pBorderColor: *mut f32, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Gets the flags used by a texture reference\n\n \\deprecated\n\n Returns in \\p *pFlags the flags of the texture reference \\p hTexRef.\n\n \\param pFlags  - Returned flags\n \\param hTexRef - Texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefSetAddress,\n ::cuTexRefSetAddress2D, ::cuTexRefSetAddressMode, ::cuTexRefSetArray,\n ::cuTexRefSetFilterMode, ::cuTexRefSetFlags, ::cuTexRefSetFormat,\n ::cuTexRefGetAddress, ::cuTexRefGetAddressMode, ::cuTexRefGetArray,\n ::cuTexRefGetFilterMode, ::cuTexRefGetFormat"]
    pub fn cuTexRefGetFlags(pFlags: *mut ::std::os::raw::c_uint, hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a texture reference\n\n \\deprecated\n\n Creates a texture reference and returns its handle in \\p *pTexRef. Once\n created, the application must call ::cuTexRefSetArray() or\n ::cuTexRefSetAddress() to associate the reference with allocated memory.\n Other texture reference functions are used to specify the format and\n interpretation (addressing, filtering, etc.) to be used when the memory is\n read through this texture reference.\n\n \\param pTexRef - Returned texture reference\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefDestroy"]
    pub fn cuTexRefCreate(pTexRef: *mut CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a texture reference\n\n \\deprecated\n\n Destroys the texture reference specified by \\p hTexRef.\n\n \\param hTexRef - Texture reference to destroy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuTexRefCreate"]
    pub fn cuTexRefDestroy(hTexRef: CUtexref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Sets the CUDA array for a surface reference.\n\n \\deprecated\n\n Sets the CUDA array \\p hArray to be read and written by the surface reference\n \\p hSurfRef.  Any previous CUDA array state associated with the surface\n reference is superseded by this function.  \\p Flags must be set to 0.\n The ::CUDA_ARRAY3D_SURFACE_LDST flag must have been set for the CUDA array.\n Any CUDA array previously bound to \\p hSurfRef is unbound.\n\n \\param hSurfRef - Surface reference handle\n \\param hArray - CUDA array handle\n \\param Flags - set to 0\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuModuleGetSurfRef,\n ::cuSurfRefGetArray"]
    pub fn cuSurfRefSetArray(
        hSurfRef: CUsurfref,
        hArray: CUarray,
        Flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Passes back the CUDA array bound to a surface reference.\n\n \\deprecated\n\n Returns in \\p *phArray the CUDA array bound to the surface reference\n \\p hSurfRef, or returns ::CUDA_ERROR_INVALID_VALUE if the surface reference\n is not bound to any CUDA array.\n\n \\param phArray - Surface reference handle\n \\param hSurfRef - Surface reference handle\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa ::cuModuleGetSurfRef, ::cuSurfRefSetArray"]
    pub fn cuSurfRefGetArray(phArray: *mut CUarray, hSurfRef: CUsurfref) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a texture object\n\n Creates a texture object and returns it in \\p pTexObject. \\p pResDesc describes\n the data to texture from. \\p pTexDesc describes how the data should be sampled.\n \\p pResViewDesc is an optional argument that specifies an alternate format for\n the data described by \\p pResDesc, and also describes the subresource region\n to restrict access to when texturing. \\p pResViewDesc can only be specified if\n the type of resource is a CUDA array or a CUDA mipmapped array.\n\n Texture objects are only supported on devices of compute capability 3.0 or higher.\n Additionally, a texture object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n The ::CUDA_RESOURCE_DESC structure is defined as:\n \\code\ntypedef struct CUDA_RESOURCE_DESC_st\n{\nCUresourcetype resType;\n\nunion {\nstruct {\nCUarray hArray;\n} array;\nstruct {\nCUmipmappedArray hMipmappedArray;\n} mipmap;\nstruct {\nCUdeviceptr devPtr;\nCUarray_format format;\nunsigned int numChannels;\nsize_t sizeInBytes;\n} linear;\nstruct {\nCUdeviceptr devPtr;\nCUarray_format format;\nunsigned int numChannels;\nsize_t width;\nsize_t height;\nsize_t pitchInBytes;\n} pitch2D;\n} res;\n\nunsigned int flags;\n} CUDA_RESOURCE_DESC;\n\n \\endcode\n where:\n - ::CUDA_RESOURCE_DESC::resType specifies the type of resource to texture from.\n CUresourceType is defined as:\n \\code\ntypedef enum CUresourcetype_enum {\nCU_RESOURCE_TYPE_ARRAY           = 0x00,\nCU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01,\nCU_RESOURCE_TYPE_LINEAR          = 0x02,\nCU_RESOURCE_TYPE_PITCH2D         = 0x03\n} CUresourcetype;\n \\endcode\n\n \\par\n If ::CUDA_RESOURCE_DESC::resType is set to ::CU_RESOURCE_TYPE_ARRAY, ::CUDA_RESOURCE_DESC::res::array::hArray\n must be set to a valid CUDA array handle.\n\n \\par\n If ::CUDA_RESOURCE_DESC::resType is set to ::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY, ::CUDA_RESOURCE_DESC::res::mipmap::hMipmappedArray\n must be set to a valid CUDA mipmapped array handle.\n\n \\par\n If ::CUDA_RESOURCE_DESC::resType is set to ::CU_RESOURCE_TYPE_LINEAR, ::CUDA_RESOURCE_DESC::res::linear::devPtr\n must be set to a valid device pointer, that is aligned to ::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT.\n ::CUDA_RESOURCE_DESC::res::linear::format and ::CUDA_RESOURCE_DESC::res::linear::numChannels\n describe the format of each component and the number of components per array element. ::CUDA_RESOURCE_DESC::res::linear::sizeInBytes\n specifies the size of the array in bytes. The total number of elements in the linear address range cannot exceed\n ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH. The number of elements is computed as (sizeInBytes / (sizeof(format) * numChannels)).\n\n \\par\n If ::CUDA_RESOURCE_DESC::resType is set to ::CU_RESOURCE_TYPE_PITCH2D, ::CUDA_RESOURCE_DESC::res::pitch2D::devPtr\n must be set to a valid device pointer, that is aligned to ::CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT.\n ::CUDA_RESOURCE_DESC::res::pitch2D::format and ::CUDA_RESOURCE_DESC::res::pitch2D::numChannels\n describe the format of each component and the number of components per array element. ::CUDA_RESOURCE_DESC::res::pitch2D::width\n and ::CUDA_RESOURCE_DESC::res::pitch2D::height specify the width and height of the array in elements, and cannot exceed\n ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH and ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT respectively.\n ::CUDA_RESOURCE_DESC::res::pitch2D::pitchInBytes specifies the pitch between two rows in bytes and has to be aligned to\n ::CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT. Pitch cannot exceed ::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH.\n\n - ::flags must be set to zero.\n\n\n The ::CUDA_TEXTURE_DESC struct is defined as\n \\code\ntypedef struct CUDA_TEXTURE_DESC_st {\nCUaddress_mode addressMode[3];\nCUfilter_mode filterMode;\nunsigned int flags;\nunsigned int maxAnisotropy;\nCUfilter_mode mipmapFilterMode;\nfloat mipmapLevelBias;\nfloat minMipmapLevelClamp;\nfloat maxMipmapLevelClamp;\n} CUDA_TEXTURE_DESC;\n \\endcode\n where\n - ::CUDA_TEXTURE_DESC::addressMode specifies the addressing mode for each dimension of the texture data. ::CUaddress_mode is defined as:\n   \\code\ntypedef enum CUaddress_mode_enum {\nCU_TR_ADDRESS_MODE_WRAP = 0,\nCU_TR_ADDRESS_MODE_CLAMP = 1,\nCU_TR_ADDRESS_MODE_MIRROR = 2,\nCU_TR_ADDRESS_MODE_BORDER = 3\n} CUaddress_mode;\n   \\endcode\n   This is ignored if ::CUDA_RESOURCE_DESC::resType is ::CU_RESOURCE_TYPE_LINEAR. Also, if the flag, ::CU_TRSF_NORMALIZED_COORDINATES\n   is not set, the only supported address mode is ::CU_TR_ADDRESS_MODE_CLAMP.\n\n - ::CUDA_TEXTURE_DESC::filterMode specifies the filtering mode to be used when fetching from the texture. CUfilter_mode is defined as:\n   \\code\ntypedef enum CUfilter_mode_enum {\nCU_TR_FILTER_MODE_POINT = 0,\nCU_TR_FILTER_MODE_LINEAR = 1\n} CUfilter_mode;\n   \\endcode\n   This is ignored if ::CUDA_RESOURCE_DESC::resType is ::CU_RESOURCE_TYPE_LINEAR.\n\n - ::CUDA_TEXTURE_DESC::flags can be any combination of the following:\n   - ::CU_TRSF_READ_AS_INTEGER, which suppresses the default behavior of\n   having the texture promote integer data to floating point data in the\n   range [0, 1]. Note that texture with 32-bit integer format would not be\n   promoted, regardless of whether or not this flag is specified.\n   - ::CU_TRSF_NORMALIZED_COORDINATES, which suppresses the default behavior\n   of having the texture coordinates range from [0, Dim) where Dim is the\n   width or height of the CUDA array. Instead, the texture coordinates\n   [0, 1.0) reference the entire breadth of the array dimension; Note that\n   for CUDA mipmapped arrays, this flag has to be set.\n   - ::CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION, which disables any trilinear\n   filtering optimizations. Trilinear optimizations improve texture filtering\n   performance by allowing bilinear filtering on textures in scenarios where\n   it can closely approximate the expected results.\n   - ::CU_TRSF_SEAMLESS_CUBEMAP, which enables seamless cube map filtering.\n   This flag can only be specified if the underlying resource is a CUDA array\n   or a CUDA mipmapped array that was created with the flag ::CUDA_ARRAY3D_CUBEMAP.\n   When seamless cube map filtering is enabled, texture address modes specified\n   by ::CUDA_TEXTURE_DESC::addressMode are ignored. Instead, if the ::CUDA_TEXTURE_DESC::filterMode\n   is set to ::CU_TR_FILTER_MODE_POINT the address mode ::CU_TR_ADDRESS_MODE_CLAMP\n   will be applied for all dimensions. If the ::CUDA_TEXTURE_DESC::filterMode is\n   set to ::CU_TR_FILTER_MODE_LINEAR seamless cube map filtering will be performed\n   when sampling along the cube face borders.\n\n - ::CUDA_TEXTURE_DESC::maxAnisotropy specifies the maximum anisotropy ratio to be used when doing anisotropic filtering. This value will be\n   clamped to the range [1,16].\n\n - ::CUDA_TEXTURE_DESC::mipmapFilterMode specifies the filter mode when the calculated mipmap level lies between two defined mipmap levels.\n\n - ::CUDA_TEXTURE_DESC::mipmapLevelBias specifies the offset to be applied to the calculated mipmap level.\n\n - ::CUDA_TEXTURE_DESC::minMipmapLevelClamp specifies the lower end of the mipmap level range to clamp access to.\n\n - ::CUDA_TEXTURE_DESC::maxMipmapLevelClamp specifies the upper end of the mipmap level range to clamp access to.\n\n\n The ::CUDA_RESOURCE_VIEW_DESC struct is defined as\n \\code\ntypedef struct CUDA_RESOURCE_VIEW_DESC_st\n{\nCUresourceViewFormat format;\nsize_t width;\nsize_t height;\nsize_t depth;\nunsigned int firstMipmapLevel;\nunsigned int lastMipmapLevel;\nunsigned int firstLayer;\nunsigned int lastLayer;\n} CUDA_RESOURCE_VIEW_DESC;\n \\endcode\n where:\n - ::CUDA_RESOURCE_VIEW_DESC::format specifies how the data contained in the CUDA array or CUDA mipmapped array should\n   be interpreted. Note that this can incur a change in size of the texture data. If the resource view format is a block\n   compressed format, then the underlying CUDA array or CUDA mipmapped array has to have a base of format ::CU_AD_FORMAT_UNSIGNED_INT32.\n   with 2 or 4 channels, depending on the block compressed format. For ex., BC1 and BC4 require the underlying CUDA array to have\n   a format of ::CU_AD_FORMAT_UNSIGNED_INT32 with 2 channels. The other BC formats require the underlying resource to have the same base\n   format but with 4 channels.\n\n - ::CUDA_RESOURCE_VIEW_DESC::width specifies the new width of the texture data. If the resource view format is a block\n   compressed format, this value has to be 4 times the original width of the resource. For non block compressed formats,\n   this value has to be equal to that of the original resource.\n\n - ::CUDA_RESOURCE_VIEW_DESC::height specifies the new height of the texture data. If the resource view format is a block\n   compressed format, this value has to be 4 times the original height of the resource. For non block compressed formats,\n   this value has to be equal to that of the original resource.\n\n - ::CUDA_RESOURCE_VIEW_DESC::depth specifies the new depth of the texture data. This value has to be equal to that of the\n   original resource.\n\n - ::CUDA_RESOURCE_VIEW_DESC::firstMipmapLevel specifies the most detailed mipmap level. This will be the new mipmap level zero.\n   For non-mipmapped resources, this value has to be zero.::CUDA_TEXTURE_DESC::minMipmapLevelClamp and ::CUDA_TEXTURE_DESC::maxMipmapLevelClamp\n   will be relative to this value. For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp of 1.2 is specified,\n   then the actual minimum mipmap level clamp will be 3.2.\n\n - ::CUDA_RESOURCE_VIEW_DESC::lastMipmapLevel specifies the least detailed mipmap level. For non-mipmapped resources, this value\n   has to be zero.\n\n - ::CUDA_RESOURCE_VIEW_DESC::firstLayer specifies the first layer index for layered textures. This will be the new layer zero.\n   For non-layered resources, this value has to be zero.\n\n - ::CUDA_RESOURCE_VIEW_DESC::lastLayer specifies the last layer index for layered textures. For non-layered resources,\n   this value has to be zero.\n\n\n \\param pTexObject   - Texture object to create\n \\param pResDesc     - Resource descriptor\n \\param pTexDesc     - Texture descriptor\n \\param pResViewDesc - Resource view descriptor\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexObjectDestroy,\n ::cudaCreateTextureObject"]
    pub fn cuTexObjectCreate(
        pTexObject: *mut CUtexObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
        pTexDesc: *const CUDA_TEXTURE_DESC,
        pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a texture object\n\n Destroys the texture object specified by \\p texObject.\n\n \\param texObject - Texture object to destroy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexObjectCreate,\n ::cudaDestroyTextureObject"]
    pub fn cuTexObjectDestroy(texObject: CUtexObject) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a texture object's resource descriptor\n\n Returns the resource descriptor for the texture object specified by \\p texObject.\n\n \\param pResDesc  - Resource descriptor\n \\param texObject - Texture object\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexObjectCreate,\n ::cudaGetTextureObjectResourceDesc,"]
    pub fn cuTexObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a texture object's texture descriptor\n\n Returns the texture descriptor for the texture object specified by \\p texObject.\n\n \\param pTexDesc  - Texture descriptor\n \\param texObject - Texture object\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexObjectCreate,\n ::cudaGetTextureObjectTextureDesc"]
    pub fn cuTexObjectGetTextureDesc(
        pTexDesc: *mut CUDA_TEXTURE_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a texture object's resource view descriptor\n\n Returns the resource view descriptor for the texture object specified by \\p texObject.\n If no resource view was set for \\p texObject, the ::CUDA_ERROR_INVALID_VALUE is returned.\n\n \\param pResViewDesc - Resource view descriptor\n \\param texObject    - Texture object\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTexObjectCreate,\n ::cudaGetTextureObjectResourceViewDesc"]
    pub fn cuTexObjectGetResourceViewDesc(
        pResViewDesc: *mut CUDA_RESOURCE_VIEW_DESC,
        texObject: CUtexObject,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Creates a surface object\n\n Creates a surface object and returns it in \\p pSurfObject. \\p pResDesc describes\n the data to perform surface load/stores on. ::CUDA_RESOURCE_DESC::resType must be\n ::CU_RESOURCE_TYPE_ARRAY and  ::CUDA_RESOURCE_DESC::res::array::hArray\n must be set to a valid CUDA array handle. ::CUDA_RESOURCE_DESC::flags must be set to zero.\n\n Surface objects are only supported on devices of compute capability 3.0 or higher.\n Additionally, a surface object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n \\param pSurfObject - Surface object to create\n \\param pResDesc    - Resource descriptor\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuSurfObjectDestroy,\n ::cudaCreateSurfaceObject"]
    pub fn cuSurfObjectCreate(
        pSurfObject: *mut CUsurfObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Destroys a surface object\n\n Destroys the surface object specified by \\p surfObject.\n\n \\param surfObject - Surface object to destroy\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuSurfObjectCreate,\n ::cudaDestroySurfaceObject"]
    pub fn cuSurfObjectDestroy(surfObject: CUsurfObject) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Returns a surface object's resource descriptor\n\n Returns the resource descriptor for the surface object specified by \\p surfObject.\n\n \\param pResDesc   - Resource descriptor\n \\param surfObject - Surface object\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuSurfObjectCreate,\n ::cudaGetSurfaceObjectResourceDesc"]
    pub fn cuSurfObjectGetResourceDesc(
        pResDesc: *mut CUDA_RESOURCE_DESC,
        surfObject: CUsurfObject,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a tensor map descriptor object representing tiled memory region\n\n Creates a descriptor for Tensor Memory Access (TMA) object specified\n by the parameters describing a tiled region and returns it in \\p tensorMap.\n\n Tensor map objects are only supported on devices of compute capability 9.0 or higher.\n Additionally, a tensor map object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n The parameters passed are bound to the following requirements:\n\n - \\p tensorMap address must be aligned to 64 bytes.\n\n - \\p tensorDataType has to be an enum from ::CUtensorMapDataType which is defined as:\n \\code\ntypedef enum CUtensorMapDataType_enum {\nCU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,       // 1 byte\nCU_TENSOR_MAP_DATA_TYPE_UINT16,          // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT32,          // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT32,           // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT64,          // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT64,           // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT16,         // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32,         // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT64,         // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_BFLOAT16,        // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ,     // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32,        // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ     // 4 bytes\n} CUtensorMapDataType;\n \\endcode\n\n - \\p tensorRank must be non-zero and less than or equal to the maximum supported dimensionality of 5. If \\p interleave is not\n ::CU_TENSOR_MAP_INTERLEAVE_NONE, then \\p tensorRank must additionally be greater than or equal to 3.\n\n - \\p globalAddress, which specifies the starting address of the memory region described, must be 32 byte aligned when \\p interleave is\n ::CU_TENSOR_MAP_INTERLEAVE_32B and 16 byte aligned otherwise.\n\n - \\p globalDim array, which specifies tensor size of each of the \\p tensorRank dimensions, must be non-zero and less than or\n equal to 2^32.\n\n - \\p globalStrides array, which specifies tensor stride of each of the lower \\p tensorRank - 1 dimensions in bytes, must be a\n multiple of 16 and less than 2^40. Additionally, the stride must be a multiple of 32 when \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_32B.\n Each following dimension specified includes previous dimension stride:\n \\code\nglobalStrides[0] = globalDim[0] * elementSizeInBytes(tensorDataType) + padding[0];\nfor (i = 1; i < tensorRank - 1; i++)\nglobalStrides[i] = globalStrides[i  1] * globalStrides[i] + padding[i];\nassert(globalStrides[i] >= globalDim[i]);\n \\endcode\n\n - \\p boxDim array, which specifies number of elements to be traversed along each of the \\p tensorRank dimensions, must be less\n than or equal to 8.\n When \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_NONE, { \\p boxDim[0] * elementSizeInBytes( \\p tensorDataType ) } must be a multiple\n of 16 bytes.\n\n - \\p elementStrides array, which specifies the iteration step along each of the \\p tensorRank dimensions, must be non-zero and less\n than or equal to 8. Note that when \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_NONE, the first element of this array is ignored since\n TMA doesnt support the stride for dimension zero.\n When all elemets of \\p elementStrides array is one, \\p boxDim specifies the number of elements to load. However, if the \\p elementStrides[i]\n is not equal to one, then TMA loads ceil( \\p boxDim[i] / \\p elementStrides[i]) number of elements along i-th dimension. To load N elements along\n i-th dimension, \\p boxDim[i] must be set to N * \\p elementStrides[i].\n\n - \\p interleave specifies the interleaved layout of type ::CUtensorMapInterleave, which is defined as:\n \\code\ntypedef enum CUtensorMapInterleave_enum {\nCU_TENSOR_MAP_INTERLEAVE_NONE = 0,\nCU_TENSOR_MAP_INTERLEAVE_16B,\nCU_TENSOR_MAP_INTERLEAVE_32B\n} CUtensorMapInterleave;\n \\endcode\n TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16 bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16\n uses 32 bytes.\n When \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_NONE and \\p swizzle is not ::CU_TENSOR_MAP_SWIZZLE_NONE, the bounding box inner dimension\n (computed as \\p boxDim[0] multiplied by element size derived from \\p tensorDataType) must be less than or equal to the swizzle size.\n    - CU_TENSOR_MAP_SWIZZLE_32B implies the bounding box inner dimension will be <= 32.\n    - CU_TENSOR_MAP_SWIZZLE_64B implies the bounding box inner dimension will be <= 64.\n    - CU_TENSOR_MAP_SWIZZLE_128B implies the bounding box inner dimension will be <= 128.\n\n - \\p swizzle, which specifies the shared memory bank swizzling pattern, has to be of type ::CUtensorMapSwizzle which is defined as:\n \\code\ntypedef enum CUtensorMapSwizzle_enum {\nCU_TENSOR_MAP_SWIZZLE_NONE = 0,\nCU_TENSOR_MAP_SWIZZLE_32B,\nCU_TENSOR_MAP_SWIZZLE_64B,\nCU_TENSOR_MAP_SWIZZLE_128B\n} CUtensorMapSwizzle;\n \\endcode\n Data is organized in specific order in global memory; however, it may not match the order in which data are accessed by application in\n the shared memory. This difference in data organization may cause bank conflicts when shared memory is accessed. In order to avoid this\n problem, data can be loaded to shard memory with shuffling across shared memory banks.\n Note that its expected that when \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_32B, \\p swizzle should be ::CU_TENSOR_MAP_SWIZZLE_32B mode.\n Other interleave modes can have any swizzling patterns.\n\n - \\p l2Promotion specifies L2 fetch size which indicates the byte granurality at which L2 requests is filled from DRAM. It must be of\n type ::CUtensorMapL2promotion, which is defined as:\n \\code\ntypedef enum CUtensorMapL2promotion_enum {\nCU_TENSOR_MAP_L2_PROMOTION_NONE = 0,\nCU_TENSOR_MAP_L2_PROMOTION_L2_64B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_128B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_256B\n} CUtensorMapL2promotion;\n \\endcode\n\n - \\p oobFill, which indicates whether zero or a special NaN constant should be used to fill out-of-bound elements, must be of type\n ::CUtensorMapFloatOOBfill which is defined as:\n \\code\ntypedef enum CUtensorMapFloatOOBfill_enum {\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA\n} CUtensorMapFloatOOBfill;\n \\endcode\n Note that ::CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA can only be used when \\p tensorDataType represents a floating data type.\n\n \\param tensorMap         - Tensor map object to create\n \\param tensorDataType    - Tensor data type\n \\param tensorRank        - Dimensionality of tensor\n \\param globalAddress     - Starting address of memory region described by tensor\n \\param globalDim         - Array containing tensor size (number of elements) along each of the \\p tensorRank dimensions\n \\param globalStrides     - Array containing stride size (in bytes) along each of the \\p tensorRank - 1 dimensions\n \\param boxDim            - Array containing traversal box size (number of elments) along each of the \\p tensorRank dimensions. Specifies how many elements to be traversed along each tensor dimension.\n \\param elementStrides    - Array containing traversal stride in each of the \\p tensorRank dimensions\n \\param interleave        - Type of interleaved layout the tensor addresses\n \\param swizzle           - Bank swizzling pattern inside shared memory\n \\param l2Promotion       - L2 promotion size\n \\param oobFill           - Indicate whether zero or special NaN constant must be used to fill out-of-bound elements\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTensorMapEncodeIm2col,\n ::cuTensorMapReplaceAddress"]
    pub fn cuTensorMapEncodeTiled(
        tensorMap: *mut CUtensorMap,
        tensorDataType: CUtensorMapDataType,
        tensorRank: cuuint32_t,
        globalAddress: *mut ::std::os::raw::c_void,
        globalDim: *const cuuint64_t,
        globalStrides: *const cuuint64_t,
        boxDim: *const cuuint32_t,
        elementStrides: *const cuuint32_t,
        interleave: CUtensorMapInterleave,
        swizzle: CUtensorMapSwizzle,
        l2Promotion: CUtensorMapL2promotion,
        oobFill: CUtensorMapFloatOOBfill,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Create a tensor map descriptor object representing im2col memory region\n\n Creates a descriptor for Tensor Memory Access (TMA) object specified\n by the parameters describing a im2col memory layout and returns it in \\p tensorMap.\n\n Tensor map objects are only supported on devices of compute capability 9.0 or higher.\n Additionally, a tensor map object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n The parameters passed are bound to the following requirements:\n\n - \\p tensorMap address must be aligned to 64 bytes.\n\n - \\p tensorDataType has to be an enum from ::CUtensorMapDataType which is defined as:\n \\code\ntypedef enum CUtensorMapDataType_enum {\nCU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,       // 1 byte\nCU_TENSOR_MAP_DATA_TYPE_UINT16,          // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT32,          // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT32,           // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_UINT64,          // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_INT64,           // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT16,         // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32,         // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT64,         // 8 bytes\nCU_TENSOR_MAP_DATA_TYPE_BFLOAT16,        // 2 bytes\nCU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ,     // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32,        // 4 bytes\nCU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ     // 4 bytes\n} CUtensorMapDataType;\n \\endcode\n\n - \\p tensorRank must be one of dimensions 3, 4, or 5.\n\n - \\p globalAddress, which specifies the starting address of the memory region described, must be 32 byte aligned when \\p interleave is\n ::CU_TENSOR_MAP_INTERLEAVE_32B and 16 byte aligned otherwise.\n\n - \\p globalDim array, which specifies tensor size of each of the \\p tensorRank dimensions, must be non-zero and less than or\n equal to 2^32.\n\n - \\p globalStrides array, which specifies tensor stride of each of the lower \\p tensorRank - 1 dimensions in bytes, must be a\n multiple of 16 and less than 2^40. Additionally, the stride must be a multiple of 32 when \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_32B.\n Each following dimension specified includes previous dimension stride:\n \\code\nglobalStrides[0] = globalDim[0] * elementSizeInBytes(tensorDataType) + padding[0];\nfor (i = 1; i < tensorRank - 1; i++)\nglobalStrides[i] = globalStrides[i  1] * globalStrides[i] + padding[i];\nassert(globalStrides[i] >= globalDim[i]);\n \\endcode\n\n - \\p pixelBoxLowerCorner array specifies the coordinate offsets {D, H, W} of the bounding box from top/left/front corner. The number of\n offsets and their precision depends on the tensor dimensionality:\n    - When \\p tensorRank is 3, one signed offset within range [-32768, 32767] is supported.\n    - When \\p tensorRank is 4, two signed offsets each within range [-128, 127] are supported.\n    - When \\p tensorRank is 5, three offsets each within range [-16, 15] are supported.\n\n - \\p pixelBoxUpperCorner array specifies the coordinate offsets {D, H, W} of the bounding box from bottom/right/back corner. The number of\n offsets and their precision depends on the tensor dimensionality:\n    - When \\p tensorRank is 3, one signed offset within range [-32768, 32767] is supported.\n    - When \\p tensorRank is 4, two signed offsets each within range [-128, 127] are supported.\n    - When \\p tensorRank is 5, three offsets each within range [-16, 15] are supported.\n The bounding box specified by \\p pixelBoxLowerCorner and \\p pixelBoxUpperCorner must have non-zero area.\n\n - \\p channelsPerPixel, which specifies the number of elements which must be accessed along C dimension, must be less than or equal to 256.\n\n - \\p pixelsPerColumn, which specifies the number of elements that must be accessed along the {N, D, H, W} dimensions, must be less than or\n equal to 1024.\n\n - \\p elementStrides array, which specifies the iteration step along each of the \\p tensorRank dimensions, must be non-zero and less\n than or equal to 8. Note that when \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_NONE, the first element of this array is ignored since\n TMA doesnt support the stride for dimension zero.\n When all elemets of \\p elementStrides array is one, \\p boxDim specifies the number of elements to load. However, if the \\p elementStrides[i]\n is not equal to one, then TMA loads ceil( \\p boxDim[i] / \\p elementStrides[i]) number of elements along i-th dimension. To load N elements along\n i-th dimension, \\p boxDim[i] must be set to N * \\p elementStrides[i].\n\n - \\p interleave specifies the interleaved layout of type ::CUtensorMapInterleave, which is defined as:\n \\code\ntypedef enum CUtensorMapInterleave_enum {\nCU_TENSOR_MAP_INTERLEAVE_NONE = 0,\nCU_TENSOR_MAP_INTERLEAVE_16B,\nCU_TENSOR_MAP_INTERLEAVE_32B\n} CUtensorMapInterleave;\n \\endcode\n TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16 bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16\n uses 32 bytes.\n When \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_NONE and \\p swizzle is not ::CU_TENSOR_MAP_SWIZZLE_NONE, the bounding box inner dimension\n (computed as \\p boxDim[0] multiplied by element size derived from \\p tensorDataType) must be less than or equal to the swizzle size.\n    - CU_TENSOR_MAP_SWIZZLE_32B implies the bounding box inner dimension will be <= 32.\n    - CU_TENSOR_MAP_SWIZZLE_64B implies the bounding box inner dimension will be <= 64.\n    - CU_TENSOR_MAP_SWIZZLE_128B implies the bounding box inner dimension will be <= 128.\n\n - \\p swizzle, which specifies the shared memory bank swizzling pattern, has to be of type ::CUtensorMapSwizzle which is defined as:\n \\code\ntypedef enum CUtensorMapSwizzle_enum {\nCU_TENSOR_MAP_SWIZZLE_NONE = 0,\nCU_TENSOR_MAP_SWIZZLE_32B,\nCU_TENSOR_MAP_SWIZZLE_64B,\nCU_TENSOR_MAP_SWIZZLE_128B\n} CUtensorMapSwizzle;\n \\endcode\n Data is organized in specific order in global memory; however, it may not match the order in which data are accessed by application in\n the shared memory. This difference in data organization may cause bank conflicts when shared memory is accessed. In order to avoid this\n problem, data can be loaded to shard memory with shuffling across shared memory banks.\n Note that its expected that when \\p interleave is ::CU_TENSOR_MAP_INTERLEAVE_32B, \\p swizzle should be ::CU_TENSOR_MAP_SWIZZLE_32B mode.\n Other interleave modes can have any swizzling patterns.\n\n - \\p l2Promotion specifies L2 fetch size which indicates the byte granurality at which L2 requests is filled from DRAM. It must be of\n type ::CUtensorMapL2promotion, which is defined as:\n \\code\ntypedef enum CUtensorMapL2promotion_enum {\nCU_TENSOR_MAP_L2_PROMOTION_NONE = 0,\nCU_TENSOR_MAP_L2_PROMOTION_L2_64B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_128B,\nCU_TENSOR_MAP_L2_PROMOTION_L2_256B\n} CUtensorMapL2promotion;\n \\endcode\n\n - \\p oobFill, which indicates whether zero or a special NaN constant should be used to fill out-of-bound elements, must be of type\n ::CUtensorMapFloatOOBfill which is defined as:\n \\code\ntypedef enum CUtensorMapFloatOOBfill_enum {\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,\nCU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA\n} CUtensorMapFloatOOBfill;\n \\endcode\n Note that ::CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA can only be used when \\p tensorDataType represents a floating data type.\n\n \\param tensorMap             - Tensor map object to create\n \\param tensorDataType        - Tensor data type\n \\param tensorRank            - Dimensionality of tensor, needs to be at least of dimension 3\n \\param globalAddress         - Starting address of memory region described by tensor\n \\param globalDim             - Array containing tensor size (number of elements) along each of the \\p tensorRank dimensions\n \\param globalStrides         - Array containing stride size (in bytes) along each of the \\p tensorRank - 1 dimensions\n \\param pixelBoxLowerCorner   - Array containing DHW dimentions of lower box corner\n \\param pixelBoxUpperCorner   - Array containing DHW dimentions of upper box corner\n \\param channelsPerPixel      - Number of channels per pixel\n \\param pixelsPerColumn       - Number of pixels per column\n \\param elementStrides        - Array containing traversal stride in each of the \\p tensorRank dimensions\n \\param interleave            - Type of interleaved layout the tensor addresses\n \\param swizzle               - Bank swizzling pattern inside shared memory\n \\param l2Promotion           - L2 promotion size\n \\param oobFill               - Indicate whether zero or special NaN constant must be used to fill out-of-bound elements\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTensorMapEncodeTiled,\n ::cuTensorMapReplaceAddress"]
    pub fn cuTensorMapEncodeIm2col(
        tensorMap: *mut CUtensorMap,
        tensorDataType: CUtensorMapDataType,
        tensorRank: cuuint32_t,
        globalAddress: *mut ::std::os::raw::c_void,
        globalDim: *const cuuint64_t,
        globalStrides: *const cuuint64_t,
        pixelBoxLowerCorner: *const ::std::os::raw::c_int,
        pixelBoxUpperCorner: *const ::std::os::raw::c_int,
        channelsPerPixel: cuuint32_t,
        pixelsPerColumn: cuuint32_t,
        elementStrides: *const cuuint32_t,
        interleave: CUtensorMapInterleave,
        swizzle: CUtensorMapSwizzle,
        l2Promotion: CUtensorMapL2promotion,
        oobFill: CUtensorMapFloatOOBfill,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Modify an existing tensor map descriptor with an updated global address\n\n Modifies the descriptor for Tensor Memory Access (TMA) object passed in \\p tensorMap with\n an updated \\p globalAddress.\n\n Tensor map objects are only supported on devices of compute capability 9.0 or higher.\n Additionally, a tensor map object is an opaque value, and, as such, should only be\n accessed through CUDA API calls.\n\n \\param tensorMap             - Tensor map object to modify\n \\param globalAddress         - Starting address of memory region described by tensor, must follow previous alignment requirements\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE\n\n \\sa\n ::cuTensorMapEncodeTiled,\n ::cuTensorMapEncodeIm2col"]
    pub fn cuTensorMapReplaceAddress(
        tensorMap: *mut CUtensorMap,
        globalAddress: *mut ::std::os::raw::c_void,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries if a device may directly access a peer device's memory.\n\n Returns in \\p *canAccessPeer a value of 1 if contexts on \\p dev are capable of\n directly accessing memory from contexts on \\p peerDev and 0 otherwise.\n If direct access of \\p peerDev from \\p dev is possible, then access may be\n enabled on two specific contexts by calling ::cuCtxEnablePeerAccess().\n\n \\param canAccessPeer - Returned access capability\n \\param dev           - Device from which allocations on \\p peerDev are to\n                        be directly accessed.\n \\param peerDev       - Device on which the allocations to be directly accessed\n                        by \\p dev reside.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_DEVICE\n \\notefnerr\n\n \\sa\n ::cuCtxEnablePeerAccess,\n ::cuCtxDisablePeerAccess,\n ::cudaDeviceCanAccessPeer"]
    pub fn cuDeviceCanAccessPeer(
        canAccessPeer: *mut ::std::os::raw::c_int,
        dev: CUdevice,
        peerDev: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Enables direct access to memory allocations in a peer context.\n\n If both the current context and \\p peerContext are on devices which support unified\n addressing (as may be queried using ::CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING) and same\n major compute capability, then on success all allocations from \\p peerContext will\n immediately be accessible by the current context.  See \\ref CUDA_UNIFIED for additional\n details.\n\n Note that access granted by this call is unidirectional and that in order to access\n memory from the current context in \\p peerContext, a separate symmetric call\n to ::cuCtxEnablePeerAccess() is required.\n\n Note that there are both device-wide and system-wide limitations per system\n configuration, as noted in the CUDA Programming Guide under the section\n \"Peer-to-Peer Memory Access\".\n\n Returns ::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED if ::cuDeviceCanAccessPeer() indicates\n that the ::CUdevice of the current context cannot directly access memory\n from the ::CUdevice of \\p peerContext.\n\n Returns ::CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED if direct access of\n \\p peerContext from the current context has already been enabled.\n\n Returns ::CUDA_ERROR_TOO_MANY_PEERS if direct peer access is not possible\n because hardware resources required for peer access have been exhausted.\n\n Returns ::CUDA_ERROR_INVALID_CONTEXT if there is no current context, \\p peerContext\n is not a valid context, or if the current context is \\p peerContext.\n\n Returns ::CUDA_ERROR_INVALID_VALUE if \\p Flags is not 0.\n\n \\param peerContext - Peer context to enable direct access to from the current context\n \\param Flags       - Reserved for future use and must be set to 0\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED,\n ::CUDA_ERROR_TOO_MANY_PEERS,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_PEER_ACCESS_UNSUPPORTED,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa\n ::cuDeviceCanAccessPeer,\n ::cuCtxDisablePeerAccess,\n ::cudaDeviceEnablePeerAccess"]
    pub fn cuCtxEnablePeerAccess(peerContext: CUcontext, Flags: ::std::os::raw::c_uint)
        -> CUresult;
}
extern "C" {
    #[doc = " \\brief Disables direct access to memory allocations in a peer context and\n unregisters any registered allocations.\n\nReturns ::CUDA_ERROR_PEER_ACCESS_NOT_ENABLED if direct peer access has\n not yet been enabled from \\p peerContext to the current context.\n\n Returns ::CUDA_ERROR_INVALID_CONTEXT if there is no current context, or if\n \\p peerContext is not a valid context.\n\n \\param peerContext - Peer context to disable direct access to\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_PEER_ACCESS_NOT_ENABLED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n \\notefnerr\n\n \\sa\n ::cuDeviceCanAccessPeer,\n ::cuCtxEnablePeerAccess,\n ::cudaDeviceDisablePeerAccess"]
    pub fn cuCtxDisablePeerAccess(peerContext: CUcontext) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Queries attributes of the link between two devices.\n\n Returns in \\p *value the value of the requested attribute \\p attrib of the\n link between \\p srcDevice and \\p dstDevice. The supported attributes are:\n - ::CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK: A relative value indicating the\n   performance of the link between two devices.\n - ::CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED P2P: 1 if P2P Access is enable.\n - ::CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED: 1 if Atomic operations over\n   the link are supported.\n - ::CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED: 1 if cudaArray can\n   be accessed over the link.\n\n Returns ::CUDA_ERROR_INVALID_DEVICE if \\p srcDevice or \\p dstDevice are not valid\n or if they represent the same device.\n\n Returns ::CUDA_ERROR_INVALID_VALUE if \\p attrib is not valid or if \\p value is\n a null pointer.\n\n \\param value         - Returned value of the requested attribute\n \\param attrib        - The requested attribute of the link between \\p srcDevice and \\p dstDevice.\n \\param srcDevice     - The source device of the target link.\n \\param dstDevice     - The destination device of the target link.\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_DEVICE,\n ::CUDA_ERROR_INVALID_VALUE\n \\notefnerr\n\n \\sa\n ::cuCtxEnablePeerAccess,\n ::cuCtxDisablePeerAccess,\n ::cuDeviceCanAccessPeer,\n ::cudaDeviceGetP2PAttribute"]
    pub fn cuDeviceGetP2PAttribute(
        value: *mut ::std::os::raw::c_int,
        attrib: CUdevice_P2PAttribute,
        srcDevice: CUdevice,
        dstDevice: CUdevice,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unregisters a graphics resource for access by CUDA\n\n Unregisters the graphics resource \\p resource so it is not accessible by\n CUDA unless registered again.\n\n If \\p resource is invalid then ::CUDA_ERROR_INVALID_HANDLE is\n returned.\n\n \\param resource - Resource to unregister\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_UNKNOWN\n \\notefnerr\n\n \\sa\n ::cuGraphicsD3D9RegisterResource,\n ::cuGraphicsD3D10RegisterResource,\n ::cuGraphicsD3D11RegisterResource,\n ::cuGraphicsGLRegisterBuffer,\n ::cuGraphicsGLRegisterImage,\n ::cudaGraphicsUnregisterResource"]
    pub fn cuGraphicsUnregisterResource(resource: CUgraphicsResource) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Get an array through which to access a subresource of a mapped graphics resource.\n\n Returns in \\p *pArray an array through which the subresource of the mapped\n graphics resource \\p resource which corresponds to array index \\p arrayIndex\n and mipmap level \\p mipLevel may be accessed.  The value set in \\p *pArray may\n change every time that \\p resource is mapped.\n\n If \\p resource is not a texture then it cannot be accessed via an array and\n ::CUDA_ERROR_NOT_MAPPED_AS_ARRAY is returned.\n If \\p arrayIndex is not a valid array index for \\p resource then\n ::CUDA_ERROR_INVALID_VALUE is returned.\n If \\p mipLevel is not a valid mipmap level for \\p resource then\n ::CUDA_ERROR_INVALID_VALUE is returned.\n If \\p resource is not mapped then ::CUDA_ERROR_NOT_MAPPED is returned.\n\n \\param pArray      - Returned array through which a subresource of \\p resource may be accessed\n \\param resource    - Mapped resource to access\n \\param arrayIndex  - Array index for array textures or cubemap face\n                      index as defined by ::CUarray_cubemap_face for\n                      cubemap textures for the subresource to access\n \\param mipLevel    - Mipmap level for the subresource to access\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_MAPPED,\n ::CUDA_ERROR_NOT_MAPPED_AS_ARRAY\n \\notefnerr\n\n \\sa\n ::cuGraphicsResourceGetMappedPointer,\n ::cudaGraphicsSubResourceGetMappedArray"]
    pub fn cuGraphicsSubResourceGetMappedArray(
        pArray: *mut CUarray,
        resource: CUgraphicsResource,
        arrayIndex: ::std::os::raw::c_uint,
        mipLevel: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Get a mipmapped array through which to access a mapped graphics resource.\n\n Returns in \\p *pMipmappedArray a mipmapped array through which the mapped graphics\n resource \\p resource. The value set in \\p *pMipmappedArray may change every time\n that \\p resource is mapped.\n\n If \\p resource is not a texture then it cannot be accessed via a mipmapped array and\n ::CUDA_ERROR_NOT_MAPPED_AS_ARRAY is returned.\n If \\p resource is not mapped then ::CUDA_ERROR_NOT_MAPPED is returned.\n\n \\param pMipmappedArray - Returned mipmapped array through which \\p resource may be accessed\n \\param resource        - Mapped resource to access\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_VALUE,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_MAPPED,\n ::CUDA_ERROR_NOT_MAPPED_AS_ARRAY\n \\notefnerr\n\n \\sa\n ::cuGraphicsResourceGetMappedPointer,\n ::cudaGraphicsResourceGetMappedMipmappedArray"]
    pub fn cuGraphicsResourceGetMappedMipmappedArray(
        pMipmappedArray: *mut CUmipmappedArray,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceGetMappedPointer_v2(
        pDevPtr: *mut CUdeviceptr,
        pSize: *mut usize,
        resource: CUgraphicsResource,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGraphicsResourceSetMapFlags_v2(
        resource: CUgraphicsResource,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Map graphics resources for access by CUDA\n\n Maps the \\p count graphics resources in \\p resources for access by CUDA.\n\n The resources in \\p resources may be accessed by CUDA until they\n are unmapped. The graphics API from which \\p resources were registered\n should not access any resources while they are mapped by CUDA. If an\n application does so, the results are undefined.\n\n This function provides the synchronization guarantee that any graphics calls\n issued before ::cuGraphicsMapResources() will complete before any subsequent CUDA\n work issued in \\p stream begins.\n\n If \\p resources includes any duplicate entries then ::CUDA_ERROR_INVALID_HANDLE is returned.\n If any of \\p resources are presently mapped for access by CUDA then ::CUDA_ERROR_ALREADY_MAPPED is returned.\n\n \\param count      - Number of resources to map\n \\param resources  - Resources to map for CUDA usage\n \\param hStream    - Stream with which to synchronize\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_ALREADY_MAPPED,\n ::CUDA_ERROR_UNKNOWN\n \\note_null_stream\n \\notefnerr\n\n \\sa\n ::cuGraphicsResourceGetMappedPointer,\n ::cuGraphicsSubResourceGetMappedArray,\n ::cuGraphicsUnmapResources,\n ::cudaGraphicsMapResources"]
    pub fn cuGraphicsMapResources(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    #[doc = " \\brief Unmap graphics resources.\n\n Unmaps the \\p count graphics resources in \\p resources.\n\n Once unmapped, the resources in \\p resources may not be accessed by CUDA\n until they are mapped again.\n\n This function provides the synchronization guarantee that any CUDA work issued\n in \\p stream before ::cuGraphicsUnmapResources() will complete before any\n subsequently issued graphics work begins.\n\n\n If \\p resources includes any duplicate entries then ::CUDA_ERROR_INVALID_HANDLE is returned.\n If any of \\p resources are not presently mapped for access by CUDA then ::CUDA_ERROR_NOT_MAPPED is returned.\n\n \\param count      - Number of resources to unmap\n \\param resources  - Resources to unmap\n \\param hStream    - Stream with which to synchronize\n\n \\return\n ::CUDA_SUCCESS,\n ::CUDA_ERROR_DEINITIALIZED,\n ::CUDA_ERROR_NOT_INITIALIZED,\n ::CUDA_ERROR_INVALID_CONTEXT,\n ::CUDA_ERROR_INVALID_HANDLE,\n ::CUDA_ERROR_NOT_MAPPED,\n ::CUDA_ERROR_UNKNOWN\n \\note_null_stream\n \\notefnerr\n\n \\sa\n ::cuGraphicsMapResources,\n ::cudaGraphicsUnmapResources"]
    pub fn cuGraphicsUnmapResources(
        count: ::std::os::raw::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult;
}
extern "C" {
    pub fn cuGetProcAddress_v2(
        symbol: *const ::std::os::raw::c_char,
        pfn: *mut *mut ::std::os::raw::c_void,
        cudaVersion: ::std::os::raw::c_int,
        flags: cuuint64_t,
        symbolStatus: *mut CUdriverProcAddressQueryResult,
    ) -> CUresult;
}
extern "C" {
    #[doc = " @}"]
    pub fn cuGetExportTable(
        ppExportTable: *mut *const ::std::os::raw::c_void,
        pExportTableId: *const CUuuid,
    ) -> CUresult;
}
pub type CUvideodecoder = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUcontextlock_st {
    _unused: [u8; 0],
}
pub type CUvideoctxlock = *mut _CUcontextlock_st;
#[doc = "<  MPEG1"]
pub const cudaVideoCodec_enum_cudaVideoCodec_MPEG1: cudaVideoCodec_enum = 0;
#[doc = "<  MPEG2"]
pub const cudaVideoCodec_enum_cudaVideoCodec_MPEG2: cudaVideoCodec_enum = 1;
#[doc = "<  MPEG4"]
pub const cudaVideoCodec_enum_cudaVideoCodec_MPEG4: cudaVideoCodec_enum = 2;
#[doc = "<  VC1"]
pub const cudaVideoCodec_enum_cudaVideoCodec_VC1: cudaVideoCodec_enum = 3;
#[doc = "<  H264"]
pub const cudaVideoCodec_enum_cudaVideoCodec_H264: cudaVideoCodec_enum = 4;
#[doc = "<  JPEG"]
pub const cudaVideoCodec_enum_cudaVideoCodec_JPEG: cudaVideoCodec_enum = 5;
#[doc = "<  H264-SVC"]
pub const cudaVideoCodec_enum_cudaVideoCodec_H264_SVC: cudaVideoCodec_enum = 6;
#[doc = "<  H264-MVC"]
pub const cudaVideoCodec_enum_cudaVideoCodec_H264_MVC: cudaVideoCodec_enum = 7;
#[doc = "<  HEVC"]
pub const cudaVideoCodec_enum_cudaVideoCodec_HEVC: cudaVideoCodec_enum = 8;
#[doc = "<  VP8"]
pub const cudaVideoCodec_enum_cudaVideoCodec_VP8: cudaVideoCodec_enum = 9;
#[doc = "<  VP9"]
pub const cudaVideoCodec_enum_cudaVideoCodec_VP9: cudaVideoCodec_enum = 10;
#[doc = "<  AV1"]
pub const cudaVideoCodec_enum_cudaVideoCodec_AV1: cudaVideoCodec_enum = 11;
#[doc = "<  Max codecs"]
pub const cudaVideoCodec_enum_cudaVideoCodec_NumCodecs: cudaVideoCodec_enum = 12;
#[doc = "< Y,U,V (4:2:0)"]
pub const cudaVideoCodec_enum_cudaVideoCodec_YUV420: cudaVideoCodec_enum = 1230591318;
#[doc = "< Y,V,U (4:2:0)"]
pub const cudaVideoCodec_enum_cudaVideoCodec_YV12: cudaVideoCodec_enum = 1498820914;
#[doc = "< Y,UV  (4:2:0)"]
pub const cudaVideoCodec_enum_cudaVideoCodec_NV12: cudaVideoCodec_enum = 1314271538;
#[doc = "< YUYV/YUY2 (4:2:2)"]
pub const cudaVideoCodec_enum_cudaVideoCodec_YUYV: cudaVideoCodec_enum = 1498765654;
#[doc = "< UYVY (4:2:2)"]
pub const cudaVideoCodec_enum_cudaVideoCodec_UYVY: cudaVideoCodec_enum = 1431918169;
#[doc = "/\n//! \\enum cudaVideoCodec\n//! Video codec enums\n//! These enums are used in CUVIDDECODECREATEINFO and CUVIDDECODECAPS structures\n/"]
pub type cudaVideoCodec_enum = ::std::os::raw::c_int;
#[doc = "/\n//! \\enum cudaVideoCodec\n//! Video codec enums\n//! These enums are used in CUVIDDECODECREATEINFO and CUVIDDECODECAPS structures\n/"]
pub use self::cudaVideoCodec_enum as cudaVideoCodec;
#[doc = "< Semi-Planar YUV [Y plane followed by interleaved UV plane]"]
pub const cudaVideoSurfaceFormat_enum_cudaVideoSurfaceFormat_NV12: cudaVideoSurfaceFormat_enum = 0;
#[doc = "< 16 bit Semi-Planar YUV [Y plane followed by interleaved UV plane].\nCan be used for 10 bit(6LSB bits 0), 12 bit (4LSB bits 0)"]
pub const cudaVideoSurfaceFormat_enum_cudaVideoSurfaceFormat_P016: cudaVideoSurfaceFormat_enum = 1;
#[doc = "< Planar YUV [Y plane followed by U and V planes]"]
pub const cudaVideoSurfaceFormat_enum_cudaVideoSurfaceFormat_YUV444: cudaVideoSurfaceFormat_enum =
    2;
#[doc = "< 16 bit Planar YUV [Y plane followed by U and V planes].\nCan be used for 10 bit(6LSB bits 0), 12 bit (4LSB bits 0)"]
pub const cudaVideoSurfaceFormat_enum_cudaVideoSurfaceFormat_YUV444_16Bit:
    cudaVideoSurfaceFormat_enum = 3;
#[doc = "/\n//! \\enum cudaVideoSurfaceFormat\n//! Video surface format enums used for output format of decoded output\n//! These enums are used in CUVIDDECODECREATEINFO structure\n/"]
pub type cudaVideoSurfaceFormat_enum = ::std::os::raw::c_int;
#[doc = "/\n//! \\enum cudaVideoSurfaceFormat\n//! Video surface format enums used for output format of decoded output\n//! These enums are used in CUVIDDECODECREATEINFO structure\n/"]
pub use self::cudaVideoSurfaceFormat_enum as cudaVideoSurfaceFormat;
#[doc = "< Weave both fields (no deinterlacing)"]
pub const cudaVideoDeinterlaceMode_enum_cudaVideoDeinterlaceMode_Weave:
    cudaVideoDeinterlaceMode_enum = 0;
#[doc = "< Drop one field"]
pub const cudaVideoDeinterlaceMode_enum_cudaVideoDeinterlaceMode_Bob:
    cudaVideoDeinterlaceMode_enum = 1;
#[doc = "< Adaptive deinterlacing"]
pub const cudaVideoDeinterlaceMode_enum_cudaVideoDeinterlaceMode_Adaptive:
    cudaVideoDeinterlaceMode_enum = 2;
#[doc = "/\n//! \\enum cudaVideoDeinterlaceMode\n//! Deinterlacing mode enums\n//! These enums are used in CUVIDDECODECREATEINFO structure\n//! Use cudaVideoDeinterlaceMode_Weave for progressive content and for content that doesn't need deinterlacing\n//! cudaVideoDeinterlaceMode_Adaptive needs more video memory than other DImodes\n/"]
pub type cudaVideoDeinterlaceMode_enum = ::std::os::raw::c_int;
#[doc = "/\n//! \\enum cudaVideoDeinterlaceMode\n//! Deinterlacing mode enums\n//! These enums are used in CUVIDDECODECREATEINFO structure\n//! Use cudaVideoDeinterlaceMode_Weave for progressive content and for content that doesn't need deinterlacing\n//! cudaVideoDeinterlaceMode_Adaptive needs more video memory than other DImodes\n/"]
pub use self::cudaVideoDeinterlaceMode_enum as cudaVideoDeinterlaceMode;
#[doc = "< MonoChrome"]
pub const cudaVideoChromaFormat_enum_cudaVideoChromaFormat_Monochrome: cudaVideoChromaFormat_enum =
    0;
#[doc = "< YUV 4:2:0"]
pub const cudaVideoChromaFormat_enum_cudaVideoChromaFormat_420: cudaVideoChromaFormat_enum = 1;
#[doc = "< YUV 4:2:2"]
pub const cudaVideoChromaFormat_enum_cudaVideoChromaFormat_422: cudaVideoChromaFormat_enum = 2;
#[doc = "< YUV 4:4:4"]
pub const cudaVideoChromaFormat_enum_cudaVideoChromaFormat_444: cudaVideoChromaFormat_enum = 3;
#[doc = "/\n//! \\enum cudaVideoChromaFormat\n//! Chroma format enums\n//! These enums are used in CUVIDDECODECREATEINFO and CUVIDDECODECAPS structures\n/"]
pub type cudaVideoChromaFormat_enum = ::std::os::raw::c_int;
#[doc = "/\n//! \\enum cudaVideoChromaFormat\n//! Chroma format enums\n//! These enums are used in CUVIDDECODECREATEINFO and CUVIDDECODECAPS structures\n/"]
pub use self::cudaVideoChromaFormat_enum as cudaVideoChromaFormat;
#[doc = "< Default operation mode: use dedicated video engines"]
pub const cudaVideoCreateFlags_enum_cudaVideoCreate_Default: cudaVideoCreateFlags_enum = 0;
#[doc = "< Use CUDA-based decoder (requires valid vidLock object for multi-threading)"]
pub const cudaVideoCreateFlags_enum_cudaVideoCreate_PreferCUDA: cudaVideoCreateFlags_enum = 1;
#[doc = "< Go through DXVA internally if possible (requires D3D9 interop)"]
pub const cudaVideoCreateFlags_enum_cudaVideoCreate_PreferDXVA: cudaVideoCreateFlags_enum = 2;
#[doc = "< Use dedicated video engines directly"]
pub const cudaVideoCreateFlags_enum_cudaVideoCreate_PreferCUVID: cudaVideoCreateFlags_enum = 4;
#[doc = "/\n//! \\enum cudaVideoCreateFlags\n//! Decoder flag enums to select preferred decode path\n//! cudaVideoCreate_Default and cudaVideoCreate_PreferCUVID are most optimized, use these whenever possible\n/"]
pub type cudaVideoCreateFlags_enum = ::std::os::raw::c_int;
#[doc = "/\n//! \\enum cudaVideoCreateFlags\n//! Decoder flag enums to select preferred decode path\n//! cudaVideoCreate_Default and cudaVideoCreate_PreferCUVID are most optimized, use these whenever possible\n/"]
pub use self::cudaVideoCreateFlags_enum as cudaVideoCreateFlags;
pub const cuvidDecodeStatus_enum_cuvidDecodeStatus_Invalid: cuvidDecodeStatus_enum = 0;
pub const cuvidDecodeStatus_enum_cuvidDecodeStatus_InProgress: cuvidDecodeStatus_enum = 1;
pub const cuvidDecodeStatus_enum_cuvidDecodeStatus_Success: cuvidDecodeStatus_enum = 2;
pub const cuvidDecodeStatus_enum_cuvidDecodeStatus_Error: cuvidDecodeStatus_enum = 8;
pub const cuvidDecodeStatus_enum_cuvidDecodeStatus_Error_Concealed: cuvidDecodeStatus_enum = 9;
#[doc = "/\n//! \\enum cuvidDecodeStatus\n//! Decode status enums\n//! These enums are used in CUVIDGETDECODESTATUS structure\n/"]
pub type cuvidDecodeStatus_enum = ::std::os::raw::c_int;
#[doc = "/\n//! \\enum cuvidDecodeStatus\n//! Decode status enums\n//! These enums are used in CUVIDGETDECODESTATUS structure\n/"]
pub use self::cuvidDecodeStatus_enum as cuvidDecodeStatus;
#[doc = "/\n//! \\struct CUVIDDECODECAPS;\n//! This structure is used in cuvidGetDecoderCaps API\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDDECODECAPS {
    #[doc = "< IN: cudaVideoCodec_XXX"]
    pub eCodecType: cudaVideoCodec,
    #[doc = "< IN: cudaVideoChromaFormat_XXX"]
    pub eChromaFormat: cudaVideoChromaFormat,
    #[doc = "< IN: The Value \"BitDepth minus 8\""]
    pub nBitDepthMinus8: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use - set to zero"]
    pub reserved1: [::std::os::raw::c_uint; 3usize],
    #[doc = "< OUT: 1 if codec supported, 0 if not supported"]
    pub bIsSupported: ::std::os::raw::c_uchar,
    #[doc = "< OUT: Number of NVDECs that can support IN params"]
    pub nNumNVDECs: ::std::os::raw::c_uchar,
    #[doc = "< OUT: each bit represents corresponding cudaVideoSurfaceFormat enum"]
    pub nOutputFormatMask: ::std::os::raw::c_ushort,
    #[doc = "< OUT: Max supported coded width in pixels"]
    pub nMaxWidth: ::std::os::raw::c_uint,
    #[doc = "< OUT: Max supported coded height in pixels"]
    pub nMaxHeight: ::std::os::raw::c_uint,
    #[doc = "< OUT: Max supported macroblock count\nCodedWidth*CodedHeight/256 must be <= nMaxMBCount"]
    pub nMaxMBCount: ::std::os::raw::c_uint,
    #[doc = "< OUT: Min supported coded width in pixels"]
    pub nMinWidth: ::std::os::raw::c_ushort,
    #[doc = "< OUT: Min supported coded height in pixels"]
    pub nMinHeight: ::std::os::raw::c_ushort,
    #[doc = "< OUT: 1 if Y component histogram output is supported, 0 if not\nNote: histogram is computed on original picture data before\nany post-processing like scaling, cropping, etc. is applied"]
    pub bIsHistogramSupported: ::std::os::raw::c_uchar,
    #[doc = "< OUT: histogram counter bit depth"]
    pub nCounterBitDepth: ::std::os::raw::c_uchar,
    #[doc = "< OUT: Max number of histogram bins"]
    pub nMaxHistogramBins: ::std::os::raw::c_ushort,
    #[doc = "< Reserved for future use - set to zero"]
    pub reserved3: [::std::os::raw::c_uint; 10usize],
}
#[test]
fn bindgen_test_layout__CUVIDDECODECAPS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDDECODECAPS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDDECODECAPS>(),
        88usize,
        concat!("Size of: ", stringify!(_CUVIDDECODECAPS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDDECODECAPS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDDECODECAPS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eCodecType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(eCodecType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eChromaFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(eChromaFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitDepthMinus8) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nBitDepthMinus8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsSupported) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(bIsSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nNumNVDECs) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nNumNVDECs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nOutputFormatMask) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nOutputFormatMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMaxWidth) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nMaxWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMaxHeight) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nMaxHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMaxMBCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nMaxMBCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMinWidth) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nMinWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMinHeight) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nMinHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsHistogramSupported) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(bIsHistogramSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nCounterBitDepth) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nCounterBitDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMaxHistogramBins) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(nMaxHistogramBins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECAPS),
            "::",
            stringify!(reserved3)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDDECODECAPS;\n//! This structure is used in cuvidGetDecoderCaps API\n/"]
pub type CUVIDDECODECAPS = _CUVIDDECODECAPS;
#[doc = "/\n//! \\struct CUVIDDECODECREATEINFO\n//! This structure is used in cuvidCreateDecoder API\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDDECODECREATEINFO {
    #[doc = "< IN: Coded sequence width in pixels"]
    pub ulWidth: ::std::os::raw::c_ulong,
    #[doc = "< IN: Coded sequence height in pixels"]
    pub ulHeight: ::std::os::raw::c_ulong,
    #[doc = "< IN: Maximum number of internal decode surfaces"]
    pub ulNumDecodeSurfaces: ::std::os::raw::c_ulong,
    #[doc = "< IN: cudaVideoCodec_XXX"]
    pub CodecType: cudaVideoCodec,
    #[doc = "< IN: cudaVideoChromaFormat_XXX"]
    pub ChromaFormat: cudaVideoChromaFormat,
    #[doc = "< IN: Decoder creation flags (cudaVideoCreateFlags_XXX)"]
    pub ulCreationFlags: ::std::os::raw::c_ulong,
    #[doc = "< IN: The value \"BitDepth minus 8\""]
    pub bitDepthMinus8: ::std::os::raw::c_ulong,
    #[doc = "< IN: Set 1 only if video has all intra frames (default value is 0). This will\noptimize video memory for Intra frames only decoding. The support is limited\nto specific codecs - H264, HEVC, VP9, the flag will be ignored for codecs which\nare not supported. However decoding might fail if the flag is enabled in case\nof supported codecs for regular bit streams having P and/or B frames."]
    pub ulIntraDecodeOnly: ::std::os::raw::c_ulong,
    #[doc = "< IN: Coded sequence max width in pixels used with reconfigure Decoder"]
    pub ulMaxWidth: ::std::os::raw::c_ulong,
    #[doc = "< IN: Coded sequence max height in pixels used with reconfigure Decoder"]
    pub ulMaxHeight: ::std::os::raw::c_ulong,
    #[doc = "< Reserved for future use - set to zero"]
    pub Reserved1: ::std::os::raw::c_ulong,
    pub display_area: _CUVIDDECODECREATEINFO__bindgen_ty_1,
    #[doc = "< IN: cudaVideoSurfaceFormat_XXX"]
    pub OutputFormat: cudaVideoSurfaceFormat,
    #[doc = "< IN: cudaVideoDeinterlaceMode_XXX"]
    pub DeinterlaceMode: cudaVideoDeinterlaceMode,
    #[doc = "< IN: Post-processed output width (Should be aligned to 2)"]
    pub ulTargetWidth: ::std::os::raw::c_ulong,
    #[doc = "< IN: Post-processed output height (Should be aligned to 2)"]
    pub ulTargetHeight: ::std::os::raw::c_ulong,
    #[doc = "< IN: Maximum number of output surfaces simultaneously mapped"]
    pub ulNumOutputSurfaces: ::std::os::raw::c_ulong,
    #[doc = "< IN: If non-NULL, context lock used for synchronizing ownership of\nthe cuda context. Needed for cudaVideoCreate_PreferCUDA decode"]
    pub vidLock: CUvideoctxlock,
    pub target_rect: _CUVIDDECODECREATEINFO__bindgen_ty_2,
    #[doc = "< IN: enable histogram output, if supported"]
    pub enableHistogram: ::std::os::raw::c_ulong,
    #[doc = "< Reserved for future use - set to zero"]
    pub Reserved2: [::std::os::raw::c_ulong; 4usize],
}
#[doc = " IN: area of the frame that should be displayed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDDECODECREATEINFO__bindgen_ty_1 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout__CUVIDDECODECREATEINFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDDECODECREATEINFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDDECODECREATEINFO__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDDECODECREATEINFO__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_1),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_1),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_1),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_1),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " IN: target rectangle in the output frame (for aspect ratio conversion)\n if a null rectangle is specified, {0,0,ulTargetWidth,ulTargetHeight} will be used"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDDECODECREATEINFO__bindgen_ty_2 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout__CUVIDDECODECREATEINFO__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDDECODECREATEINFO__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDDECODECREATEINFO__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDDECODECREATEINFO__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_2),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_2),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_2),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO__bindgen_ty_2),
            "::",
            stringify!(bottom)
        )
    );
}
#[test]
fn bindgen_test_layout__CUVIDDECODECREATEINFO() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDDECODECREATEINFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDDECODECREATEINFO>(),
        112usize,
        concat!("Size of: ", stringify!(_CUVIDDECODECREATEINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDDECODECREATEINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDDECODECREATEINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulNumDecodeSurfaces) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulNumDecodeSurfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodecType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(CodecType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChromaFormat) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ChromaFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulCreationFlags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulCreationFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitDepthMinus8) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(bitDepthMinus8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulIntraDecodeOnly) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulIntraDecodeOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulMaxWidth) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulMaxWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulMaxHeight) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulMaxHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_area) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(display_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutputFormat) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(OutputFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeinterlaceMode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(DeinterlaceMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulTargetWidth) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulTargetWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulTargetHeight) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulTargetHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulNumOutputSurfaces) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(ulNumOutputSurfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vidLock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(vidLock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_rect) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(target_rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableHistogram) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(enableHistogram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDDECODECREATEINFO),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDDECODECREATEINFO\n//! This structure is used in cuvidCreateDecoder API\n/"]
pub type CUVIDDECODECREATEINFO = _CUVIDDECODECREATEINFO;
#[doc = "/\n//! \\struct CUVIDH264DPBENTRY\n//! H.264 DPB entry\n//! This structure is used in CUVIDH264PICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDH264DPBENTRY {
    #[doc = "< picture index of reference frame"]
    pub PicIdx: ::std::os::raw::c_int,
    #[doc = "< frame_num(short-term) or LongTermFrameIdx(long-term)"]
    pub FrameIdx: ::std::os::raw::c_int,
    #[doc = "< 0=short term reference, 1=long term reference"]
    pub is_long_term: ::std::os::raw::c_int,
    #[doc = "< non-existing reference frame (corresponding PicIdx should be set to -1)"]
    pub not_existing: ::std::os::raw::c_int,
    #[doc = "< 0=unused, 1=top_field, 2=bottom_field, 3=both_fields"]
    pub used_for_reference: ::std::os::raw::c_int,
    #[doc = "< field order count of top and bottom fields"]
    pub FieldOrderCnt: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout__CUVIDH264DPBENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDH264DPBENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDH264DPBENTRY>(),
        28usize,
        concat!("Size of: ", stringify!(_CUVIDH264DPBENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDH264DPBENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDH264DPBENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PicIdx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264DPBENTRY),
            "::",
            stringify!(PicIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FrameIdx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264DPBENTRY),
            "::",
            stringify!(FrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_long_term) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264DPBENTRY),
            "::",
            stringify!(is_long_term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).not_existing) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264DPBENTRY),
            "::",
            stringify!(not_existing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).used_for_reference) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264DPBENTRY),
            "::",
            stringify!(used_for_reference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FieldOrderCnt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264DPBENTRY),
            "::",
            stringify!(FieldOrderCnt)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDH264DPBENTRY\n//! H.264 DPB entry\n//! This structure is used in CUVIDH264PICPARAMS structure\n/"]
pub type CUVIDH264DPBENTRY = _CUVIDH264DPBENTRY;
#[doc = "/\n//! \\struct CUVIDH264MVCEXT\n//! H.264 MVC picture parameters ext\n//! This structure is used in CUVIDH264PICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDH264MVCEXT {
    #[doc = "< Max number of coded views minus 1 in video : Range - 0 to 1023"]
    pub num_views_minus1: ::std::os::raw::c_int,
    #[doc = "< view identifier"]
    pub view_id: ::std::os::raw::c_int,
    #[doc = "< 1 if used for inter-view prediction, 0 if not"]
    pub inter_view_flag: ::std::os::raw::c_uchar,
    #[doc = "< number of inter-view ref pics in RefPicList0"]
    pub num_inter_view_refs_l0: ::std::os::raw::c_uchar,
    #[doc = "< number of inter-view ref pics in RefPicList1"]
    pub num_inter_view_refs_l1: ::std::os::raw::c_uchar,
    #[doc = "< Reserved bits"]
    pub MVCReserved8Bits: ::std::os::raw::c_uchar,
    #[doc = "< view id of the i-th view component for inter-view prediction in RefPicList0"]
    pub InterViewRefsL0: [::std::os::raw::c_int; 16usize],
    #[doc = "< view id of the i-th view component for inter-view prediction in RefPicList1"]
    pub InterViewRefsL1: [::std::os::raw::c_int; 16usize],
}
#[test]
fn bindgen_test_layout__CUVIDH264MVCEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDH264MVCEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDH264MVCEXT>(),
        140usize,
        concat!("Size of: ", stringify!(_CUVIDH264MVCEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDH264MVCEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDH264MVCEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_views_minus1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264MVCEXT),
            "::",
            stringify!(num_views_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).view_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264MVCEXT),
            "::",
            stringify!(view_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inter_view_flag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264MVCEXT),
            "::",
            stringify!(inter_view_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_inter_view_refs_l0) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264MVCEXT),
            "::",
            stringify!(num_inter_view_refs_l0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_inter_view_refs_l1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264MVCEXT),
            "::",
            stringify!(num_inter_view_refs_l1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MVCReserved8Bits) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264MVCEXT),
            "::",
            stringify!(MVCReserved8Bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InterViewRefsL0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264MVCEXT),
            "::",
            stringify!(InterViewRefsL0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InterViewRefsL1) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264MVCEXT),
            "::",
            stringify!(InterViewRefsL1)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDH264MVCEXT\n//! H.264 MVC picture parameters ext\n//! This structure is used in CUVIDH264PICPARAMS structure\n/"]
pub type CUVIDH264MVCEXT = _CUVIDH264MVCEXT;
#[doc = "/\n//! \\struct CUVIDH264SVCEXT\n//! H.264 SVC picture parameters ext\n//! This structure is used in CUVIDH264PICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDH264SVCEXT {
    pub profile_idc: ::std::os::raw::c_uchar,
    pub level_idc: ::std::os::raw::c_uchar,
    pub DQId: ::std::os::raw::c_uchar,
    pub DQIdMax: ::std::os::raw::c_uchar,
    pub disable_inter_layer_deblocking_filter_idc: ::std::os::raw::c_uchar,
    pub ref_layer_chroma_phase_y_plus1: ::std::os::raw::c_uchar,
    pub inter_layer_slice_alpha_c0_offset_div2: ::std::os::raw::c_schar,
    pub inter_layer_slice_beta_offset_div2: ::std::os::raw::c_schar,
    pub DPBEntryValidFlag: ::std::os::raw::c_ushort,
    pub inter_layer_deblocking_filter_control_present_flag: ::std::os::raw::c_uchar,
    pub extended_spatial_scalability_idc: ::std::os::raw::c_uchar,
    pub adaptive_tcoeff_level_prediction_flag: ::std::os::raw::c_uchar,
    pub slice_header_restriction_flag: ::std::os::raw::c_uchar,
    pub chroma_phase_x_plus1_flag: ::std::os::raw::c_uchar,
    pub chroma_phase_y_plus1: ::std::os::raw::c_uchar,
    pub tcoeff_level_prediction_flag: ::std::os::raw::c_uchar,
    pub constrained_intra_resampling_flag: ::std::os::raw::c_uchar,
    pub ref_layer_chroma_phase_x_plus1_flag: ::std::os::raw::c_uchar,
    pub store_ref_base_pic_flag: ::std::os::raw::c_uchar,
    pub Reserved8BitsA: ::std::os::raw::c_uchar,
    pub Reserved8BitsB: ::std::os::raw::c_uchar,
    pub scaled_ref_layer_left_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_top_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_right_offset: ::std::os::raw::c_short,
    pub scaled_ref_layer_bottom_offset: ::std::os::raw::c_short,
    pub Reserved16Bits: ::std::os::raw::c_ushort,
    #[doc = "< Points to the picparams for the next layer to be decoded.\nLinked list ends at the target layer."]
    pub pNextLayer: *mut _CUVIDPICPARAMS,
    #[doc = "< whether to store ref base pic"]
    pub bRefBaseLayer: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__CUVIDH264SVCEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDH264SVCEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDH264SVCEXT>(),
        48usize,
        concat!("Size of: ", stringify!(_CUVIDH264SVCEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDH264SVCEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDH264SVCEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_idc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(profile_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level_idc) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(level_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DQId) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(DQId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DQIdMax) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(DQIdMax)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).disable_inter_layer_deblocking_filter_idc) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(disable_inter_layer_deblocking_filter_idc)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ref_layer_chroma_phase_y_plus1) as usize - ptr as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(ref_layer_chroma_phase_y_plus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).inter_layer_slice_alpha_c0_offset_div2) as usize
                - ptr as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(inter_layer_slice_alpha_c0_offset_div2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).inter_layer_slice_beta_offset_div2) as usize - ptr as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(inter_layer_slice_beta_offset_div2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DPBEntryValidFlag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(DPBEntryValidFlag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).inter_layer_deblocking_filter_control_present_flag) as usize
                - ptr as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(inter_layer_deblocking_filter_control_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).extended_spatial_scalability_idc) as usize - ptr as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(extended_spatial_scalability_idc)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).adaptive_tcoeff_level_prediction_flag) as usize
                - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(adaptive_tcoeff_level_prediction_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).slice_header_restriction_flag) as usize - ptr as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(slice_header_restriction_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_phase_x_plus1_flag) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(chroma_phase_x_plus1_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_phase_y_plus1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(chroma_phase_y_plus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tcoeff_level_prediction_flag) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(tcoeff_level_prediction_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).constrained_intra_resampling_flag) as usize - ptr as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(constrained_intra_resampling_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ref_layer_chroma_phase_x_plus1_flag) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(ref_layer_chroma_phase_x_plus1_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).store_ref_base_pic_flag) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(store_ref_base_pic_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved8BitsA) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(Reserved8BitsA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved8BitsB) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(Reserved8BitsB)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scaled_ref_layer_left_offset) as usize - ptr as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(scaled_ref_layer_left_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaled_ref_layer_top_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(scaled_ref_layer_top_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scaled_ref_layer_right_offset) as usize - ptr as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(scaled_ref_layer_right_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).scaled_ref_layer_bottom_offset) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(scaled_ref_layer_bottom_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved16Bits) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(Reserved16Bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pNextLayer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(pNextLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bRefBaseLayer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264SVCEXT),
            "::",
            stringify!(bRefBaseLayer)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDH264SVCEXT\n//! H.264 SVC picture parameters ext\n//! This structure is used in CUVIDH264PICPARAMS structure\n/"]
pub type CUVIDH264SVCEXT = _CUVIDH264SVCEXT;
#[doc = "/\n//! \\struct CUVIDH264PICPARAMS\n//! H.264 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDH264PICPARAMS {
    pub log2_max_frame_num_minus4: ::std::os::raw::c_int,
    pub pic_order_cnt_type: ::std::os::raw::c_int,
    pub log2_max_pic_order_cnt_lsb_minus4: ::std::os::raw::c_int,
    pub delta_pic_order_always_zero_flag: ::std::os::raw::c_int,
    pub frame_mbs_only_flag: ::std::os::raw::c_int,
    pub direct_8x8_inference_flag: ::std::os::raw::c_int,
    pub num_ref_frames: ::std::os::raw::c_int,
    pub residual_colour_transform_flag: ::std::os::raw::c_uchar,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub qpprime_y_zero_transform_bypass_flag: ::std::os::raw::c_uchar,
    pub entropy_coding_mode_flag: ::std::os::raw::c_int,
    pub pic_order_present_flag: ::std::os::raw::c_int,
    pub num_ref_idx_l0_active_minus1: ::std::os::raw::c_int,
    pub num_ref_idx_l1_active_minus1: ::std::os::raw::c_int,
    pub weighted_pred_flag: ::std::os::raw::c_int,
    pub weighted_bipred_idc: ::std::os::raw::c_int,
    pub pic_init_qp_minus26: ::std::os::raw::c_int,
    pub deblocking_filter_control_present_flag: ::std::os::raw::c_int,
    pub redundant_pic_cnt_present_flag: ::std::os::raw::c_int,
    pub transform_8x8_mode_flag: ::std::os::raw::c_int,
    pub MbaffFrameFlag: ::std::os::raw::c_int,
    pub constrained_intra_pred_flag: ::std::os::raw::c_int,
    pub chroma_qp_index_offset: ::std::os::raw::c_int,
    pub second_chroma_qp_index_offset: ::std::os::raw::c_int,
    pub ref_pic_flag: ::std::os::raw::c_int,
    pub frame_num: ::std::os::raw::c_int,
    pub CurrFieldOrderCnt: [::std::os::raw::c_int; 2usize],
    pub dpb: [CUVIDH264DPBENTRY; 16usize],
    pub WeightScale4x4: [[::std::os::raw::c_uchar; 16usize]; 6usize],
    pub WeightScale8x8: [[::std::os::raw::c_uchar; 64usize]; 2usize],
    pub fmo_aso_enable: ::std::os::raw::c_uchar,
    pub num_slice_groups_minus1: ::std::os::raw::c_uchar,
    pub slice_group_map_type: ::std::os::raw::c_uchar,
    pub pic_init_qs_minus26: ::std::os::raw::c_schar,
    pub slice_group_change_rate_minus1: ::std::os::raw::c_uint,
    pub fmo: _CUVIDH264PICPARAMS__bindgen_ty_1,
    pub Reserved: [::std::os::raw::c_uint; 12usize],
    pub __bindgen_anon_1: _CUVIDH264PICPARAMS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDH264PICPARAMS__bindgen_ty_1 {
    pub slice_group_map_addr: ::std::os::raw::c_ulonglong,
    pub pMb2SliceGroupMap: *const ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__CUVIDH264PICPARAMS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDH264PICPARAMS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDH264PICPARAMS__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_CUVIDH264PICPARAMS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDH264PICPARAMS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDH264PICPARAMS__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_group_map_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS__bindgen_ty_1),
            "::",
            stringify!(slice_group_map_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pMb2SliceGroupMap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS__bindgen_ty_1),
            "::",
            stringify!(pMb2SliceGroupMap)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDH264PICPARAMS__bindgen_ty_2 {
    pub mvcext: CUVIDH264MVCEXT,
    pub svcext: CUVIDH264SVCEXT,
}
#[test]
fn bindgen_test_layout__CUVIDH264PICPARAMS__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDH264PICPARAMS__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDH264PICPARAMS__bindgen_ty_2>(),
        144usize,
        concat!("Size of: ", stringify!(_CUVIDH264PICPARAMS__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDH264PICPARAMS__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDH264PICPARAMS__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvcext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS__bindgen_ty_2),
            "::",
            stringify!(mvcext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).svcext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS__bindgen_ty_2),
            "::",
            stringify!(svcext)
        )
    );
}
#[test]
fn bindgen_test_layout__CUVIDH264PICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDH264PICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDH264PICPARAMS>(),
        984usize,
        concat!("Size of: ", stringify!(_CUVIDH264PICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDH264PICPARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDH264PICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_max_frame_num_minus4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(log2_max_frame_num_minus4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_order_cnt_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(pic_order_cnt_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_max_pic_order_cnt_lsb_minus4) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(log2_max_pic_order_cnt_lsb_minus4)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).delta_pic_order_always_zero_flag) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(delta_pic_order_always_zero_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_mbs_only_flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(frame_mbs_only_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direct_8x8_inference_flag) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(direct_8x8_inference_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_ref_frames) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(num_ref_frames)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).residual_colour_transform_flag) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(residual_colour_transform_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_luma_minus8) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(bit_depth_luma_minus8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_chroma_minus8) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(bit_depth_chroma_minus8)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).qpprime_y_zero_transform_bypass_flag) as usize
                - ptr as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(qpprime_y_zero_transform_bypass_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entropy_coding_mode_flag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(entropy_coding_mode_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_order_present_flag) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(pic_order_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_idx_l0_active_minus1) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(num_ref_idx_l0_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_idx_l1_active_minus1) as usize - ptr as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(num_ref_idx_l1_active_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weighted_pred_flag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(weighted_pred_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weighted_bipred_idc) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(weighted_bipred_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_init_qp_minus26) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(pic_init_qp_minus26)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).deblocking_filter_control_present_flag) as usize
                - ptr as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(deblocking_filter_control_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).redundant_pic_cnt_present_flag) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(redundant_pic_cnt_present_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_8x8_mode_flag) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(transform_8x8_mode_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MbaffFrameFlag) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(MbaffFrameFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constrained_intra_pred_flag) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(constrained_intra_pred_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_qp_index_offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(chroma_qp_index_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).second_chroma_qp_index_offset) as usize - ptr as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(second_chroma_qp_index_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_pic_flag) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(ref_pic_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrFieldOrderCnt) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(CurrFieldOrderCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dpb) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(dpb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WeightScale4x4) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(WeightScale4x4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WeightScale8x8) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(WeightScale8x8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmo_aso_enable) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(fmo_aso_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_slice_groups_minus1) as usize - ptr as usize },
        777usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(num_slice_groups_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_group_map_type) as usize - ptr as usize },
        778usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(slice_group_map_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_init_qs_minus26) as usize - ptr as usize },
        779usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(pic_init_qs_minus26)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).slice_group_change_rate_minus1) as usize - ptr as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(slice_group_change_rate_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmo) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(fmo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDH264PICPARAMS),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDH264PICPARAMS\n//! H.264 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDH264PICPARAMS = _CUVIDH264PICPARAMS;
#[doc = "/\n//! \\struct CUVIDMPEG2PICPARAMS\n//! MPEG-2 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDMPEG2PICPARAMS {
    pub ForwardRefIdx: ::std::os::raw::c_int,
    pub BackwardRefIdx: ::std::os::raw::c_int,
    pub picture_coding_type: ::std::os::raw::c_int,
    pub full_pel_forward_vector: ::std::os::raw::c_int,
    pub full_pel_backward_vector: ::std::os::raw::c_int,
    pub f_code: [[::std::os::raw::c_int; 2usize]; 2usize],
    pub intra_dc_precision: ::std::os::raw::c_int,
    pub frame_pred_frame_dct: ::std::os::raw::c_int,
    pub concealment_motion_vectors: ::std::os::raw::c_int,
    pub q_scale_type: ::std::os::raw::c_int,
    pub intra_vlc_format: ::std::os::raw::c_int,
    pub alternate_scan: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub QuantMatrixIntra: [::std::os::raw::c_uchar; 64usize],
    pub QuantMatrixInter: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout__CUVIDMPEG2PICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDMPEG2PICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDMPEG2PICPARAMS>(),
        192usize,
        concat!("Size of: ", stringify!(_CUVIDMPEG2PICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDMPEG2PICPARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDMPEG2PICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ForwardRefIdx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(ForwardRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BackwardRefIdx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(BackwardRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picture_coding_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(picture_coding_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_pel_forward_vector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(full_pel_forward_vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_pel_backward_vector) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(full_pel_backward_vector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_code) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(f_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_dc_precision) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_pred_frame_dct) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(frame_pred_frame_dct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).concealment_motion_vectors) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(concealment_motion_vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q_scale_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(q_scale_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_vlc_format) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(intra_vlc_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alternate_scan) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(alternate_scan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_field_first) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuantMatrixIntra) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(QuantMatrixIntra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuantMatrixInter) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG2PICPARAMS),
            "::",
            stringify!(QuantMatrixInter)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDMPEG2PICPARAMS\n//! MPEG-2 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDMPEG2PICPARAMS = _CUVIDMPEG2PICPARAMS;
#[doc = "/\n//! \\struct CUVIDMPEG4PICPARAMS\n//! MPEG-4 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDMPEG4PICPARAMS {
    pub ForwardRefIdx: ::std::os::raw::c_int,
    pub BackwardRefIdx: ::std::os::raw::c_int,
    pub video_object_layer_width: ::std::os::raw::c_int,
    pub video_object_layer_height: ::std::os::raw::c_int,
    pub vop_time_increment_bitcount: ::std::os::raw::c_int,
    pub top_field_first: ::std::os::raw::c_int,
    pub resync_marker_disable: ::std::os::raw::c_int,
    pub quant_type: ::std::os::raw::c_int,
    pub quarter_sample: ::std::os::raw::c_int,
    pub short_video_header: ::std::os::raw::c_int,
    pub divx_flags: ::std::os::raw::c_int,
    pub vop_coding_type: ::std::os::raw::c_int,
    pub vop_coded: ::std::os::raw::c_int,
    pub vop_rounding_type: ::std::os::raw::c_int,
    pub alternate_vertical_scan_flag: ::std::os::raw::c_int,
    pub interlaced: ::std::os::raw::c_int,
    pub vop_fcode_forward: ::std::os::raw::c_int,
    pub vop_fcode_backward: ::std::os::raw::c_int,
    pub trd: [::std::os::raw::c_int; 2usize],
    pub trb: [::std::os::raw::c_int; 2usize],
    pub QuantMatrixIntra: [::std::os::raw::c_uchar; 64usize],
    pub QuantMatrixInter: [::std::os::raw::c_uchar; 64usize],
    pub gmc_enabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__CUVIDMPEG4PICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDMPEG4PICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDMPEG4PICPARAMS>(),
        220usize,
        concat!("Size of: ", stringify!(_CUVIDMPEG4PICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDMPEG4PICPARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDMPEG4PICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ForwardRefIdx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(ForwardRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BackwardRefIdx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(BackwardRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_object_layer_width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(video_object_layer_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_object_layer_height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(video_object_layer_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vop_time_increment_bitcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(vop_time_increment_bitcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_field_first) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resync_marker_disable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(resync_marker_disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quant_type) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(quant_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quarter_sample) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(quarter_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_video_header) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(short_video_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).divx_flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(divx_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vop_coding_type) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(vop_coding_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vop_coded) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(vop_coded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vop_rounding_type) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(vop_rounding_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).alternate_vertical_scan_flag) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(alternate_vertical_scan_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vop_fcode_forward) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(vop_fcode_forward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vop_fcode_backward) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(vop_fcode_backward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trd) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(trd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trb) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(trb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuantMatrixIntra) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(QuantMatrixIntra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuantMatrixInter) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(QuantMatrixInter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gmc_enabled) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDMPEG4PICPARAMS),
            "::",
            stringify!(gmc_enabled)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDMPEG4PICPARAMS\n//! MPEG-4 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDMPEG4PICPARAMS = _CUVIDMPEG4PICPARAMS;
#[doc = "/\n//! \\struct CUVIDVC1PICPARAMS\n//! VC1 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDVC1PICPARAMS {
    #[doc = "< Picture index of forward reference (P/B-frames)"]
    pub ForwardRefIdx: ::std::os::raw::c_int,
    #[doc = "< Picture index of backward reference (B-frames)"]
    pub BackwardRefIdx: ::std::os::raw::c_int,
    #[doc = "< Actual frame width"]
    pub FrameWidth: ::std::os::raw::c_int,
    #[doc = "< Actual frame height"]
    pub FrameHeight: ::std::os::raw::c_int,
    #[doc = "< Set to 1 for I,BI frames"]
    pub intra_pic_flag: ::std::os::raw::c_int,
    #[doc = "< Set to 1 for I,P frames"]
    pub ref_pic_flag: ::std::os::raw::c_int,
    #[doc = "< Progressive frame"]
    pub progressive_fcm: ::std::os::raw::c_int,
    pub profile: ::std::os::raw::c_int,
    pub postprocflag: ::std::os::raw::c_int,
    pub pulldown: ::std::os::raw::c_int,
    pub interlace: ::std::os::raw::c_int,
    pub tfcntrflag: ::std::os::raw::c_int,
    pub finterpflag: ::std::os::raw::c_int,
    pub psf: ::std::os::raw::c_int,
    pub multires: ::std::os::raw::c_int,
    pub syncmarker: ::std::os::raw::c_int,
    pub rangered: ::std::os::raw::c_int,
    pub maxbframes: ::std::os::raw::c_int,
    pub panscan_flag: ::std::os::raw::c_int,
    pub refdist_flag: ::std::os::raw::c_int,
    pub extended_mv: ::std::os::raw::c_int,
    pub dquant: ::std::os::raw::c_int,
    pub vstransform: ::std::os::raw::c_int,
    pub loopfilter: ::std::os::raw::c_int,
    pub fastuvmc: ::std::os::raw::c_int,
    pub overlap: ::std::os::raw::c_int,
    pub quantizer: ::std::os::raw::c_int,
    pub extended_dmv: ::std::os::raw::c_int,
    pub range_mapy_flag: ::std::os::raw::c_int,
    pub range_mapy: ::std::os::raw::c_int,
    pub range_mapuv_flag: ::std::os::raw::c_int,
    pub range_mapuv: ::std::os::raw::c_int,
    pub rangeredfrm: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__CUVIDVC1PICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDVC1PICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDVC1PICPARAMS>(),
        132usize,
        concat!("Size of: ", stringify!(_CUVIDVC1PICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDVC1PICPARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDVC1PICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ForwardRefIdx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(ForwardRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BackwardRefIdx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(BackwardRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FrameWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(FrameWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FrameHeight) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(FrameHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_pic_flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(intra_pic_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_pic_flag) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(ref_pic_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progressive_fcm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(progressive_fcm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postprocflag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(postprocflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pulldown) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(pulldown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlace) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(interlace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tfcntrflag) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(tfcntrflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finterpflag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(finterpflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psf) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(psf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multires) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(multires)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).syncmarker) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(syncmarker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangered) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(rangered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxbframes) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(maxbframes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).panscan_flag) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(panscan_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refdist_flag) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(refdist_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extended_mv) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(extended_mv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dquant) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(dquant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vstransform) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(vstransform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loopfilter) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(loopfilter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fastuvmc) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(fastuvmc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlap) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(overlap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantizer) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(quantizer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extended_dmv) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(extended_dmv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_mapy_flag) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(range_mapy_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_mapy) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(range_mapy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_mapuv_flag) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(range_mapuv_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_mapuv) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(range_mapuv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangeredfrm) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVC1PICPARAMS),
            "::",
            stringify!(rangeredfrm)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDVC1PICPARAMS\n//! VC1 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDVC1PICPARAMS = _CUVIDVC1PICPARAMS;
#[doc = "/\n//! \\struct CUVIDJPEGPICPARAMS\n//! JPEG picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDJPEGPICPARAMS {
    pub Reserved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__CUVIDJPEGPICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDJPEGPICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDJPEGPICPARAMS>(),
        4usize,
        concat!("Size of: ", stringify!(_CUVIDJPEGPICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDJPEGPICPARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDJPEGPICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDJPEGPICPARAMS),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDJPEGPICPARAMS\n//! JPEG picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDJPEGPICPARAMS = _CUVIDJPEGPICPARAMS;
#[doc = "/\n//! \\struct CUVIDHEVCPICPARAMS\n//! HEVC picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDHEVCPICPARAMS {
    pub pic_width_in_luma_samples: ::std::os::raw::c_int,
    pub pic_height_in_luma_samples: ::std::os::raw::c_int,
    pub log2_min_luma_coding_block_size_minus3: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_luma_coding_block_size: ::std::os::raw::c_uchar,
    pub log2_min_transform_block_size_minus2: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_transform_block_size: ::std::os::raw::c_uchar,
    pub pcm_enabled_flag: ::std::os::raw::c_uchar,
    pub log2_min_pcm_luma_coding_block_size_minus3: ::std::os::raw::c_uchar,
    pub log2_diff_max_min_pcm_luma_coding_block_size: ::std::os::raw::c_uchar,
    pub pcm_sample_bit_depth_luma_minus1: ::std::os::raw::c_uchar,
    pub pcm_sample_bit_depth_chroma_minus1: ::std::os::raw::c_uchar,
    pub pcm_loop_filter_disabled_flag: ::std::os::raw::c_uchar,
    pub strong_intra_smoothing_enabled_flag: ::std::os::raw::c_uchar,
    pub max_transform_hierarchy_depth_intra: ::std::os::raw::c_uchar,
    pub max_transform_hierarchy_depth_inter: ::std::os::raw::c_uchar,
    pub amp_enabled_flag: ::std::os::raw::c_uchar,
    pub separate_colour_plane_flag: ::std::os::raw::c_uchar,
    pub log2_max_pic_order_cnt_lsb_minus4: ::std::os::raw::c_uchar,
    pub num_short_term_ref_pic_sets: ::std::os::raw::c_uchar,
    pub long_term_ref_pics_present_flag: ::std::os::raw::c_uchar,
    pub num_long_term_ref_pics_sps: ::std::os::raw::c_uchar,
    pub sps_temporal_mvp_enabled_flag: ::std::os::raw::c_uchar,
    pub sample_adaptive_offset_enabled_flag: ::std::os::raw::c_uchar,
    pub scaling_list_enable_flag: ::std::os::raw::c_uchar,
    pub IrapPicFlag: ::std::os::raw::c_uchar,
    pub IdrPicFlag: ::std::os::raw::c_uchar,
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    pub log2_max_transform_skip_block_size_minus2: ::std::os::raw::c_uchar,
    pub log2_sao_offset_scale_luma: ::std::os::raw::c_uchar,
    pub log2_sao_offset_scale_chroma: ::std::os::raw::c_uchar,
    pub high_precision_offsets_enabled_flag: ::std::os::raw::c_uchar,
    pub reserved1: [::std::os::raw::c_uchar; 10usize],
    pub dependent_slice_segments_enabled_flag: ::std::os::raw::c_uchar,
    pub slice_segment_header_extension_present_flag: ::std::os::raw::c_uchar,
    pub sign_data_hiding_enabled_flag: ::std::os::raw::c_uchar,
    pub cu_qp_delta_enabled_flag: ::std::os::raw::c_uchar,
    pub diff_cu_qp_delta_depth: ::std::os::raw::c_uchar,
    pub init_qp_minus26: ::std::os::raw::c_schar,
    pub pps_cb_qp_offset: ::std::os::raw::c_schar,
    pub pps_cr_qp_offset: ::std::os::raw::c_schar,
    pub constrained_intra_pred_flag: ::std::os::raw::c_uchar,
    pub weighted_pred_flag: ::std::os::raw::c_uchar,
    pub weighted_bipred_flag: ::std::os::raw::c_uchar,
    pub transform_skip_enabled_flag: ::std::os::raw::c_uchar,
    pub transquant_bypass_enabled_flag: ::std::os::raw::c_uchar,
    pub entropy_coding_sync_enabled_flag: ::std::os::raw::c_uchar,
    pub log2_parallel_merge_level_minus2: ::std::os::raw::c_uchar,
    pub num_extra_slice_header_bits: ::std::os::raw::c_uchar,
    pub loop_filter_across_tiles_enabled_flag: ::std::os::raw::c_uchar,
    pub loop_filter_across_slices_enabled_flag: ::std::os::raw::c_uchar,
    pub output_flag_present_flag: ::std::os::raw::c_uchar,
    pub num_ref_idx_l0_default_active_minus1: ::std::os::raw::c_uchar,
    pub num_ref_idx_l1_default_active_minus1: ::std::os::raw::c_uchar,
    pub lists_modification_present_flag: ::std::os::raw::c_uchar,
    pub cabac_init_present_flag: ::std::os::raw::c_uchar,
    pub pps_slice_chroma_qp_offsets_present_flag: ::std::os::raw::c_uchar,
    pub deblocking_filter_override_enabled_flag: ::std::os::raw::c_uchar,
    pub pps_deblocking_filter_disabled_flag: ::std::os::raw::c_uchar,
    pub pps_beta_offset_div2: ::std::os::raw::c_schar,
    pub pps_tc_offset_div2: ::std::os::raw::c_schar,
    pub tiles_enabled_flag: ::std::os::raw::c_uchar,
    pub uniform_spacing_flag: ::std::os::raw::c_uchar,
    pub num_tile_columns_minus1: ::std::os::raw::c_uchar,
    pub num_tile_rows_minus1: ::std::os::raw::c_uchar,
    pub column_width_minus1: [::std::os::raw::c_ushort; 21usize],
    pub row_height_minus1: [::std::os::raw::c_ushort; 21usize],
    pub sps_range_extension_flag: ::std::os::raw::c_uchar,
    pub transform_skip_rotation_enabled_flag: ::std::os::raw::c_uchar,
    pub transform_skip_context_enabled_flag: ::std::os::raw::c_uchar,
    pub implicit_rdpcm_enabled_flag: ::std::os::raw::c_uchar,
    pub explicit_rdpcm_enabled_flag: ::std::os::raw::c_uchar,
    pub extended_precision_processing_flag: ::std::os::raw::c_uchar,
    pub intra_smoothing_disabled_flag: ::std::os::raw::c_uchar,
    pub persistent_rice_adaptation_enabled_flag: ::std::os::raw::c_uchar,
    pub cabac_bypass_alignment_enabled_flag: ::std::os::raw::c_uchar,
    pub pps_range_extension_flag: ::std::os::raw::c_uchar,
    pub cross_component_prediction_enabled_flag: ::std::os::raw::c_uchar,
    pub chroma_qp_offset_list_enabled_flag: ::std::os::raw::c_uchar,
    pub diff_cu_chroma_qp_offset_depth: ::std::os::raw::c_uchar,
    pub chroma_qp_offset_list_len_minus1: ::std::os::raw::c_uchar,
    pub cb_qp_offset_list: [::std::os::raw::c_schar; 6usize],
    pub cr_qp_offset_list: [::std::os::raw::c_schar; 6usize],
    pub reserved2: [::std::os::raw::c_uchar; 2usize],
    pub reserved3: [::std::os::raw::c_uint; 8usize],
    pub NumBitsForShortTermRPSInSlice: ::std::os::raw::c_int,
    pub NumDeltaPocsOfRefRpsIdx: ::std::os::raw::c_int,
    pub NumPocTotalCurr: ::std::os::raw::c_int,
    pub NumPocStCurrBefore: ::std::os::raw::c_int,
    pub NumPocStCurrAfter: ::std::os::raw::c_int,
    pub NumPocLtCurr: ::std::os::raw::c_int,
    pub CurrPicOrderCntVal: ::std::os::raw::c_int,
    pub RefPicIdx: [::std::os::raw::c_int; 16usize],
    pub PicOrderCntVal: [::std::os::raw::c_int; 16usize],
    pub IsLongTerm: [::std::os::raw::c_uchar; 16usize],
    pub RefPicSetStCurrBefore: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetStCurrAfter: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetLtCurr: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetInterLayer0: [::std::os::raw::c_uchar; 8usize],
    pub RefPicSetInterLayer1: [::std::os::raw::c_uchar; 8usize],
    pub reserved4: [::std::os::raw::c_uint; 12usize],
    pub ScalingList4x4: [[::std::os::raw::c_uchar; 16usize]; 6usize],
    pub ScalingList8x8: [[::std::os::raw::c_uchar; 64usize]; 6usize],
    pub ScalingList16x16: [[::std::os::raw::c_uchar; 64usize]; 6usize],
    pub ScalingList32x32: [[::std::os::raw::c_uchar; 64usize]; 2usize],
    pub ScalingListDCCoeff16x16: [::std::os::raw::c_uchar; 6usize],
    pub ScalingListDCCoeff32x32: [::std::os::raw::c_uchar; 2usize],
}
#[test]
fn bindgen_test_layout__CUVIDHEVCPICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDHEVCPICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDHEVCPICPARAMS>(),
        1484usize,
        concat!("Size of: ", stringify!(_CUVIDHEVCPICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDHEVCPICPARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDHEVCPICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_width_in_luma_samples) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pic_width_in_luma_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_height_in_luma_samples) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pic_height_in_luma_samples)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_min_luma_coding_block_size_minus3) as usize
                - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_min_luma_coding_block_size_minus3)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_diff_max_min_luma_coding_block_size) as usize
                - ptr as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_diff_max_min_luma_coding_block_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_min_transform_block_size_minus2) as usize
                - ptr as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_min_transform_block_size_minus2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_diff_max_min_transform_block_size) as usize
                - ptr as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_diff_max_min_transform_block_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcm_enabled_flag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pcm_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_min_pcm_luma_coding_block_size_minus3) as usize
                - ptr as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_min_pcm_luma_coding_block_size_minus3)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_diff_max_min_pcm_luma_coding_block_size) as usize
                - ptr as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_diff_max_min_pcm_luma_coding_block_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pcm_sample_bit_depth_luma_minus1) as usize - ptr as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pcm_sample_bit_depth_luma_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pcm_sample_bit_depth_chroma_minus1) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pcm_sample_bit_depth_chroma_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pcm_loop_filter_disabled_flag) as usize - ptr as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pcm_loop_filter_disabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).strong_intra_smoothing_enabled_flag) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(strong_intra_smoothing_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_transform_hierarchy_depth_intra) as usize - ptr as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(max_transform_hierarchy_depth_intra)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_transform_hierarchy_depth_inter) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(max_transform_hierarchy_depth_inter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amp_enabled_flag) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(amp_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).separate_colour_plane_flag) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(separate_colour_plane_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_max_pic_order_cnt_lsb_minus4) as usize - ptr as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_max_pic_order_cnt_lsb_minus4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_short_term_ref_pic_sets) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(num_short_term_ref_pic_sets)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).long_term_ref_pics_present_flag) as usize - ptr as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(long_term_ref_pics_present_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_long_term_ref_pics_sps) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(num_long_term_ref_pics_sps)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sps_temporal_mvp_enabled_flag) as usize - ptr as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(sps_temporal_mvp_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sample_adaptive_offset_enabled_flag) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(sample_adaptive_offset_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling_list_enable_flag) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(scaling_list_enable_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IrapPicFlag) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(IrapPicFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdrPicFlag) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(IdrPicFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_luma_minus8) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(bit_depth_luma_minus8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_chroma_minus8) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(bit_depth_chroma_minus8)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_max_transform_skip_block_size_minus2) as usize
                - ptr as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_max_transform_skip_block_size_minus2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_sao_offset_scale_luma) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_sao_offset_scale_luma)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_sao_offset_scale_chroma) as usize - ptr as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_sao_offset_scale_chroma)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).high_precision_offsets_enabled_flag) as usize - ptr as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(high_precision_offsets_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dependent_slice_segments_enabled_flag) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(dependent_slice_segments_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).slice_segment_header_extension_present_flag) as usize
                - ptr as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(slice_segment_header_extension_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).sign_data_hiding_enabled_flag) as usize - ptr as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(sign_data_hiding_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cu_qp_delta_enabled_flag) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(cu_qp_delta_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).diff_cu_qp_delta_depth) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(diff_cu_qp_delta_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_qp_minus26) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(init_qp_minus26)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pps_cb_qp_offset) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pps_cb_qp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pps_cr_qp_offset) as usize - ptr as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pps_cr_qp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constrained_intra_pred_flag) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(constrained_intra_pred_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weighted_pred_flag) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(weighted_pred_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weighted_bipred_flag) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(weighted_bipred_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_skip_enabled_flag) as usize - ptr as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(transform_skip_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).transquant_bypass_enabled_flag) as usize - ptr as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(transquant_bypass_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).entropy_coding_sync_enabled_flag) as usize - ptr as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(entropy_coding_sync_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_parallel_merge_level_minus2) as usize - ptr as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(log2_parallel_merge_level_minus2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_extra_slice_header_bits) as usize - ptr as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(num_extra_slice_header_bits)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).loop_filter_across_tiles_enabled_flag) as usize
                - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(loop_filter_across_tiles_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).loop_filter_across_slices_enabled_flag) as usize
                - ptr as usize
        },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(loop_filter_across_slices_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_flag_present_flag) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(output_flag_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_idx_l0_default_active_minus1) as usize
                - ptr as usize
        },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(num_ref_idx_l0_default_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_idx_l1_default_active_minus1) as usize
                - ptr as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(num_ref_idx_l1_default_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lists_modification_present_flag) as usize - ptr as usize
        },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(lists_modification_present_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cabac_init_present_flag) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(cabac_init_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pps_slice_chroma_qp_offsets_present_flag) as usize
                - ptr as usize
        },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pps_slice_chroma_qp_offsets_present_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).deblocking_filter_override_enabled_flag) as usize
                - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(deblocking_filter_override_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pps_deblocking_filter_disabled_flag) as usize - ptr as usize
        },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pps_deblocking_filter_disabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pps_beta_offset_div2) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pps_beta_offset_div2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pps_tc_offset_div2) as usize - ptr as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pps_tc_offset_div2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tiles_enabled_flag) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(tiles_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uniform_spacing_flag) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(uniform_spacing_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_tile_columns_minus1) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(num_tile_columns_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_tile_rows_minus1) as usize - ptr as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(num_tile_rows_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_width_minus1) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(column_width_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_height_minus1) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(row_height_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sps_range_extension_flag) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(sps_range_extension_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).transform_skip_rotation_enabled_flag) as usize
                - ptr as usize
        },
        165usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(transform_skip_rotation_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).transform_skip_context_enabled_flag) as usize - ptr as usize
        },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(transform_skip_context_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).implicit_rdpcm_enabled_flag) as usize - ptr as usize },
        167usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(implicit_rdpcm_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).explicit_rdpcm_enabled_flag) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(explicit_rdpcm_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).extended_precision_processing_flag) as usize - ptr as usize
        },
        169usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(extended_precision_processing_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).intra_smoothing_disabled_flag) as usize - ptr as usize
        },
        170usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(intra_smoothing_disabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).persistent_rice_adaptation_enabled_flag) as usize
                - ptr as usize
        },
        171usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(persistent_rice_adaptation_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cabac_bypass_alignment_enabled_flag) as usize - ptr as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(cabac_bypass_alignment_enabled_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pps_range_extension_flag) as usize - ptr as usize },
        173usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(pps_range_extension_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cross_component_prediction_enabled_flag) as usize
                - ptr as usize
        },
        174usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(cross_component_prediction_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).chroma_qp_offset_list_enabled_flag) as usize - ptr as usize
        },
        175usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(chroma_qp_offset_list_enabled_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).diff_cu_chroma_qp_offset_depth) as usize - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(diff_cu_chroma_qp_offset_depth)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).chroma_qp_offset_list_len_minus1) as usize - ptr as usize
        },
        177usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(chroma_qp_offset_list_len_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_qp_offset_list) as usize - ptr as usize },
        178usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(cb_qp_offset_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_qp_offset_list) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(cr_qp_offset_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        190usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).NumBitsForShortTermRPSInSlice) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(NumBitsForShortTermRPSInSlice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumDeltaPocsOfRefRpsIdx) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(NumDeltaPocsOfRefRpsIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumPocTotalCurr) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(NumPocTotalCurr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumPocStCurrBefore) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(NumPocStCurrBefore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumPocStCurrAfter) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(NumPocStCurrAfter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumPocLtCurr) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(NumPocLtCurr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrPicOrderCntVal) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(CurrPicOrderCntVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefPicIdx) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(RefPicIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PicOrderCntVal) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(PicOrderCntVal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsLongTerm) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(IsLongTerm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefPicSetStCurrBefore) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(RefPicSetStCurrBefore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefPicSetStCurrAfter) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(RefPicSetStCurrAfter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefPicSetLtCurr) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(RefPicSetLtCurr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefPicSetInterLayer0) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(RefPicSetInterLayer0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefPicSetInterLayer1) as usize - ptr as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(RefPicSetInterLayer1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScalingList4x4) as usize - ptr as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(ScalingList4x4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScalingList8x8) as usize - ptr as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(ScalingList8x8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScalingList16x16) as usize - ptr as usize },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(ScalingList16x16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScalingList32x32) as usize - ptr as usize },
        1348usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(ScalingList32x32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScalingListDCCoeff16x16) as usize - ptr as usize },
        1476usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(ScalingListDCCoeff16x16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScalingListDCCoeff32x32) as usize - ptr as usize },
        1482usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDHEVCPICPARAMS),
            "::",
            stringify!(ScalingListDCCoeff32x32)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDHEVCPICPARAMS\n//! HEVC picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDHEVCPICPARAMS = _CUVIDHEVCPICPARAMS;
#[doc = "/\n//! \\struct CUVIDVP8PICPARAMS\n//! VP8 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDVP8PICPARAMS {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub first_partition_size: ::std::os::raw::c_uint,
    pub LastRefIdx: ::std::os::raw::c_uchar,
    pub GoldenRefIdx: ::std::os::raw::c_uchar,
    pub AltRefIdx: ::std::os::raw::c_uchar,
    pub __bindgen_anon_1: _CUVIDVP8PICPARAMS__bindgen_ty_1,
    pub Reserved1: [::std::os::raw::c_uchar; 4usize],
    pub Reserved2: [::std::os::raw::c_uint; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDVP8PICPARAMS__bindgen_ty_1 {
    pub vp8_frame_tag: _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1,
    pub wFrameTagFlags: ::std::os::raw::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _CUVIDVP8PICPARAMS__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_mb_segmentation_data(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_update_mb_segmentation_data(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2Bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved2Bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: ::std::os::raw::c_uchar,
        version: ::std::os::raw::c_uchar,
        show_frame: ::std::os::raw::c_uchar,
        update_mb_segmentation_data: ::std::os::raw::c_uchar,
        Reserved2Bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frame_type: u8 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let version: u8 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let show_frame: u8 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let update_mb_segmentation_data: u8 =
                unsafe { ::std::mem::transmute(update_mb_segmentation_data) };
            update_mb_segmentation_data as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Reserved2Bits: u8 = unsafe { ::std::mem::transmute(Reserved2Bits) };
            Reserved2Bits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__CUVIDVP8PICPARAMS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDVP8PICPARAMS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDVP8PICPARAMS__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(_CUVIDVP8PICPARAMS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDVP8PICPARAMS__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDVP8PICPARAMS__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp8_frame_tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS__bindgen_ty_1),
            "::",
            stringify!(vp8_frame_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wFrameTagFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS__bindgen_ty_1),
            "::",
            stringify!(wFrameTagFlags)
        )
    );
}
#[test]
fn bindgen_test_layout__CUVIDVP8PICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDVP8PICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDVP8PICPARAMS>(),
        32usize,
        concat!("Size of: ", stringify!(_CUVIDVP8PICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDVP8PICPARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDVP8PICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_partition_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS),
            "::",
            stringify!(first_partition_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastRefIdx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS),
            "::",
            stringify!(LastRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GoldenRefIdx) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS),
            "::",
            stringify!(GoldenRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AltRefIdx) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS),
            "::",
            stringify!(AltRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP8PICPARAMS),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDVP8PICPARAMS\n//! VP8 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDVP8PICPARAMS = _CUVIDVP8PICPARAMS;
#[doc = "/\n//! \\struct CUVIDVP9PICPARAMS\n//! VP9 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDVP9PICPARAMS {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub LastRefIdx: ::std::os::raw::c_uchar,
    pub GoldenRefIdx: ::std::os::raw::c_uchar,
    pub AltRefIdx: ::std::os::raw::c_uchar,
    pub colorSpace: ::std::os::raw::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub reserved16Bits: ::std::os::raw::c_ushort,
    pub refFrameSignBias: [::std::os::raw::c_uchar; 4usize],
    pub bitDepthMinus8Luma: ::std::os::raw::c_uchar,
    pub bitDepthMinus8Chroma: ::std::os::raw::c_uchar,
    pub loopFilterLevel: ::std::os::raw::c_uchar,
    pub loopFilterSharpness: ::std::os::raw::c_uchar,
    pub modeRefLfEnabled: ::std::os::raw::c_uchar,
    pub log2_tile_columns: ::std::os::raw::c_uchar,
    pub log2_tile_rows: ::std::os::raw::c_uchar,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub segmentFeatureEnable: [[::std::os::raw::c_uchar; 4usize]; 8usize],
    pub segmentFeatureData: [[::std::os::raw::c_short; 4usize]; 8usize],
    pub mb_segment_tree_probs: [::std::os::raw::c_uchar; 7usize],
    pub segment_pred_probs: [::std::os::raw::c_uchar; 3usize],
    pub reservedSegment16Bits: [::std::os::raw::c_uchar; 2usize],
    pub qpYAc: ::std::os::raw::c_int,
    pub qpYDc: ::std::os::raw::c_int,
    pub qpChDc: ::std::os::raw::c_int,
    pub qpChAc: ::std::os::raw::c_int,
    pub activeRefIdx: [::std::os::raw::c_uint; 3usize],
    pub resetFrameContext: ::std::os::raw::c_uint,
    pub mcomp_filter_type: ::std::os::raw::c_uint,
    pub mbRefLfDelta: [::std::os::raw::c_uint; 4usize],
    pub mbModeLfDelta: [::std::os::raw::c_uint; 2usize],
    pub frameTagSize: ::std::os::raw::c_uint,
    pub offsetToDctParts: ::std::os::raw::c_uint,
    pub reserved128Bits: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout__CUVIDVP9PICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDVP9PICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDVP9PICPARAMS>(),
        220usize,
        concat!("Size of: ", stringify!(_CUVIDVP9PICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDVP9PICPARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDVP9PICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastRefIdx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(LastRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GoldenRefIdx) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(GoldenRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AltRefIdx) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(AltRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorSpace) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(colorSpace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved16Bits) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(reserved16Bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refFrameSignBias) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(refFrameSignBias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitDepthMinus8Luma) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(bitDepthMinus8Luma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitDepthMinus8Chroma) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(bitDepthMinus8Chroma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loopFilterLevel) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(loopFilterLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loopFilterSharpness) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(loopFilterSharpness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modeRefLfEnabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(modeRefLfEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_tile_columns) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(log2_tile_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_tile_rows) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(log2_tile_rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentFeatureEnable) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(segmentFeatureEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentFeatureData) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(segmentFeatureData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_segment_tree_probs) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(mb_segment_tree_probs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segment_pred_probs) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(segment_pred_probs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedSegment16Bits) as usize - ptr as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(reservedSegment16Bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpYAc) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(qpYAc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpYDc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(qpYDc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpChDc) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(qpChDc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpChAc) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(qpChAc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activeRefIdx) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(activeRefIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resetFrameContext) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(resetFrameContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcomp_filter_type) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(mcomp_filter_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbRefLfDelta) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(mbRefLfDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbModeLfDelta) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(mbModeLfDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameTagSize) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(frameTagSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetToDctParts) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(offsetToDctParts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved128Bits) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDVP9PICPARAMS),
            "::",
            stringify!(reserved128Bits)
        )
    );
}
impl _CUVIDVP9PICPARAMS {
    #[inline]
    pub fn profile(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_profile(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn frameContextIdx(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_frameContextIdx(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn frameType(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_frameType(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn showFrame(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_showFrame(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errorResilient(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_errorResilient(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frameParallelDecoding(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_frameParallelDecoding(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subSamplingX(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_subSamplingX(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subSamplingY(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_subSamplingY(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intraOnly(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_intraOnly(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refreshEntropyProbs(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_refreshEntropyProbs(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2Bits(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_reserved2Bits(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile: ::std::os::raw::c_ushort,
        frameContextIdx: ::std::os::raw::c_ushort,
        frameType: ::std::os::raw::c_ushort,
        showFrame: ::std::os::raw::c_ushort,
        errorResilient: ::std::os::raw::c_ushort,
        frameParallelDecoding: ::std::os::raw::c_ushort,
        subSamplingX: ::std::os::raw::c_ushort,
        subSamplingY: ::std::os::raw::c_ushort,
        intraOnly: ::std::os::raw::c_ushort,
        allow_high_precision_mv: ::std::os::raw::c_ushort,
        refreshEntropyProbs: ::std::os::raw::c_ushort,
        reserved2Bits: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let profile: u16 = unsafe { ::std::mem::transmute(profile) };
            profile as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let frameContextIdx: u16 = unsafe { ::std::mem::transmute(frameContextIdx) };
            frameContextIdx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frameType: u16 = unsafe { ::std::mem::transmute(frameType) };
            frameType as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let showFrame: u16 = unsafe { ::std::mem::transmute(showFrame) };
            showFrame as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let errorResilient: u16 = unsafe { ::std::mem::transmute(errorResilient) };
            errorResilient as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let frameParallelDecoding: u16 =
                unsafe { ::std::mem::transmute(frameParallelDecoding) };
            frameParallelDecoding as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let subSamplingX: u16 = unsafe { ::std::mem::transmute(subSamplingX) };
            subSamplingX as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let subSamplingY: u16 = unsafe { ::std::mem::transmute(subSamplingY) };
            subSamplingY as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let intraOnly: u16 = unsafe { ::std::mem::transmute(intraOnly) };
            intraOnly as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let allow_high_precision_mv: u16 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let refreshEntropyProbs: u16 = unsafe { ::std::mem::transmute(refreshEntropyProbs) };
            refreshEntropyProbs as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let reserved2Bits: u16 = unsafe { ::std::mem::transmute(reserved2Bits) };
            reserved2Bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn segmentEnabled(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentEnabled(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentMapUpdate(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentMapUpdate(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentMapTemporalUpdate(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentMapTemporalUpdate(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentFeatureMode(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentFeatureMode(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4Bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4Bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        segmentEnabled: ::std::os::raw::c_uchar,
        segmentMapUpdate: ::std::os::raw::c_uchar,
        segmentMapTemporalUpdate: ::std::os::raw::c_uchar,
        segmentFeatureMode: ::std::os::raw::c_uchar,
        reserved4Bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segmentEnabled: u8 = unsafe { ::std::mem::transmute(segmentEnabled) };
            segmentEnabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let segmentMapUpdate: u8 = unsafe { ::std::mem::transmute(segmentMapUpdate) };
            segmentMapUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let segmentMapTemporalUpdate: u8 =
                unsafe { ::std::mem::transmute(segmentMapTemporalUpdate) };
            segmentMapTemporalUpdate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segmentFeatureMode: u8 = unsafe { ::std::mem::transmute(segmentFeatureMode) };
            segmentFeatureMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved4Bits: u8 = unsafe { ::std::mem::transmute(reserved4Bits) };
            reserved4Bits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "/\n//! \\struct CUVIDVP9PICPARAMS\n//! VP9 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDVP9PICPARAMS = _CUVIDVP9PICPARAMS;
#[doc = "/\n//! \\struct CUVIDAV1PICPARAMS\n//! AV1 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDAV1PICPARAMS {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub frame_offset: ::std::os::raw::c_uint,
    pub decodePicIdx: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
    pub tile_widths: [::std::os::raw::c_ushort; 64usize],
    pub tile_heights: [::std::os::raw::c_ushort; 64usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cdef_y_strength: [::std::os::raw::c_uchar; 8usize],
    pub cdef_uv_strength: [::std::os::raw::c_uchar; 8usize],
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub base_qindex: ::std::os::raw::c_uchar,
    pub qp_y_dc_delta_q: ::std::os::raw::c_char,
    pub qp_u_dc_delta_q: ::std::os::raw::c_char,
    pub qp_v_dc_delta_q: ::std::os::raw::c_char,
    pub qp_u_ac_delta_q: ::std::os::raw::c_char,
    pub qp_v_ac_delta_q: ::std::os::raw::c_char,
    pub qm_y: ::std::os::raw::c_uchar,
    pub qm_u: ::std::os::raw::c_uchar,
    pub qm_v: ::std::os::raw::c_uchar,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub segmentation_feature_data: [[::std::os::raw::c_short; 8usize]; 8usize],
    pub segmentation_feature_mask: [::std::os::raw::c_uchar; 8usize],
    pub loop_filter_level: [::std::os::raw::c_uchar; 2usize],
    pub loop_filter_level_u: ::std::os::raw::c_uchar,
    pub loop_filter_level_v: ::std::os::raw::c_uchar,
    pub loop_filter_sharpness: ::std::os::raw::c_uchar,
    pub loop_filter_ref_deltas: [::std::os::raw::c_char; 8usize],
    pub loop_filter_mode_deltas: [::std::os::raw::c_char; 2usize],
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub lr_unit_size: [::std::os::raw::c_uchar; 3usize],
    pub lr_type: [::std::os::raw::c_uchar; 3usize],
    pub primary_ref_frame: ::std::os::raw::c_uchar,
    pub ref_frame_map: [::std::os::raw::c_uchar; 8usize],
    pub _bitfield_align_6: [u8; 0],
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved5_32bits: [::std::os::raw::c_uchar; 4usize],
    pub ref_frame: [_CUVIDAV1PICPARAMS__bindgen_ty_1; 7usize],
    pub global_motion: [_CUVIDAV1PICPARAMS__bindgen_ty_2; 7usize],
    pub _bitfield_align_7: [u8; 0],
    pub _bitfield_7: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub num_y_points: ::std::os::raw::c_uchar,
    pub scaling_points_y: [[::std::os::raw::c_uchar; 2usize]; 14usize],
    pub num_cb_points: ::std::os::raw::c_uchar,
    pub scaling_points_cb: [[::std::os::raw::c_uchar; 2usize]; 10usize],
    pub num_cr_points: ::std::os::raw::c_uchar,
    pub scaling_points_cr: [[::std::os::raw::c_uchar; 2usize]; 10usize],
    pub reserved7_8bits: ::std::os::raw::c_uchar,
    pub random_seed: ::std::os::raw::c_ushort,
    pub ar_coeffs_y: [::std::os::raw::c_short; 24usize],
    pub ar_coeffs_cb: [::std::os::raw::c_short; 25usize],
    pub ar_coeffs_cr: [::std::os::raw::c_short; 25usize],
    pub cb_mult: ::std::os::raw::c_uchar,
    pub cb_luma_mult: ::std::os::raw::c_uchar,
    pub cb_offset: ::std::os::raw::c_short,
    pub cr_mult: ::std::os::raw::c_uchar,
    pub cr_luma_mult: ::std::os::raw::c_uchar,
    pub cr_offset: ::std::os::raw::c_short,
    pub reserved: [::std::os::raw::c_int; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDAV1PICPARAMS__bindgen_ty_1 {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub index: ::std::os::raw::c_uchar,
    pub reserved24Bits: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout__CUVIDAV1PICPARAMS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDAV1PICPARAMS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDAV1PICPARAMS__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDAV1PICPARAMS__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_1),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved24Bits) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_1),
            "::",
            stringify!(reserved24Bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDAV1PICPARAMS__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved24Bits: [::std::os::raw::c_char; 3usize],
    pub wmmat: [::std::os::raw::c_int; 6usize],
}
#[test]
fn bindgen_test_layout__CUVIDAV1PICPARAMS__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDAV1PICPARAMS__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDAV1PICPARAMS__bindgen_ty_2>(),
        28usize,
        concat!("Size of: ", stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDAV1PICPARAMS__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved24Bits) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_2),
            "::",
            stringify!(reserved24Bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wmmat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS__bindgen_ty_2),
            "::",
            stringify!(wmmat)
        )
    );
}
impl _CUVIDAV1PICPARAMS__bindgen_ty_2 {
    #[inline]
    pub fn invalid(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_invalid(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wmtype(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_wmtype(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5Bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved5Bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        invalid: ::std::os::raw::c_uchar,
        wmtype: ::std::os::raw::c_uchar,
        reserved5Bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let invalid: u8 = unsafe { ::std::mem::transmute(invalid) };
            invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let wmtype: u8 = unsafe { ::std::mem::transmute(wmtype) };
            wmtype as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved5Bits: u8 = unsafe { ::std::mem::transmute(reserved5Bits) };
            reserved5Bits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__CUVIDAV1PICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDAV1PICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDAV1PICPARAMS>(),
        1024usize,
        concat!("Size of: ", stringify!(_CUVIDAV1PICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDAV1PICPARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDAV1PICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(frame_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decodePicIdx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(decodePicIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_widths) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(tile_widths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile_heights) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(tile_heights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdef_y_strength) as usize - ptr as usize },
        285usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(cdef_y_strength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdef_uv_strength) as usize - ptr as usize },
        293usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(cdef_uv_strength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_qindex) as usize - ptr as usize },
        302usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(base_qindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qp_y_dc_delta_q) as usize - ptr as usize },
        303usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(qp_y_dc_delta_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qp_u_dc_delta_q) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(qp_u_dc_delta_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qp_v_dc_delta_q) as usize - ptr as usize },
        305usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(qp_v_dc_delta_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qp_u_ac_delta_q) as usize - ptr as usize },
        306usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(qp_u_ac_delta_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qp_v_ac_delta_q) as usize - ptr as usize },
        307usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(qp_v_ac_delta_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qm_y) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(qm_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qm_u) as usize - ptr as usize },
        309usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(qm_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qm_v) as usize - ptr as usize },
        310usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(qm_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentation_feature_data) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(segmentation_feature_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentation_feature_mask) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(segmentation_feature_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_filter_level) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(loop_filter_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_filter_level_u) as usize - ptr as usize },
        450usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(loop_filter_level_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_filter_level_v) as usize - ptr as usize },
        451usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(loop_filter_level_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_filter_sharpness) as usize - ptr as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(loop_filter_sharpness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_filter_ref_deltas) as usize - ptr as usize },
        453usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(loop_filter_ref_deltas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_filter_mode_deltas) as usize - ptr as usize },
        461usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(loop_filter_mode_deltas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lr_unit_size) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(lr_unit_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lr_type) as usize - ptr as usize },
        467usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(lr_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primary_ref_frame) as usize - ptr as usize },
        470usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(primary_ref_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_frame_map) as usize - ptr as usize },
        471usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(ref_frame_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved5_32bits) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(reserved5_32bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_frame) as usize - ptr as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(ref_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_motion) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(global_motion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_y_points) as usize - ptr as usize },
        766usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(num_y_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling_points_y) as usize - ptr as usize },
        767usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(scaling_points_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cb_points) as usize - ptr as usize },
        795usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(num_cb_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling_points_cb) as usize - ptr as usize },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(scaling_points_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cr_points) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(num_cr_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling_points_cr) as usize - ptr as usize },
        817usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(scaling_points_cr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved7_8bits) as usize - ptr as usize },
        837usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(reserved7_8bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).random_seed) as usize - ptr as usize },
        838usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(random_seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeffs_y) as usize - ptr as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(ar_coeffs_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeffs_cb) as usize - ptr as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(ar_coeffs_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeffs_cr) as usize - ptr as usize },
        938usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(ar_coeffs_cr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_mult) as usize - ptr as usize },
        988usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(cb_mult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_luma_mult) as usize - ptr as usize },
        989usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(cb_luma_mult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_offset) as usize - ptr as usize },
        990usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(cb_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_mult) as usize - ptr as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(cr_mult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_luma_mult) as usize - ptr as usize },
        993usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(cr_luma_mult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_offset) as usize - ptr as usize },
        994usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(cr_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        996usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDAV1PICPARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
impl _CUVIDAV1PICPARAMS {
    #[inline]
    pub fn profile(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_profile(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn use_128x128_superblock(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_128x128_superblock(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subsampling_x(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_x(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subsampling_y(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_y(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mono_chrome(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mono_chrome(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_depth_minus8(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bit_depth_minus8(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_filter_intra(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_filter_intra(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_intra_edge_filter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_intra_edge_filter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_interintra_compound(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_interintra_compound(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_masked_compound(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_masked_compound(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_dual_filter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_dual_filter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_order_hint(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_order_hint(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn order_hint_bits_minus1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_order_hint_bits_minus1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_jnt_comp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_jnt_comp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_superres(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_superres(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_cdef(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_cdef(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_restoration(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_restoration(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_fgs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_fgs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0_7bits(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0_7bits(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_type(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_cdf_update(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_cdf_update(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_screen_content_tools(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_screen_content_tools(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_integer_mv(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_integer_mv(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn coded_denom(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_coded_denom(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_intrabc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_intrabc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interp_filter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_interp_filter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn switchable_motion_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_switchable_motion_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_ref_frame_mvs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_ref_frame_mvs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_frame_end_update_cdf(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_frame_end_update_cdf(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_q_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_q_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_q_res(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_delta_q_res(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn using_qmatrix(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_using_qmatrix(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn coded_lossless(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_coded_lossless(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_superres(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_superres(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reference_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reference_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_warped_motion(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_warped_motion(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reduced_tx_set(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reduced_tx_set(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1_3bits(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1_3bits(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn num_tile_cols(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_num_tile_cols(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn num_tile_rows(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_num_tile_rows(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn context_update_tile_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_context_update_tile_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile: ::std::os::raw::c_uint,
        use_128x128_superblock: ::std::os::raw::c_uint,
        subsampling_x: ::std::os::raw::c_uint,
        subsampling_y: ::std::os::raw::c_uint,
        mono_chrome: ::std::os::raw::c_uint,
        bit_depth_minus8: ::std::os::raw::c_uint,
        enable_filter_intra: ::std::os::raw::c_uint,
        enable_intra_edge_filter: ::std::os::raw::c_uint,
        enable_interintra_compound: ::std::os::raw::c_uint,
        enable_masked_compound: ::std::os::raw::c_uint,
        enable_dual_filter: ::std::os::raw::c_uint,
        enable_order_hint: ::std::os::raw::c_uint,
        order_hint_bits_minus1: ::std::os::raw::c_uint,
        enable_jnt_comp: ::std::os::raw::c_uint,
        enable_superres: ::std::os::raw::c_uint,
        enable_cdef: ::std::os::raw::c_uint,
        enable_restoration: ::std::os::raw::c_uint,
        enable_fgs: ::std::os::raw::c_uint,
        reserved0_7bits: ::std::os::raw::c_uint,
        frame_type: ::std::os::raw::c_uint,
        show_frame: ::std::os::raw::c_uint,
        disable_cdf_update: ::std::os::raw::c_uint,
        allow_screen_content_tools: ::std::os::raw::c_uint,
        force_integer_mv: ::std::os::raw::c_uint,
        coded_denom: ::std::os::raw::c_uint,
        allow_intrabc: ::std::os::raw::c_uint,
        allow_high_precision_mv: ::std::os::raw::c_uint,
        interp_filter: ::std::os::raw::c_uint,
        switchable_motion_mode: ::std::os::raw::c_uint,
        use_ref_frame_mvs: ::std::os::raw::c_uint,
        disable_frame_end_update_cdf: ::std::os::raw::c_uint,
        delta_q_present: ::std::os::raw::c_uint,
        delta_q_res: ::std::os::raw::c_uint,
        using_qmatrix: ::std::os::raw::c_uint,
        coded_lossless: ::std::os::raw::c_uint,
        use_superres: ::std::os::raw::c_uint,
        tx_mode: ::std::os::raw::c_uint,
        reference_mode: ::std::os::raw::c_uint,
        allow_warped_motion: ::std::os::raw::c_uint,
        reduced_tx_set: ::std::os::raw::c_uint,
        skip_mode: ::std::os::raw::c_uint,
        reserved1_3bits: ::std::os::raw::c_uint,
        num_tile_cols: ::std::os::raw::c_uint,
        num_tile_rows: ::std::os::raw::c_uint,
        context_update_tile_id: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let profile: u32 = unsafe { ::std::mem::transmute(profile) };
            profile as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let use_128x128_superblock: u32 =
                unsafe { ::std::mem::transmute(use_128x128_superblock) };
            use_128x128_superblock as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let subsampling_x: u32 = unsafe { ::std::mem::transmute(subsampling_x) };
            subsampling_x as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let subsampling_y: u32 = unsafe { ::std::mem::transmute(subsampling_y) };
            subsampling_y as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mono_chrome: u32 = unsafe { ::std::mem::transmute(mono_chrome) };
            mono_chrome as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let bit_depth_minus8: u32 = unsafe { ::std::mem::transmute(bit_depth_minus8) };
            bit_depth_minus8 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enable_filter_intra: u32 = unsafe { ::std::mem::transmute(enable_filter_intra) };
            enable_filter_intra as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enable_intra_edge_filter: u32 =
                unsafe { ::std::mem::transmute(enable_intra_edge_filter) };
            enable_intra_edge_filter as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enable_interintra_compound: u32 =
                unsafe { ::std::mem::transmute(enable_interintra_compound) };
            enable_interintra_compound as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enable_masked_compound: u32 =
                unsafe { ::std::mem::transmute(enable_masked_compound) };
            enable_masked_compound as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enable_dual_filter: u32 = unsafe { ::std::mem::transmute(enable_dual_filter) };
            enable_dual_filter as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enable_order_hint: u32 = unsafe { ::std::mem::transmute(enable_order_hint) };
            enable_order_hint as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let order_hint_bits_minus1: u32 =
                unsafe { ::std::mem::transmute(order_hint_bits_minus1) };
            order_hint_bits_minus1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let enable_jnt_comp: u32 = unsafe { ::std::mem::transmute(enable_jnt_comp) };
            enable_jnt_comp as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let enable_superres: u32 = unsafe { ::std::mem::transmute(enable_superres) };
            enable_superres as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let enable_cdef: u32 = unsafe { ::std::mem::transmute(enable_cdef) };
            enable_cdef as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let enable_restoration: u32 = unsafe { ::std::mem::transmute(enable_restoration) };
            enable_restoration as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let enable_fgs: u32 = unsafe { ::std::mem::transmute(enable_fgs) };
            enable_fgs as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved0_7bits: u32 = unsafe { ::std::mem::transmute(reserved0_7bits) };
            reserved0_7bits as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let disable_cdf_update: u32 = unsafe { ::std::mem::transmute(disable_cdf_update) };
            disable_cdf_update as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let allow_screen_content_tools: u32 =
                unsafe { ::std::mem::transmute(allow_screen_content_tools) };
            allow_screen_content_tools as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let force_integer_mv: u32 = unsafe { ::std::mem::transmute(force_integer_mv) };
            force_integer_mv as u64
        });
        __bindgen_bitfield_unit.set(38usize, 3u8, {
            let coded_denom: u32 = unsafe { ::std::mem::transmute(coded_denom) };
            coded_denom as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let allow_intrabc: u32 = unsafe { ::std::mem::transmute(allow_intrabc) };
            allow_intrabc as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let allow_high_precision_mv: u32 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(43usize, 3u8, {
            let interp_filter: u32 = unsafe { ::std::mem::transmute(interp_filter) };
            interp_filter as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let switchable_motion_mode: u32 =
                unsafe { ::std::mem::transmute(switchable_motion_mode) };
            switchable_motion_mode as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let use_ref_frame_mvs: u32 = unsafe { ::std::mem::transmute(use_ref_frame_mvs) };
            use_ref_frame_mvs as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let disable_frame_end_update_cdf: u32 =
                unsafe { ::std::mem::transmute(disable_frame_end_update_cdf) };
            disable_frame_end_update_cdf as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let delta_q_present: u32 = unsafe { ::std::mem::transmute(delta_q_present) };
            delta_q_present as u64
        });
        __bindgen_bitfield_unit.set(50usize, 2u8, {
            let delta_q_res: u32 = unsafe { ::std::mem::transmute(delta_q_res) };
            delta_q_res as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let using_qmatrix: u32 = unsafe { ::std::mem::transmute(using_qmatrix) };
            using_qmatrix as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let coded_lossless: u32 = unsafe { ::std::mem::transmute(coded_lossless) };
            coded_lossless as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let use_superres: u32 = unsafe { ::std::mem::transmute(use_superres) };
            use_superres as u64
        });
        __bindgen_bitfield_unit.set(55usize, 2u8, {
            let tx_mode: u32 = unsafe { ::std::mem::transmute(tx_mode) };
            tx_mode as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let reference_mode: u32 = unsafe { ::std::mem::transmute(reference_mode) };
            reference_mode as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let allow_warped_motion: u32 = unsafe { ::std::mem::transmute(allow_warped_motion) };
            allow_warped_motion as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let reduced_tx_set: u32 = unsafe { ::std::mem::transmute(reduced_tx_set) };
            reduced_tx_set as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let skip_mode: u32 = unsafe { ::std::mem::transmute(skip_mode) };
            skip_mode as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let reserved1_3bits: u32 = unsafe { ::std::mem::transmute(reserved1_3bits) };
            reserved1_3bits as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let num_tile_cols: u32 = unsafe { ::std::mem::transmute(num_tile_cols) };
            num_tile_cols as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let num_tile_rows: u32 = unsafe { ::std::mem::transmute(num_tile_rows) };
            num_tile_rows as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let context_update_tile_id: u32 =
                unsafe { ::std::mem::transmute(context_update_tile_id) };
            context_update_tile_id as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cdef_damping_minus_3(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_cdef_damping_minus_3(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cdef_bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_cdef_bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2_4bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved2_4bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        cdef_damping_minus_3: ::std::os::raw::c_uchar,
        cdef_bits: ::std::os::raw::c_uchar,
        reserved2_4bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cdef_damping_minus_3: u8 = unsafe { ::std::mem::transmute(cdef_damping_minus_3) };
            cdef_damping_minus_3 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let cdef_bits: u8 = unsafe { ::std::mem::transmute(cdef_bits) };
            cdef_bits as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved2_4bits: u8 = unsafe { ::std::mem::transmute(reserved2_4bits) };
            reserved2_4bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn SkipModeFrame0(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SkipModeFrame0(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SkipModeFrame1(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SkipModeFrame1(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        SkipModeFrame0: ::std::os::raw::c_uchar,
        SkipModeFrame1: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SkipModeFrame0: u8 = unsafe { ::std::mem::transmute(SkipModeFrame0) };
            SkipModeFrame0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let SkipModeFrame1: u8 = unsafe { ::std::mem::transmute(SkipModeFrame1) };
            SkipModeFrame1 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_update_data(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_update_data(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3_4bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_4.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3_4bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_4.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        segmentation_enabled: ::std::os::raw::c_uchar,
        segmentation_update_map: ::std::os::raw::c_uchar,
        segmentation_update_data: ::std::os::raw::c_uchar,
        segmentation_temporal_update: ::std::os::raw::c_uchar,
        reserved3_4bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segmentation_enabled: u8 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let segmentation_update_map: u8 =
                unsafe { ::std::mem::transmute(segmentation_update_map) };
            segmentation_update_map as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let segmentation_update_data: u8 =
                unsafe { ::std::mem::transmute(segmentation_update_data) };
            segmentation_update_data as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segmentation_temporal_update: u8 =
                unsafe { ::std::mem::transmute(segmentation_temporal_update) };
            segmentation_temporal_update as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved3_4bits: u8 = unsafe { ::std::mem::transmute(reserved3_4bits) };
            reserved3_4bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn loop_filter_delta_enabled(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_loop_filter_delta_enabled(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_delta_update(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_loop_filter_delta_update(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_lf_present(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_delta_lf_present(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_lf_res(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_delta_lf_res(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_lf_multi(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_delta_lf_multi(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4_2bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_5.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4_2bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_5.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_5(
        loop_filter_delta_enabled: ::std::os::raw::c_uchar,
        loop_filter_delta_update: ::std::os::raw::c_uchar,
        delta_lf_present: ::std::os::raw::c_uchar,
        delta_lf_res: ::std::os::raw::c_uchar,
        delta_lf_multi: ::std::os::raw::c_uchar,
        reserved4_2bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let loop_filter_delta_enabled: u8 =
                unsafe { ::std::mem::transmute(loop_filter_delta_enabled) };
            loop_filter_delta_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let loop_filter_delta_update: u8 =
                unsafe { ::std::mem::transmute(loop_filter_delta_update) };
            loop_filter_delta_update as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let delta_lf_present: u8 = unsafe { ::std::mem::transmute(delta_lf_present) };
            delta_lf_present as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let delta_lf_res: u8 = unsafe { ::std::mem::transmute(delta_lf_res) };
            delta_lf_res as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let delta_lf_multi: u8 = unsafe { ::std::mem::transmute(delta_lf_multi) };
            delta_lf_multi as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let reserved4_2bits: u8 = unsafe { ::std::mem::transmute(reserved4_2bits) };
            reserved4_2bits as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn temporal_layer_id(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_temporal_layer_id(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_6.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn spatial_layer_id(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_6.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_spatial_layer_id(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_6.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_6(
        temporal_layer_id: ::std::os::raw::c_uchar,
        spatial_layer_id: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let temporal_layer_id: u8 = unsafe { ::std::mem::transmute(temporal_layer_id) };
            temporal_layer_id as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let spatial_layer_id: u8 = unsafe { ::std::mem::transmute(spatial_layer_id) };
            spatial_layer_id as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn apply_grain(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_apply_grain(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlap_flag(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_overlap_flag(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scaling_shift_minus8(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_scaling_shift_minus8(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn chroma_scaling_from_luma(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_chroma_scaling_from_luma(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ar_coeff_lag(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_ar_coeff_lag(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ar_coeff_shift_minus6(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(7usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_ar_coeff_shift_minus6(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn grain_scale_shift(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(9usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_grain_scale_shift(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn clip_to_restricted_range(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_clip_to_restricted_range(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6_4bits(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_7.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_reserved6_4bits(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_7.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_7(
        apply_grain: ::std::os::raw::c_ushort,
        overlap_flag: ::std::os::raw::c_ushort,
        scaling_shift_minus8: ::std::os::raw::c_ushort,
        chroma_scaling_from_luma: ::std::os::raw::c_ushort,
        ar_coeff_lag: ::std::os::raw::c_ushort,
        ar_coeff_shift_minus6: ::std::os::raw::c_ushort,
        grain_scale_shift: ::std::os::raw::c_ushort,
        clip_to_restricted_range: ::std::os::raw::c_ushort,
        reserved6_4bits: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let apply_grain: u16 = unsafe { ::std::mem::transmute(apply_grain) };
            apply_grain as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let overlap_flag: u16 = unsafe { ::std::mem::transmute(overlap_flag) };
            overlap_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let scaling_shift_minus8: u16 = unsafe { ::std::mem::transmute(scaling_shift_minus8) };
            scaling_shift_minus8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let chroma_scaling_from_luma: u16 =
                unsafe { ::std::mem::transmute(chroma_scaling_from_luma) };
            chroma_scaling_from_luma as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ar_coeff_lag: u16 = unsafe { ::std::mem::transmute(ar_coeff_lag) };
            ar_coeff_lag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let ar_coeff_shift_minus6: u16 =
                unsafe { ::std::mem::transmute(ar_coeff_shift_minus6) };
            ar_coeff_shift_minus6 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let grain_scale_shift: u16 = unsafe { ::std::mem::transmute(grain_scale_shift) };
            grain_scale_shift as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let clip_to_restricted_range: u16 =
                unsafe { ::std::mem::transmute(clip_to_restricted_range) };
            clip_to_restricted_range as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved6_4bits: u16 = unsafe { ::std::mem::transmute(reserved6_4bits) };
            reserved6_4bits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "/\n//! \\struct CUVIDAV1PICPARAMS\n//! AV1 picture parameters\n//! This structure is used in CUVIDPICPARAMS structure\n/"]
pub type CUVIDAV1PICPARAMS = _CUVIDAV1PICPARAMS;
#[doc = "/\n//! \\struct CUVIDPICPARAMS\n//! Picture parameters for decoding\n//! This structure is used in cuvidDecodePicture API\n//! IN  for cuvidDecodePicture\n/"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CUVIDPICPARAMS {
    #[doc = "< IN: Coded frame size in macroblocks"]
    pub PicWidthInMbs: ::std::os::raw::c_int,
    #[doc = "< IN: Coded frame height in macroblocks"]
    pub FrameHeightInMbs: ::std::os::raw::c_int,
    #[doc = "< IN: Output index of the current picture"]
    pub CurrPicIdx: ::std::os::raw::c_int,
    #[doc = "< IN: 0=frame picture, 1=field picture"]
    pub field_pic_flag: ::std::os::raw::c_int,
    #[doc = "< IN: 0=top field, 1=bottom field (ignored if field_pic_flag=0)"]
    pub bottom_field_flag: ::std::os::raw::c_int,
    #[doc = "< IN: Second field of a complementary field pair"]
    pub second_field: ::std::os::raw::c_int,
    #[doc = "< IN: Number of bytes in bitstream data buffer"]
    pub nBitstreamDataLen: ::std::os::raw::c_uint,
    #[doc = "< IN: Ptr to bitstream data for this picture (slice-layer)"]
    pub pBitstreamData: *const ::std::os::raw::c_uchar,
    #[doc = "< IN: Number of slices in this picture"]
    pub nNumSlices: ::std::os::raw::c_uint,
    #[doc = "< IN: nNumSlices entries, contains offset of each slice within\nthe bitstream data buffer"]
    pub pSliceDataOffsets: *const ::std::os::raw::c_uint,
    #[doc = "< IN: This picture is a reference picture"]
    pub ref_pic_flag: ::std::os::raw::c_int,
    #[doc = "< IN: This picture is entirely intra coded"]
    pub intra_pic_flag: ::std::os::raw::c_int,
    #[doc = "< Reserved for future use"]
    pub Reserved: [::std::os::raw::c_uint; 30usize],
    pub CodecSpecific: _CUVIDPICPARAMS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CUVIDPICPARAMS__bindgen_ty_1 {
    #[doc = "< Also used for MPEG-1"]
    pub mpeg2: CUVIDMPEG2PICPARAMS,
    pub h264: CUVIDH264PICPARAMS,
    pub vc1: CUVIDVC1PICPARAMS,
    pub mpeg4: CUVIDMPEG4PICPARAMS,
    pub jpeg: CUVIDJPEGPICPARAMS,
    pub hevc: CUVIDHEVCPICPARAMS,
    pub vp8: CUVIDVP8PICPARAMS,
    pub vp9: CUVIDVP9PICPARAMS,
    pub av1: CUVIDAV1PICPARAMS,
    pub CodecReserved: [::std::os::raw::c_uint; 1024usize],
}
#[test]
fn bindgen_test_layout__CUVIDPICPARAMS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDPICPARAMS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDPICPARAMS__bindgen_ty_1>(),
        4096usize,
        concat!("Size of: ", stringify!(_CUVIDPICPARAMS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDPICPARAMS__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDPICPARAMS__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpeg2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(mpeg2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h264) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(h264)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vc1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(vc1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpeg4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(mpeg4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jpeg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(jpeg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hevc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(hevc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(vp8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vp9) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(vp9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(av1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodecReserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS__bindgen_ty_1),
            "::",
            stringify!(CodecReserved)
        )
    );
}
#[test]
fn bindgen_test_layout__CUVIDPICPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDPICPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDPICPARAMS>(),
        4280usize,
        concat!("Size of: ", stringify!(_CUVIDPICPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDPICPARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDPICPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PicWidthInMbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(PicWidthInMbs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FrameHeightInMbs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(FrameHeightInMbs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrPicIdx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(CurrPicIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_pic_flag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(field_pic_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom_field_flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(bottom_field_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).second_field) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(second_field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitstreamDataLen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(nBitstreamDataLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBitstreamData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(pBitstreamData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nNumSlices) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(nNumSlices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSliceDataOffsets) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(pSliceDataOffsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_pic_flag) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(ref_pic_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_pic_flag) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(intra_pic_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodecSpecific) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPICPARAMS),
            "::",
            stringify!(CodecSpecific)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDPICPARAMS\n//! Picture parameters for decoding\n//! This structure is used in cuvidDecodePicture API\n//! IN  for cuvidDecodePicture\n/"]
pub type CUVIDPICPARAMS = _CUVIDPICPARAMS;
#[doc = "/\n//! \\struct CUVIDPROCPARAMS\n//! Picture parameters for postprocessing\n//! This structure is used in cuvidMapVideoFrame API\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDPROCPARAMS {
    #[doc = "< IN: Input is progressive (deinterlace_mode will be ignored)"]
    pub progressive_frame: ::std::os::raw::c_int,
    #[doc = "< IN: Output the second field (ignored if deinterlace mode is Weave)"]
    pub second_field: ::std::os::raw::c_int,
    #[doc = "< IN: Input frame is top field first (1st field is top, 2nd field is bottom)"]
    pub top_field_first: ::std::os::raw::c_int,
    #[doc = "< IN: Input only contains one field (2nd field is invalid)"]
    pub unpaired_field: ::std::os::raw::c_int,
    #[doc = "< Reserved for future use (set to zero)"]
    pub reserved_flags: ::std::os::raw::c_uint,
    #[doc = "< Reserved (set to zero)"]
    pub reserved_zero: ::std::os::raw::c_uint,
    #[doc = "< IN: Input CUdeviceptr for raw YUV extensions"]
    pub raw_input_dptr: ::std::os::raw::c_ulonglong,
    #[doc = "< IN: pitch in bytes of raw YUV input (should be aligned appropriately)"]
    pub raw_input_pitch: ::std::os::raw::c_uint,
    #[doc = "< IN: Input YUV format (cudaVideoCodec_enum)"]
    pub raw_input_format: ::std::os::raw::c_uint,
    #[doc = "< IN: Output CUdeviceptr for raw YUV extensions"]
    pub raw_output_dptr: ::std::os::raw::c_ulonglong,
    #[doc = "< IN: pitch in bytes of raw YUV output (should be aligned appropriately)"]
    pub raw_output_pitch: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use (set to zero)"]
    pub Reserved1: ::std::os::raw::c_uint,
    #[doc = "< IN: stream object used by cuvidMapVideoFrame"]
    pub output_stream: CUstream,
    #[doc = "< Reserved for future use (set to zero)"]
    pub Reserved: [::std::os::raw::c_uint; 46usize],
    #[doc = "< OUT: Output CUdeviceptr for histogram extensions"]
    pub histogram_dptr: *mut ::std::os::raw::c_ulonglong,
    #[doc = "< Reserved for future use (set to zero)"]
    pub Reserved2: [*mut ::std::os::raw::c_void; 1usize],
}
#[test]
fn bindgen_test_layout__CUVIDPROCPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDPROCPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDPROCPARAMS>(),
        264usize,
        concat!("Size of: ", stringify!(_CUVIDPROCPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDPROCPARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDPROCPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progressive_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(progressive_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).second_field) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(second_field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_field_first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unpaired_field) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(unpaired_field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(reserved_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_zero) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(reserved_zero)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_input_dptr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(raw_input_dptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_input_pitch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(raw_input_pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_input_format) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(raw_input_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_output_dptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(raw_output_dptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_output_pitch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(raw_output_pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_stream) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(output_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).histogram_dptr) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(histogram_dptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPROCPARAMS),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDPROCPARAMS\n//! Picture parameters for postprocessing\n//! This structure is used in cuvidMapVideoFrame API\n/"]
pub type CUVIDPROCPARAMS = _CUVIDPROCPARAMS;
#[doc = "/\n//! \\struct CUVIDGETDECODESTATUS\n//! Struct for reporting decode status.\n//! This structure is used in cuvidGetDecodeStatus API.\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDGETDECODESTATUS {
    pub decodeStatus: cuvidDecodeStatus,
    pub reserved: [::std::os::raw::c_uint; 31usize],
    pub pReserved: [*mut ::std::os::raw::c_void; 8usize],
}
#[test]
fn bindgen_test_layout__CUVIDGETDECODESTATUS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDGETDECODESTATUS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDGETDECODESTATUS>(),
        192usize,
        concat!("Size of: ", stringify!(_CUVIDGETDECODESTATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDGETDECODESTATUS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDGETDECODESTATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decodeStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDGETDECODESTATUS),
            "::",
            stringify!(decodeStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDGETDECODESTATUS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pReserved) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDGETDECODESTATUS),
            "::",
            stringify!(pReserved)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDGETDECODESTATUS\n//! Struct for reporting decode status.\n//! This structure is used in cuvidGetDecodeStatus API.\n/"]
pub type CUVIDGETDECODESTATUS = _CUVIDGETDECODESTATUS;
#[doc = "/\n//! \\struct CUVIDRECONFIGUREDECODERINFO\n//! Struct for decoder reset\n//! This structure is used in cuvidReconfigureDecoder() API\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDRECONFIGUREDECODERINFO {
    #[doc = "< IN: Coded sequence width in pixels, MUST be < = ulMaxWidth defined at CUVIDDECODECREATEINFO"]
    pub ulWidth: ::std::os::raw::c_uint,
    #[doc = "< IN: Coded sequence height in pixels, MUST be < = ulMaxHeight defined at CUVIDDECODECREATEINFO"]
    pub ulHeight: ::std::os::raw::c_uint,
    #[doc = "< IN: Post processed output width"]
    pub ulTargetWidth: ::std::os::raw::c_uint,
    #[doc = "< IN: Post Processed output height"]
    pub ulTargetHeight: ::std::os::raw::c_uint,
    #[doc = "< IN: Maximum number of internal decode surfaces"]
    pub ulNumDecodeSurfaces: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use. Set to Zero"]
    pub reserved1: [::std::os::raw::c_uint; 12usize],
    pub display_area: _CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1,
    pub target_rect: _CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2,
    #[doc = "< Reserved for future use. Set to Zero"]
    pub reserved2: [::std::os::raw::c_uint; 11usize],
}
#[doc = " IN: Area of frame to be displayed. Use-case : Source Cropping"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout__CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_1),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " IN: Target Rectangle in the OutputFrame. Use-case : Aspect ratio Conversion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2 {
    pub left: ::std::os::raw::c_short,
    pub top: ::std::os::raw::c_short,
    pub right: ::std::os::raw::c_short,
    pub bottom: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout__CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO__bindgen_ty_2),
            "::",
            stringify!(bottom)
        )
    );
}
#[test]
fn bindgen_test_layout__CUVIDRECONFIGUREDECODERINFO() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDRECONFIGUREDECODERINFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDRECONFIGUREDECODERINFO>(),
        128usize,
        concat!("Size of: ", stringify!(_CUVIDRECONFIGUREDECODERINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDRECONFIGUREDECODERINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUVIDRECONFIGUREDECODERINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(ulWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(ulHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulTargetWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(ulTargetWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulTargetHeight) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(ulTargetHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulNumDecodeSurfaces) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(ulNumDecodeSurfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_area) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(display_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_rect) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(target_rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDRECONFIGUREDECODERINFO),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = "/\n//! \\struct CUVIDRECONFIGUREDECODERINFO\n//! Struct for decoder reset\n//! This structure is used in cuvidReconfigureDecoder() API\n/"]
pub type CUVIDRECONFIGUREDECODERINFO = _CUVIDRECONFIGUREDECODERINFO;
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidGetDecoderCaps(CUVIDDECODECAPS *pdc)\n//! Queries decode capabilities of NVDEC-HW based on CodecType, ChromaFormat and BitDepthMinus8 parameters.\n//! 1. Application fills IN parameters CodecType, ChromaFormat and BitDepthMinus8 of CUVIDDECODECAPS structure\n//! 2. On calling cuvidGetDecoderCaps, driver fills OUT parameters if the IN parameters are supported\n//!    If IN parameters passed to the driver are not supported by NVDEC-HW, then all OUT params are set to 0.\n//! E.g. on Geforce GTX 960:\n//!   App fills - eCodecType = cudaVideoCodec_H264; eChromaFormat = cudaVideoChromaFormat_420; nBitDepthMinus8 = 0;\n//!   Given IN parameters are supported, hence driver fills: bIsSupported = 1; nMinWidth   = 48; nMinHeight  = 16;\n//!   nMaxWidth = 4096; nMaxHeight = 4096; nMaxMBCount = 65536;\n//! CodedWidth*CodedHeight/256 must be less than or equal to nMaxMBCount\n/"]
    pub fn cuvidGetDecoderCaps(pdc: *mut CUVIDDECODECAPS) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidCreateDecoder(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)\n//! Create the decoder object based on pdci. A handle to the created decoder is returned\n/"]
    pub fn cuvidCreateDecoder(
        phDecoder: *mut CUvideodecoder,
        pdci: *mut CUVIDDECODECREATEINFO,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidDestroyDecoder(CUvideodecoder hDecoder)\n//! Destroy the decoder object\n/"]
    pub fn cuvidDestroyDecoder(hDecoder: CUvideodecoder) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidDecodePicture(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)\n//! Decode a single picture (field or frame)\n//! Kicks off HW decoding\n/"]
    pub fn cuvidDecodePicture(
        hDecoder: CUvideodecoder,
        pPicParams: *mut CUVIDPICPARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidGetDecodeStatus(CUvideodecoder hDecoder, int nPicIdx);\n//! Get the decode status for frame corresponding to nPicIdx\n//! API is supported for Maxwell and above generation GPUs.\n//! API is currently supported for HEVC, H264 and JPEG codecs.\n//! API returns CUDA_ERROR_NOT_SUPPORTED error code for unsupported GPU or codec.\n/"]
    pub fn cuvidGetDecodeStatus(
        hDecoder: CUvideodecoder,
        nPicIdx: ::std::os::raw::c_int,
        pDecodeStatus: *mut CUVIDGETDECODESTATUS,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidReconfigureDecoder(CUvideodecoder hDecoder, CUVIDRECONFIGUREDECODERINFO *pDecReconfigParams)\n//! Used to reuse single decoder for multiple clips. Currently supports resolution change, resize params, display area\n//! params, target area params change for same codec. Must be called during CUVIDPARSERPARAMS::pfnSequenceCallback\n/"]
    pub fn cuvidReconfigureDecoder(
        hDecoder: CUvideodecoder,
        pDecReconfigParams: *mut CUVIDRECONFIGUREDECODERINFO,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidMapVideoFrame64(CUvideodecoder hDecoder, int nPicIdx, unsigned long long *pDevPtr,\n//!                                           unsigned int * pPitch, CUVIDPROCPARAMS *pVPP);\n//! Post-process and map video frame corresponding to nPicIdx for use in cuda. Returns cuda device pointer and associated\n//! pitch of the video frame\n/"]
    pub fn cuvidMapVideoFrame64(
        hDecoder: CUvideodecoder,
        nPicIdx: ::std::os::raw::c_int,
        pDevPtr: *mut ::std::os::raw::c_ulonglong,
        pPitch: *mut ::std::os::raw::c_uint,
        pVPP: *mut CUVIDPROCPARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidUnmapVideoFrame64(CUvideodecoder hDecoder, unsigned long long DevPtr);\n//! Unmap a previously mapped video frame\n/"]
    pub fn cuvidUnmapVideoFrame64(
        hDecoder: CUvideodecoder,
        DevPtr: ::std::os::raw::c_ulonglong,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidCtxLockCreate(CUvideoctxlock *pLock, CUcontext ctx)\n//! This API is used to create CtxLock object\n/"]
    pub fn cuvidCtxLockCreate(pLock: *mut CUvideoctxlock, ctx: CUcontext) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidCtxLockDestroy(CUvideoctxlock lck)\n//! This API is used to free CtxLock object\n/"]
    pub fn cuvidCtxLockDestroy(lck: CUvideoctxlock) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidCtxLock(CUvideoctxlock lck, unsigned int reserved_flags)\n//! This API is used to acquire ctxlock\n/"]
    pub fn cuvidCtxLock(lck: CUvideoctxlock, reserved_flags: ::std::os::raw::c_uint) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\fn CUresult CUDAAPI cuvidCtxUnlock(CUvideoctxlock lck, unsigned int reserved_flags)\n//! This API is used to release ctxlock\n/"]
    pub fn cuvidCtxUnlock(lck: CUvideoctxlock, reserved_flags: ::std::os::raw::c_uint) -> CUresult;
}
#[doc = "/\n//!\n//! High-level helper APIs for video sources\n//!\n/"]
pub type CUvideosource = *mut ::std::os::raw::c_void;
pub type CUvideoparser = *mut ::std::os::raw::c_void;
pub type CUvideotimestamp = ::std::os::raw::c_longlong;
#[doc = "< Error state (invalid source)"]
pub const cudaVideoState_cudaVideoState_Error: cudaVideoState = -1;
#[doc = "< Source is stopped (or reached end-of-stream)"]
pub const cudaVideoState_cudaVideoState_Stopped: cudaVideoState = 0;
#[doc = "< Source is running and delivering data"]
pub const cudaVideoState_cudaVideoState_Started: cudaVideoState = 1;
#[doc = "/\n//! \\enum cudaVideoState\n//! Video source state enums\n//! Used in cuvidSetVideoSourceState and cuvidGetVideoSourceState APIs\n/"]
pub type cudaVideoState = ::std::os::raw::c_int;
#[doc = "< MPEG-1 Audio"]
pub const cudaAudioCodec_cudaAudioCodec_MPEG1: cudaAudioCodec = 0;
#[doc = "< MPEG-2 Audio"]
pub const cudaAudioCodec_cudaAudioCodec_MPEG2: cudaAudioCodec = 1;
#[doc = "< MPEG-1 Layer III Audio"]
pub const cudaAudioCodec_cudaAudioCodec_MP3: cudaAudioCodec = 2;
#[doc = "< Dolby Digital (AC3) Audio"]
pub const cudaAudioCodec_cudaAudioCodec_AC3: cudaAudioCodec = 3;
#[doc = "< PCM Audio"]
pub const cudaAudioCodec_cudaAudioCodec_LPCM: cudaAudioCodec = 4;
#[doc = "< AAC Audio"]
pub const cudaAudioCodec_cudaAudioCodec_AAC: cudaAudioCodec = 5;
#[doc = "/\n//! \\enum cudaAudioCodec\n//! Audio compression enums\n//! Used in CUAUDIOFORMAT structure\n/"]
pub type cudaAudioCodec = ::std::os::raw::c_int;
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct HEVCTIMECODESET\n//! Used to store Time code extracted from Time code SEI in HEVC codec\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEVCTIMECODESET {
    pub time_offset_value: ::std::os::raw::c_uint,
    pub n_frames: ::std::os::raw::c_ushort,
    pub clock_timestamp_flag: ::std::os::raw::c_uchar,
    pub units_field_based_flag: ::std::os::raw::c_uchar,
    pub counting_type: ::std::os::raw::c_uchar,
    pub full_timestamp_flag: ::std::os::raw::c_uchar,
    pub discontinuity_flag: ::std::os::raw::c_uchar,
    pub cnt_dropped_flag: ::std::os::raw::c_uchar,
    pub seconds_value: ::std::os::raw::c_uchar,
    pub minutes_value: ::std::os::raw::c_uchar,
    pub hours_value: ::std::os::raw::c_uchar,
    pub seconds_flag: ::std::os::raw::c_uchar,
    pub minutes_flag: ::std::os::raw::c_uchar,
    pub hours_flag: ::std::os::raw::c_uchar,
    pub time_offset_length: ::std::os::raw::c_uchar,
    pub reserved: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__HEVCTIMECODESET() {
    const UNINIT: ::std::mem::MaybeUninit<_HEVCTIMECODESET> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_HEVCTIMECODESET>(),
        20usize,
        concat!("Size of: ", stringify!(_HEVCTIMECODESET))
    );
    assert_eq!(
        ::std::mem::align_of::<_HEVCTIMECODESET>(),
        4usize,
        concat!("Alignment of ", stringify!(_HEVCTIMECODESET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_offset_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(time_offset_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_frames) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(n_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock_timestamp_flag) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(clock_timestamp_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units_field_based_flag) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(units_field_based_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counting_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(counting_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_timestamp_flag) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(full_timestamp_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discontinuity_flag) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(discontinuity_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnt_dropped_flag) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(cnt_dropped_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds_value) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(seconds_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minutes_value) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(minutes_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hours_value) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(hours_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds_flag) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(seconds_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minutes_flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(minutes_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hours_flag) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(hours_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_offset_length) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(time_offset_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct HEVCTIMECODESET\n//! Used to store Time code extracted from Time code SEI in HEVC codec\n/"]
pub type HEVCTIMECODESET = _HEVCTIMECODESET;
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct HEVCSEITIMECODE\n//! Used to extract Time code SEI in HEVC codec\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEVCSEITIMECODE {
    pub time_code_set: [HEVCTIMECODESET; 3usize],
    pub num_clock_ts: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__HEVCSEITIMECODE() {
    const UNINIT: ::std::mem::MaybeUninit<_HEVCSEITIMECODE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_HEVCSEITIMECODE>(),
        64usize,
        concat!("Size of: ", stringify!(_HEVCSEITIMECODE))
    );
    assert_eq!(
        ::std::mem::align_of::<_HEVCSEITIMECODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_HEVCSEITIMECODE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_code_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCSEITIMECODE),
            "::",
            stringify!(time_code_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_clock_ts) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCSEITIMECODE),
            "::",
            stringify!(num_clock_ts)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct HEVCSEITIMECODE\n//! Used to extract Time code SEI in HEVC codec\n/"]
pub type HEVCSEITIMECODE = _HEVCSEITIMECODE;
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUSEIMESSAGE;\n//! Used in CUVIDSEIMESSAGEINFO structure\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUSEIMESSAGE {
    #[doc = "< OUT: SEI Message Type"]
    pub sei_message_type: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
    #[doc = "< OUT: SEI Message Size"]
    pub sei_message_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__CUSEIMESSAGE() {
    const UNINIT: ::std::mem::MaybeUninit<_CUSEIMESSAGE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUSEIMESSAGE>(),
        8usize,
        concat!("Size of: ", stringify!(_CUSEIMESSAGE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUSEIMESSAGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUSEIMESSAGE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sei_message_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUSEIMESSAGE),
            "::",
            stringify!(sei_message_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUSEIMESSAGE),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sei_message_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUSEIMESSAGE),
            "::",
            stringify!(sei_message_size)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUSEIMESSAGE;\n//! Used in CUVIDSEIMESSAGEINFO structure\n/"]
pub type CUSEIMESSAGE = _CUSEIMESSAGE;
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDEOFORMAT\n//! Video format\n//! Used in cuvidGetSourceVideoFormat API\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUVIDEOFORMAT {
    #[doc = "< OUT: Compression format"]
    pub codec: cudaVideoCodec,
    pub frame_rate: CUVIDEOFORMAT__bindgen_ty_1,
    #[doc = "< OUT: 0=interlaced, 1=progressive"]
    pub progressive_sequence: ::std::os::raw::c_uchar,
    #[doc = "< OUT: high bit depth luma. E.g, 2 for 10-bitdepth, 4 for 12-bitdepth"]
    pub bit_depth_luma_minus8: ::std::os::raw::c_uchar,
    #[doc = "< OUT: high bit depth chroma. E.g, 2 for 10-bitdepth, 4 for 12-bitdepth"]
    pub bit_depth_chroma_minus8: ::std::os::raw::c_uchar,
    #[doc = "< OUT: Minimum number of decode surfaces to be allocated for correct\ndecoding. The client can send this value in ulNumDecodeSurfaces\n(in CUVIDDECODECREATEINFO structure).\nThis guarantees correct functionality and optimal video memory\nusage but not necessarily the best performance, which depends on\nthe design of the overall application. The optimal number of\ndecode surfaces (in terms of performance and memory utilization)\nshould be decided by experimentation for each application, but it\ncannot go below min_num_decode_surfaces.\nIf this value is used for ulNumDecodeSurfaces then it must be\nreturned to parser during sequence callback."]
    pub min_num_decode_surfaces: ::std::os::raw::c_uchar,
    #[doc = "< OUT: coded frame width in pixels"]
    pub coded_width: ::std::os::raw::c_uint,
    #[doc = "< OUT: coded frame height in pixels"]
    pub coded_height: ::std::os::raw::c_uint,
    pub display_area: CUVIDEOFORMAT__bindgen_ty_2,
    #[doc = "< OUT:  Chroma format"]
    pub chroma_format: cudaVideoChromaFormat,
    #[doc = "< OUT: video bitrate (bps, 0=unknown)"]
    pub bitrate: ::std::os::raw::c_uint,
    pub display_aspect_ratio: CUVIDEOFORMAT__bindgen_ty_3,
    pub video_signal_description: CUVIDEOFORMAT__bindgen_ty_4,
    #[doc = "< OUT: Additional bytes following (CUVIDEOFORMATEX)"]
    pub seqhdr_data_length: ::std::os::raw::c_uint,
}
#[doc = " OUT: frame rate = numerator / denominator (for example: 30000/1001)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUVIDEOFORMAT__bindgen_ty_1 {
    pub numerator: ::std::os::raw::c_uint,
    pub denominator: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDEOFORMAT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_1),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_1),
            "::",
            stringify!(denominator)
        )
    );
}
#[doc = " area of the frame that should be displayed\n typical example:\n coded_width = 1920, coded_height = 1088\n display_area = { 0,0,1920,1080 }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUVIDEOFORMAT__bindgen_ty_2 {
    #[doc = "< OUT: left position of display rect"]
    pub left: ::std::os::raw::c_int,
    #[doc = "< OUT: top position of display rect"]
    pub top: ::std::os::raw::c_int,
    #[doc = "< OUT: right position of display rect"]
    pub right: ::std::os::raw::c_int,
    #[doc = "< OUT: bottom position of display rect"]
    pub bottom: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDEOFORMAT__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_2),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_2),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_2),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_2),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " OUT: Display Aspect Ratio = x:y (4:3, 16:9, etc)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUVIDEOFORMAT__bindgen_ty_3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDEOFORMAT__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_3),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " Video Signal Description\n Refer section E.2.1 (VUI parameters semantics) of H264 spec file"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUVIDEOFORMAT__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< OUT: chromaticity coordinates of source primaries"]
    pub color_primaries: ::std::os::raw::c_uchar,
    #[doc = "< OUT: opto-electronic transfer characteristic of the source picture"]
    pub transfer_characteristics: ::std::os::raw::c_uchar,
    #[doc = "< OUT: used in deriving luma and chroma signals from RGB primaries"]
    pub matrix_coefficients: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDEOFORMAT__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_4>(),
        1usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_4),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer_characteristics) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_4),
            "::",
            stringify!(transfer_characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix_coefficients) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_4),
            "::",
            stringify!(matrix_coefficients)
        )
    );
}
impl CUVIDEOFORMAT__bindgen_ty_4 {
    #[inline]
    pub fn video_format(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_video_format(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn video_full_range_flag(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_video_full_range_flag(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_zero_bits(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved_zero_bits(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        video_format: ::std::os::raw::c_uchar,
        video_full_range_flag: ::std::os::raw::c_uchar,
        reserved_zero_bits: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let video_format: u8 = unsafe { ::std::mem::transmute(video_format) };
            video_format as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let video_full_range_flag: u8 = unsafe { ::std::mem::transmute(video_full_range_flag) };
            video_full_range_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved_zero_bits: u8 = unsafe { ::std::mem::transmute(reserved_zero_bits) };
            reserved_zero_bits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDEOFORMAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDEOFORMAT>(),
        64usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDEOFORMAT>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progressive_sequence) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(progressive_sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_luma_minus8) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(bit_depth_luma_minus8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_chroma_minus8) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(bit_depth_chroma_minus8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_num_decode_surfaces) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(min_num_decode_surfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coded_height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_area) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(display_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_format) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(chroma_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_aspect_ratio) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(display_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video_signal_description) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(video_signal_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seqhdr_data_length) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(seqhdr_data_length)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDOPERATINGPOINTINFO\n//! Operating point information of scalable bitstream\n/"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUVIDOPERATINGPOINTINFO {
    pub codec: cudaVideoCodec,
    pub __bindgen_anon_1: CUVIDOPERATINGPOINTINFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUVIDOPERATINGPOINTINFO__bindgen_ty_1 {
    pub av1: CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1,
    pub CodecReserved: [::std::os::raw::c_uchar; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1 {
    pub operating_points_cnt: ::std::os::raw::c_uchar,
    pub reserved24_bits: [::std::os::raw::c_uchar; 3usize],
    pub operating_points_idc: [::std::os::raw::c_ushort; 32usize],
}
#[test]
fn bindgen_test_layout_CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1>(),
        68usize,
        concat!(
            "Size of: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operating_points_cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(operating_points_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved24_bits) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reserved24_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operating_points_idc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(operating_points_idc)
        )
    );
}
#[test]
fn bindgen_test_layout_CUVIDOPERATINGPOINTINFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDOPERATINGPOINTINFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1>(),
        1024usize,
        concat!(
            "Size of: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1),
            "::",
            stringify!(av1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodecReserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1),
            "::",
            stringify!(CodecReserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUVIDOPERATINGPOINTINFO() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDOPERATINGPOINTINFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDOPERATINGPOINTINFO>(),
        1028usize,
        concat!("Size of: ", stringify!(CUVIDOPERATINGPOINTINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDOPERATINGPOINTINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDOPERATINGPOINTINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO),
            "::",
            stringify!(codec)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDSEIMESSAGEINFO\n//! Used in cuvidParseVideoData API with PFNVIDSEIMSGCALLBACK pfnGetSEIMsg\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDSEIMESSAGEINFO {
    #[doc = "< OUT: SEI Message Data"]
    pub pSEIData: *mut ::std::os::raw::c_void,
    #[doc = "< OUT: SEI Message Info"]
    pub pSEIMessage: *mut CUSEIMESSAGE,
    #[doc = "< OUT: SEI Message Count"]
    pub sei_message_count: ::std::os::raw::c_uint,
    #[doc = "< OUT: SEI Message Pic Index"]
    pub picIdx: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__CUVIDSEIMESSAGEINFO() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDSEIMESSAGEINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDSEIMESSAGEINFO>(),
        24usize,
        concat!("Size of: ", stringify!(_CUVIDSEIMESSAGEINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDSEIMESSAGEINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDSEIMESSAGEINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSEIData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSEIMESSAGEINFO),
            "::",
            stringify!(pSEIData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSEIMessage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSEIMESSAGEINFO),
            "::",
            stringify!(pSEIMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sei_message_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSEIMESSAGEINFO),
            "::",
            stringify!(sei_message_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picIdx) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSEIMESSAGEINFO),
            "::",
            stringify!(picIdx)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDSEIMESSAGEINFO\n//! Used in cuvidParseVideoData API with PFNVIDSEIMSGCALLBACK pfnGetSEIMsg\n/"]
pub type CUVIDSEIMESSAGEINFO = _CUVIDSEIMESSAGEINFO;
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDAV1SEQHDR\n//! AV1 specific sequence header information\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUVIDAV1SEQHDR {
    pub max_width: ::std::os::raw::c_uint,
    pub max_height: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 1016usize],
}
#[test]
fn bindgen_test_layout_CUVIDAV1SEQHDR() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDAV1SEQHDR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDAV1SEQHDR>(),
        1024usize,
        concat!("Size of: ", stringify!(CUVIDAV1SEQHDR))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDAV1SEQHDR>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDAV1SEQHDR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDAV1SEQHDR),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDAV1SEQHDR),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDAV1SEQHDR),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDEOFORMATEX\n//! Video format including raw sequence header information\n//! Used in cuvidGetSourceVideoFormat API\n/"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUVIDEOFORMATEX {
    #[doc = "< OUT: CUVIDEOFORMAT structure"]
    pub format: CUVIDEOFORMAT,
    pub __bindgen_anon_1: CUVIDEOFORMATEX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUVIDEOFORMATEX__bindgen_ty_1 {
    pub av1: CUVIDAV1SEQHDR,
    #[doc = "< OUT: Sequence header data"]
    pub raw_seqhdr_data: [::std::os::raw::c_uchar; 1024usize],
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMATEX__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDEOFORMATEX__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDEOFORMATEX__bindgen_ty_1>(),
        1024usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMATEX__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDEOFORMATEX__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMATEX__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMATEX__bindgen_ty_1),
            "::",
            stringify!(av1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_seqhdr_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMATEX__bindgen_ty_1),
            "::",
            stringify!(raw_seqhdr_data)
        )
    );
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMATEX() {
    const UNINIT: ::std::mem::MaybeUninit<CUVIDEOFORMATEX> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUVIDEOFORMATEX>(),
        1088usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMATEX))
    );
    assert_eq!(
        ::std::mem::align_of::<CUVIDEOFORMATEX>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMATEX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMATEX),
            "::",
            stringify!(format)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUAUDIOFORMAT\n//! Audio formats\n//! Used in cuvidGetSourceAudioFormat API\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUAUDIOFORMAT {
    #[doc = "< OUT: Compression format"]
    pub codec: cudaAudioCodec,
    #[doc = "< OUT: number of audio channels"]
    pub channels: ::std::os::raw::c_uint,
    #[doc = "< OUT: sampling frequency"]
    pub samplespersec: ::std::os::raw::c_uint,
    #[doc = "< OUT: For uncompressed, can also be used to determine bits per sample"]
    pub bitrate: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use"]
    pub reserved1: ::std::os::raw::c_uint,
    #[doc = "< Reserved for future use"]
    pub reserved2: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CUAUDIOFORMAT() {
    const UNINIT: ::std::mem::MaybeUninit<CUAUDIOFORMAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CUAUDIOFORMAT>(),
        24usize,
        concat!("Size of: ", stringify!(CUAUDIOFORMAT))
    );
    assert_eq!(
        ::std::mem::align_of::<CUAUDIOFORMAT>(),
        4usize,
        concat!("Alignment of ", stringify!(CUAUDIOFORMAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplespersec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(samplespersec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = "< Set when this is the last packet for this stream"]
pub const CUvideopacketflags_CUVID_PKT_ENDOFSTREAM: CUvideopacketflags = 1;
#[doc = "< Timestamp is valid"]
pub const CUvideopacketflags_CUVID_PKT_TIMESTAMP: CUvideopacketflags = 2;
#[doc = "< Set when a discontinuity has to be signalled"]
pub const CUvideopacketflags_CUVID_PKT_DISCONTINUITY: CUvideopacketflags = 4;
#[doc = "< Set when the packet contains exactly one frame or one field"]
pub const CUvideopacketflags_CUVID_PKT_ENDOFPICTURE: CUvideopacketflags = 8;
#[doc = "< If this flag is set along with CUVID_PKT_ENDOFSTREAM, an additional (dummy)\ndisplay callback will be invoked with null value of CUVIDPARSERDISPINFO which\nshould be interpreted as end of the stream."]
pub const CUvideopacketflags_CUVID_PKT_NOTIFY_EOS: CUvideopacketflags = 16;
#[doc = "/\n//! \\enum CUvideopacketflags\n//! Data packet flags\n//! Used in CUVIDSOURCEDATAPACKET structure\n/"]
pub type CUvideopacketflags = ::std::os::raw::c_int;
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDSOURCEDATAPACKET\n//! Data Packet\n//! Used in cuvidParseVideoData API\n//! IN for cuvidParseVideoData\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDSOURCEDATAPACKET {
    #[doc = "< IN: Combination of CUVID_PKT_XXX flags"]
    pub flags: ::std::os::raw::c_ulong,
    #[doc = "< IN: number of bytes in the payload (may be zero if EOS flag is set)"]
    pub payload_size: ::std::os::raw::c_ulong,
    #[doc = "< IN: Pointer to packet payload data (may be NULL if EOS flag is set)"]
    pub payload: *const ::std::os::raw::c_uchar,
    #[doc = "< IN: Presentation time stamp (10MHz clock), only valid if\nCUVID_PKT_TIMESTAMP flag is set"]
    pub timestamp: CUvideotimestamp,
}
#[test]
fn bindgen_test_layout__CUVIDSOURCEDATAPACKET() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDSOURCEDATAPACKET> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDSOURCEDATAPACKET>(),
        24usize,
        concat!("Size of: ", stringify!(_CUVIDSOURCEDATAPACKET))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDSOURCEDATAPACKET>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDSOURCEDATAPACKET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEDATAPACKET),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEDATAPACKET),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEDATAPACKET),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEDATAPACKET),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDSOURCEDATAPACKET\n//! Data Packet\n//! Used in cuvidParseVideoData API\n//! IN for cuvidParseVideoData\n/"]
pub type CUVIDSOURCEDATAPACKET = _CUVIDSOURCEDATAPACKET;
pub type PFNVIDSOURCECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDSOURCEDATAPACKET,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDSOURCEPARAMS\n//! Describes parameters needed in cuvidCreateVideoSource API\n//! NVDECODE API is intended for HW accelerated video decoding so CUvideosource doesn't have audio demuxer for all supported\n//! containers. It's recommended to clients to use their own or third party demuxer if audio support is needed.\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDSOURCEPARAMS {
    #[doc = "< IN: Time stamp units in Hz (0=default=10000000Hz)"]
    pub ulClockRate: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Reserved for future use - set to zero"]
    pub uReserved1: [::std::os::raw::c_uint; 6usize],
    #[doc = "< IN: User private data passed in to the data handlers"]
    pub pUserData: *mut ::std::os::raw::c_void,
    #[doc = "< IN: Called to deliver video packets"]
    pub pfnVideoDataHandler: PFNVIDSOURCECALLBACK,
    #[doc = "< IN: Called to deliver audio packets."]
    pub pfnAudioDataHandler: PFNVIDSOURCECALLBACK,
    #[doc = "< Reserved for future use - set to NULL"]
    pub pvReserved2: [*mut ::std::os::raw::c_void; 8usize],
}
#[test]
fn bindgen_test_layout__CUVIDSOURCEPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDSOURCEPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDSOURCEPARAMS>(),
        120usize,
        concat!("Size of: ", stringify!(_CUVIDSOURCEPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDSOURCEPARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDSOURCEPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulClockRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(ulClockRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uReserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(uReserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnVideoDataHandler) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(pfnVideoDataHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnAudioDataHandler) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(pfnAudioDataHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pvReserved2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(pvReserved2)
        )
    );
}
impl _CUVIDSOURCEPARAMS {
    #[inline]
    pub fn bAnnexb(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bAnnexb(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uReserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_uReserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAnnexb: ::std::os::raw::c_uint,
        uReserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bAnnexb: u32 = unsafe { ::std::mem::transmute(bAnnexb) };
            bAnnexb as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let uReserved: u32 = unsafe { ::std::mem::transmute(uReserved) };
            uReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDSOURCEPARAMS\n//! Describes parameters needed in cuvidCreateVideoSource API\n//! NVDECODE API is intended for HW accelerated video decoding so CUvideosource doesn't have audio demuxer for all supported\n//! containers. It's recommended to clients to use their own or third party demuxer if audio support is needed.\n/"]
pub type CUVIDSOURCEPARAMS = _CUVIDSOURCEPARAMS;
#[doc = "< Return extended format structure (CUVIDEOFORMATEX)"]
pub const CUvideosourceformat_flags_CUVID_FMT_EXTFORMATINFO: CUvideosourceformat_flags = 256;
#[doc = "/\n//! \\ingroup ENUMS\n//! \\enum CUvideosourceformat_flags\n//! CUvideosourceformat_flags\n//! Used in cuvidGetSourceVideoFormat API\n/"]
pub type CUvideosourceformat_flags = ::std::os::raw::c_int;
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidCreateVideoSource(CUvideosource *pObj, const char *pszFileName, CUVIDSOURCEPARAMS *pParams)\n//! Create CUvideosource object. CUvideosource spawns demultiplexer thread that provides two callbacks:\n//! pfnVideoDataHandler() and pfnAudioDataHandler()\n//! NVDECODE API is intended for HW accelerated video decoding so CUvideosource doesn't have audio demuxer for all supported\n//! containers. It's recommended to clients to use their own or third party demuxer if audio support is needed.\n/"]
    pub fn cuvidCreateVideoSource(
        pObj: *mut CUvideosource,
        pszFileName: *const ::std::os::raw::c_char,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidCreateVideoSourceW(CUvideosource *pObj, const wchar_t *pwszFileName, CUVIDSOURCEPARAMS *pParams)\n//! Create video source\n/"]
    pub fn cuvidCreateVideoSourceW(
        pObj: *mut CUvideosource,
        pwszFileName: *const wchar_t,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidDestroyVideoSource(CUvideosource obj)\n//! Destroy video source\n/"]
    pub fn cuvidDestroyVideoSource(obj: CUvideosource) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidSetVideoSourceState(CUvideosource obj, cudaVideoState state)\n//! Set video source state to:\n//! cudaVideoState_Started - to signal the source to run and deliver data\n//! cudaVideoState_Stopped - to stop the source from delivering the data\n//! cudaVideoState_Error   - invalid source\n/"]
    pub fn cuvidSetVideoSourceState(obj: CUvideosource, state: cudaVideoState) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn cudaVideoState CUDAAPI cuvidGetVideoSourceState(CUvideosource obj)\n//! Get video source state\n//! Returns:\n//! cudaVideoState_Started - if Source is running and delivering data\n//! cudaVideoState_Stopped - if Source is stopped or reached end-of-stream\n//! cudaVideoState_Error   - if Source is in error state\n/"]
    pub fn cuvidGetVideoSourceState(obj: CUvideosource) -> cudaVideoState;
}
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidGetSourceVideoFormat(CUvideosource obj, CUVIDEOFORMAT *pvidfmt, unsigned int flags)\n//! Gets video source format in pvidfmt, flags is set to combination of CUvideosourceformat_flags as per requirement\n/"]
    pub fn cuvidGetSourceVideoFormat(
        obj: CUvideosource,
        pvidfmt: *mut CUVIDEOFORMAT,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidGetSourceAudioFormat(CUvideosource obj, CUAUDIOFORMAT *paudfmt, unsigned int flags)\n//! Get audio source format\n//! NVDECODE API is intended for HW accelerated video decoding so CUvideosource doesn't have audio demuxer for all supported\n//! containers. It's recommended to clients to use their own or third party demuxer if audio support is needed.\n/"]
    pub fn cuvidGetSourceAudioFormat(
        obj: CUvideosource,
        paudfmt: *mut CUAUDIOFORMAT,
        flags: ::std::os::raw::c_uint,
    ) -> CUresult;
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDPARSERDISPINFO\n//! Used in cuvidParseVideoData API with PFNVIDDISPLAYCALLBACK pfnDisplayPicture\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDPARSERDISPINFO {
    #[doc = "< OUT: Index of the current picture"]
    pub picture_index: ::std::os::raw::c_int,
    #[doc = "< OUT: 1 if progressive frame; 0 otherwise"]
    pub progressive_frame: ::std::os::raw::c_int,
    #[doc = "< OUT: 1 if top field is displayed first; 0 otherwise"]
    pub top_field_first: ::std::os::raw::c_int,
    #[doc = "< OUT: Number of additional fields (1=ivtc, 2=frame doubling, 4=frame tripling,\n-1=unpaired field)"]
    pub repeat_first_field: ::std::os::raw::c_int,
    #[doc = "< OUT: Presentation time stamp"]
    pub timestamp: CUvideotimestamp,
}
#[test]
fn bindgen_test_layout__CUVIDPARSERDISPINFO() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDPARSERDISPINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDPARSERDISPINFO>(),
        24usize,
        concat!("Size of: ", stringify!(_CUVIDPARSERDISPINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDPARSERDISPINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDPARSERDISPINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picture_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(picture_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progressive_frame) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(progressive_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_field_first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).repeat_first_field) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(repeat_first_field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDPARSERDISPINFO\n//! Used in cuvidParseVideoData API with PFNVIDDISPLAYCALLBACK pfnDisplayPicture\n/"]
pub type CUVIDPARSERDISPINFO = _CUVIDPARSERDISPINFO;
#[doc = "/\n//! Parser callbacks\n//! The parser will call these synchronously from within cuvidParseVideoData(), whenever there is sequence change or a picture\n//! is ready to be decoded and/or displayed. First argument in functions is \"void *pUserData\" member of structure CUVIDSOURCEPARAMS\n//! Return values from these callbacks are interpreted as below. If the callbacks return failure, it will be propagated by\n//! cuvidParseVideoData() to the application.\n//! Parser picks default operating point as 0 and outputAllLayers flag as 0 if PFNVIDOPPOINTCALLBACK is not set or return value is\n//! -1 or invalid operating point.\n//! PFNVIDSEQUENCECALLBACK : 0: fail, 1: succeeded, > 1: override dpb size of parser (set by CUVIDPARSERPARAMS::ulMaxNumDecodeSurfaces\n//! while creating parser)\n//! PFNVIDDECODECALLBACK   : 0: fail, >=1: succeeded\n//! PFNVIDDISPLAYCALLBACK  : 0: fail, >=1: succeeded\n//! PFNVIDOPPOINTCALLBACK  : <0: fail, >=0: succeeded (bit 0-9: OperatingPoint, bit 10-10: outputAllLayers, bit 11-30: reserved)\n//! PFNVIDSEIMSGCALLBACK   : 0: fail, >=1: succeeded\n/"]
pub type PFNVIDSEQUENCECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDEOFORMAT,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDDECODECALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDPICPARAMS,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDDISPLAYCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDPARSERDISPINFO,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDOPPOINTCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDOPERATINGPOINTINFO,
    ) -> ::std::os::raw::c_int,
>;
pub type PFNVIDSEIMSGCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut CUVIDSEIMESSAGEINFO,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDPARSERPARAMS\n//! Used in cuvidCreateVideoParser API\n/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUVIDPARSERPARAMS {
    #[doc = "< IN: cudaVideoCodec_XXX"]
    pub CodecType: cudaVideoCodec,
    #[doc = "< IN: Max # of decode surfaces (parser will cycle through these)"]
    pub ulMaxNumDecodeSurfaces: ::std::os::raw::c_uint,
    #[doc = "< IN: Timestamp units in Hz (0=default=10000000Hz)"]
    pub ulClockRate: ::std::os::raw::c_uint,
    #[doc = "< IN: % Error threshold (0-100) for calling pfnDecodePicture (100=always\nIN: call pfnDecodePicture even if picture bitstream is fully corrupted)"]
    pub ulErrorThreshold: ::std::os::raw::c_uint,
    #[doc = "< IN: Max display queue delay (improves pipelining of decode with display)\n0=no delay (recommended values: 2..4)"]
    pub ulMaxDisplayDelay: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< IN: Reserved for future use - set to 0"]
    pub uReserved1: [::std::os::raw::c_uint; 4usize],
    #[doc = "< IN: User data for callbacks"]
    pub pUserData: *mut ::std::os::raw::c_void,
    #[doc = "< IN: Called before decoding frames and/or whenever there is a fmt change"]
    pub pfnSequenceCallback: PFNVIDSEQUENCECALLBACK,
    #[doc = "< IN: Called when a picture is ready to be decoded (decode order)"]
    pub pfnDecodePicture: PFNVIDDECODECALLBACK,
    #[doc = "< IN: Called whenever a picture is ready to be displayed (display order)"]
    pub pfnDisplayPicture: PFNVIDDISPLAYCALLBACK,
    #[doc = "< IN: Called from AV1 sequence header to get operating point of a AV1\nscalable bitstream"]
    pub pfnGetOperatingPoint: PFNVIDOPPOINTCALLBACK,
    #[doc = "< IN: Called when all SEI messages are parsed for particular frame"]
    pub pfnGetSEIMsg: PFNVIDSEIMSGCALLBACK,
    #[doc = "< Reserved for future use - set to NULL"]
    pub pvReserved2: [*mut ::std::os::raw::c_void; 5usize],
    #[doc = "< IN: [Optional] sequence header data from system layer"]
    pub pExtVideoInfo: *mut CUVIDEOFORMATEX,
}
#[test]
fn bindgen_test_layout__CUVIDPARSERPARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_CUVIDPARSERPARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CUVIDPARSERPARAMS>(),
        136usize,
        concat!("Size of: ", stringify!(_CUVIDPARSERPARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUVIDPARSERPARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDPARSERPARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodecType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(CodecType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulMaxNumDecodeSurfaces) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(ulMaxNumDecodeSurfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulClockRate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(ulClockRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulErrorThreshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(ulErrorThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulMaxDisplayDelay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(ulMaxDisplayDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uReserved1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(uReserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnSequenceCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnSequenceCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDecodePicture) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnDecodePicture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnDisplayPicture) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnDisplayPicture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnGetOperatingPoint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnGetOperatingPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfnGetSEIMsg) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnGetSEIMsg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pvReserved2) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pvReserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pExtVideoInfo) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pExtVideoInfo)
        )
    );
}
impl _CUVIDPARSERPARAMS {
    #[inline]
    pub fn bAnnexb(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bAnnexb(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uReserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_uReserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAnnexb: ::std::os::raw::c_uint,
        uReserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bAnnexb: u32 = unsafe { ::std::mem::transmute(bAnnexb) };
            bAnnexb as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let uReserved: u32 = unsafe { ::std::mem::transmute(uReserved) };
            uReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "/\n//! \\ingroup STRUCTS\n//! \\struct CUVIDPARSERPARAMS\n//! Used in cuvidCreateVideoParser API\n/"]
pub type CUVIDPARSERPARAMS = _CUVIDPARSERPARAMS;
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidCreateVideoParser(CUvideoparser *pObj, CUVIDPARSERPARAMS *pParams)\n//! Create video parser object and initialize\n/"]
    pub fn cuvidCreateVideoParser(
        pObj: *mut CUvideoparser,
        pParams: *mut CUVIDPARSERPARAMS,
    ) -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidParseVideoData(CUvideoparser obj, CUVIDSOURCEDATAPACKET *pPacket)\n//! Parse the video data from source data packet in pPacket\n//! Extracts parameter sets like SPS, PPS, bitstream etc. from pPacket and\n//! calls back pfnDecodePicture with CUVIDPICPARAMS data for kicking of HW decoding\n//! calls back pfnSequenceCallback with CUVIDEOFORMAT data for initial sequence header or when\n//! the decoder encounters a video format change\n//! calls back pfnDisplayPicture with CUVIDPARSERDISPINFO data to display a video frame\n/"]
    pub fn cuvidParseVideoData(obj: CUvideoparser, pPacket: *mut CUVIDSOURCEDATAPACKET)
        -> CUresult;
}
extern "C" {
    #[doc = "/\n//! \\ingroup FUNCTS\n//! \\fn CUresult CUDAAPI cuvidDestroyVideoParser(CUvideoparser obj)\n//! Destroy the video parser\n/"]
    pub fn cuvidDestroyVideoParser(obj: CUvideoparser) -> CUresult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
