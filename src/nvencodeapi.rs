/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const NVENCAPI_MAJOR_VERSION: u32 = 12;
pub const NVENCAPI_MINOR_VERSION: u32 = 0;
pub const NVENCAPI_VERSION: u32 = 12;
pub const NVENC_INFINITE_GOPLENGTH: u32 = 4294967295;
pub const NV_MAX_SEQ_HDR_LEN: u32 = 512;
pub const MAX_NUM_CLOCK_TS: u32 = 3;
pub const NV_MAX_TILE_COLS_AV1: u32 = 64;
pub const NV_MAX_TILE_ROWS_AV1: u32 = 64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type max_align_t = f64;
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[doc = " \\struct GUID\n Abstracts the GUID structure for non-windows platforms."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    #[doc = "< [in]: Specifies the first 8 hexadecimal digits of the GUID."]
    pub Data1: u32,
    #[doc = "< [in]: Specifies the first group of 4 hexadecimal digits."]
    pub Data2: u16,
    #[doc = "< [in]: Specifies the second group of 4 hexadecimal digits."]
    pub Data3: u16,
    #[doc = "< [in]: Array of 8 bytes. The first 2 bytes contain the third group of 4 hexadecimal digits.\nThe remaining 6 bytes contain the final 12 hexadecimal digits."]
    pub Data4: [u8; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    const UNINIT: ::std::mem::MaybeUninit<_GUID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data4)
        )
    );
}
#[doc = " \\struct GUID\n Abstracts the GUID structure for non-windows platforms."]
pub type GUID = _GUID;
#[doc = " \\struct GUID\n Abstracts the GUID structure for non-windows platforms."]
pub type LPGUID = *mut _GUID;
#[doc = " \\struct _NVENC_RECT\n Defines a Rectangle. Used in ::NV_ENC_PREPROCESS_FRAME."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVENC_RECT {
    #[doc = "< [in]: X coordinate of the upper left corner of rectangular area to be specified."]
    pub left: u32,
    #[doc = "< [in]: Y coordinate of the upper left corner of the rectangular area to be specified."]
    pub top: u32,
    #[doc = "< [in]: X coordinate of the bottom right corner of the rectangular area to be specified."]
    pub right: u32,
    #[doc = "< [in]: Y coordinate of the bottom right corner of the rectangular area to be specified."]
    pub bottom: u32,
}
#[test]
fn bindgen_test_layout__NVENC_RECT() {
    const UNINIT: ::std::mem::MaybeUninit<_NVENC_RECT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVENC_RECT>(),
        16usize,
        concat!("Size of: ", stringify!(_NVENC_RECT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_RECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVENC_RECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " \\struct _NVENC_RECT\n Defines a Rectangle. Used in ::NV_ENC_PREPROCESS_FRAME."]
pub type NVENC_RECT = _NVENC_RECT;
#[doc = " @}"]
pub type NV_ENC_INPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_OUTPUT_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_REGISTERED_PTR = *mut ::std::os::raw::c_void;
pub type NV_ENC_CUSTREAM_PTR = *mut ::std::os::raw::c_void;
extern "C" {
    pub static NV_ENC_CODEC_H264_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_CODEC_HEVC_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_CODEC_AV1_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_H264_PROFILE_BASELINE_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_H264_PROFILE_MAIN_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_H264_PROFILE_HIGH_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_H264_PROFILE_HIGH_444_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_H264_PROFILE_STEREO_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_HEVC_PROFILE_MAIN_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_HEVC_PROFILE_MAIN10_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_HEVC_PROFILE_FREXT_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_AV1_PROFILE_MAIN_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_DEFAULT_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_HP_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_HQ_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_BD_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_LOW_LATENCY_HQ_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_LOW_LATENCY_HP_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_LOSSLESS_HP_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_P1_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_P2_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_P3_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_P4_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_P5_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_P6_GUID: GUID;
}
extern "C" {
    pub static NV_ENC_PRESET_P7_GUID: GUID;
}
#[doc = "< Frame mode"]
pub const _NV_ENC_PARAMS_FRAME_FIELD_MODE_NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME:
    _NV_ENC_PARAMS_FRAME_FIELD_MODE = 1;
#[doc = "< Field mode"]
pub const _NV_ENC_PARAMS_FRAME_FIELD_MODE_NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD:
    _NV_ENC_PARAMS_FRAME_FIELD_MODE = 2;
#[doc = "< MB adaptive frame/field"]
pub const _NV_ENC_PARAMS_FRAME_FIELD_MODE_NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF:
    _NV_ENC_PARAMS_FRAME_FIELD_MODE = 3;
#[doc = " Input frame encode modes"]
pub type _NV_ENC_PARAMS_FRAME_FIELD_MODE = ::std::os::raw::c_int;
#[doc = " Input frame encode modes"]
pub use self::_NV_ENC_PARAMS_FRAME_FIELD_MODE as NV_ENC_PARAMS_FRAME_FIELD_MODE;
#[doc = "< Constant QP mode"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_CONSTQP: _NV_ENC_PARAMS_RC_MODE = 0;
#[doc = "< Variable bitrate mode"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_VBR: _NV_ENC_PARAMS_RC_MODE = 1;
#[doc = "< Constant bitrate mode"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_CBR: _NV_ENC_PARAMS_RC_MODE = 2;
#[doc = "< Deprecated, use NV_ENC_PARAMS_RC_CBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION +\nlowDelayKeyFrameScale=1"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ: _NV_ENC_PARAMS_RC_MODE = 8;
#[doc = "< Deprecated, use NV_ENC_PARAMS_RC_CBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_CBR_HQ: _NV_ENC_PARAMS_RC_MODE = 16;
#[doc = "< Deprecated, use NV_ENC_PARAMS_RC_VBR + NV_ENC_TWO_PASS_QUARTER_RESOLUTION / NV_ENC_TWO_PASS_FULL_RESOLUTION"]
pub const _NV_ENC_PARAMS_RC_MODE_NV_ENC_PARAMS_RC_VBR_HQ: _NV_ENC_PARAMS_RC_MODE = 32;
#[doc = " Rate Control Modes"]
pub type _NV_ENC_PARAMS_RC_MODE = ::std::os::raw::c_int;
#[doc = " Rate Control Modes"]
pub use self::_NV_ENC_PARAMS_RC_MODE as NV_ENC_PARAMS_RC_MODE;
#[doc = "< Single Pass"]
pub const _NV_ENC_MULTI_PASS_NV_ENC_MULTI_PASS_DISABLED: _NV_ENC_MULTI_PASS = 0;
#[doc = "< Two Pass encoding is enabled where first Pass is quarter resolution"]
pub const _NV_ENC_MULTI_PASS_NV_ENC_TWO_PASS_QUARTER_RESOLUTION: _NV_ENC_MULTI_PASS = 1;
#[doc = "< Two Pass encoding is enabled where first Pass is full resolution"]
pub const _NV_ENC_MULTI_PASS_NV_ENC_TWO_PASS_FULL_RESOLUTION: _NV_ENC_MULTI_PASS = 2;
#[doc = " Multi Pass encoding"]
pub type _NV_ENC_MULTI_PASS = ::std::os::raw::c_int;
#[doc = " Multi Pass encoding"]
pub use self::_NV_ENC_MULTI_PASS as NV_ENC_MULTI_PASS;
#[doc = "< Emphasis Map Level 0, for zero Delta QP value"]
pub const _NV_ENC_EMPHASIS_MAP_LEVEL_NV_ENC_EMPHASIS_MAP_LEVEL_0: _NV_ENC_EMPHASIS_MAP_LEVEL = 0;
#[doc = "< Emphasis Map Level 1, for very low Delta QP value"]
pub const _NV_ENC_EMPHASIS_MAP_LEVEL_NV_ENC_EMPHASIS_MAP_LEVEL_1: _NV_ENC_EMPHASIS_MAP_LEVEL = 1;
#[doc = "< Emphasis Map Level 2, for low Delta QP value"]
pub const _NV_ENC_EMPHASIS_MAP_LEVEL_NV_ENC_EMPHASIS_MAP_LEVEL_2: _NV_ENC_EMPHASIS_MAP_LEVEL = 2;
#[doc = "< Emphasis Map Level 3, for medium Delta QP value"]
pub const _NV_ENC_EMPHASIS_MAP_LEVEL_NV_ENC_EMPHASIS_MAP_LEVEL_3: _NV_ENC_EMPHASIS_MAP_LEVEL = 3;
#[doc = "< Emphasis Map Level 4, for high Delta QP value"]
pub const _NV_ENC_EMPHASIS_MAP_LEVEL_NV_ENC_EMPHASIS_MAP_LEVEL_4: _NV_ENC_EMPHASIS_MAP_LEVEL = 4;
#[doc = "< Emphasis Map Level 5, for very high Delta QP value"]
pub const _NV_ENC_EMPHASIS_MAP_LEVEL_NV_ENC_EMPHASIS_MAP_LEVEL_5: _NV_ENC_EMPHASIS_MAP_LEVEL = 5;
#[doc = " Emphasis Levels"]
pub type _NV_ENC_EMPHASIS_MAP_LEVEL = ::std::os::raw::c_int;
#[doc = " Emphasis Levels"]
pub use self::_NV_ENC_EMPHASIS_MAP_LEVEL as NV_ENC_EMPHASIS_MAP_LEVEL;
#[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap have no effect."]
pub const _NV_ENC_QP_MAP_MODE_NV_ENC_QP_MAP_DISABLED: _NV_ENC_QP_MAP_MODE = 0;
#[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as Emphasis level. Currently this is only supported for H264"]
pub const _NV_ENC_QP_MAP_MODE_NV_ENC_QP_MAP_EMPHASIS: _NV_ENC_QP_MAP_MODE = 1;
#[doc = "< Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as QP delta map."]
pub const _NV_ENC_QP_MAP_MODE_NV_ENC_QP_MAP_DELTA: _NV_ENC_QP_MAP_MODE = 2;
#[doc = "< Currently This is not supported. Value in NV_ENC_PIC_PARAMS::qpDeltaMap will be treated as QP value."]
pub const _NV_ENC_QP_MAP_MODE_NV_ENC_QP_MAP: _NV_ENC_QP_MAP_MODE = 3;
#[doc = " QP MAP MODE"]
pub type _NV_ENC_QP_MAP_MODE = ::std::os::raw::c_int;
#[doc = " QP MAP MODE"]
pub use self::_NV_ENC_QP_MAP_MODE as NV_ENC_QP_MAP_MODE;
#[doc = "< Progressive frame"]
pub const _NV_ENC_PIC_STRUCT_NV_ENC_PIC_STRUCT_FRAME: _NV_ENC_PIC_STRUCT = 1;
#[doc = "< Field encoding top field first"]
pub const _NV_ENC_PIC_STRUCT_NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM: _NV_ENC_PIC_STRUCT = 2;
#[doc = "< Field encoding bottom field first"]
pub const _NV_ENC_PIC_STRUCT_NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP: _NV_ENC_PIC_STRUCT = 3;
#[doc = " Input picture structure"]
pub type _NV_ENC_PIC_STRUCT = ::std::os::raw::c_int;
#[doc = " Input picture structure"]
pub use self::_NV_ENC_PIC_STRUCT as NV_ENC_PIC_STRUCT;
#[doc = "< Field encoding top field first"]
pub const _NV_ENC_DISPLAY_PIC_STRUCT_NV_ENC_PIC_STRUCT_DISPLAY_FRAME: _NV_ENC_DISPLAY_PIC_STRUCT =
    0;
#[doc = "< Field encoding top field first"]
pub const _NV_ENC_DISPLAY_PIC_STRUCT_NV_ENC_PIC_STRUCT_DISPLAY_FIELD_TOP_BOTTOM:
    _NV_ENC_DISPLAY_PIC_STRUCT = 1;
#[doc = "< Field encoding bottom field first"]
pub const _NV_ENC_DISPLAY_PIC_STRUCT_NV_ENC_PIC_STRUCT_DISPLAY_FIELD_BOTTOM_TOP:
    _NV_ENC_DISPLAY_PIC_STRUCT = 2;
#[doc = "< Frame doubling"]
pub const _NV_ENC_DISPLAY_PIC_STRUCT_NV_ENC_PIC_STRUCT_DISPLAY_FRAME_DOUBLING:
    _NV_ENC_DISPLAY_PIC_STRUCT = 3;
#[doc = "< Field tripling"]
pub const _NV_ENC_DISPLAY_PIC_STRUCT_NV_ENC_PIC_STRUCT_DISPLAY_FRAME_TRIPLING:
    _NV_ENC_DISPLAY_PIC_STRUCT = 4;
#[doc = " Display picture structure\n Currently, this enum is only used for deciding the number of clock timestamp sets in Picture Timing SEI / Time Code SEI\n Otherwise, this has no impact on encoder behavior"]
pub type _NV_ENC_DISPLAY_PIC_STRUCT = ::std::os::raw::c_int;
#[doc = " Display picture structure\n Currently, this enum is only used for deciding the number of clock timestamp sets in Picture Timing SEI / Time Code SEI\n Otherwise, this has no impact on encoder behavior"]
pub use self::_NV_ENC_DISPLAY_PIC_STRUCT as NV_ENC_DISPLAY_PIC_STRUCT;
#[doc = "< Forward predicted"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_P: _NV_ENC_PIC_TYPE = 0;
#[doc = "< Bi-directionally predicted picture"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_B: _NV_ENC_PIC_TYPE = 1;
#[doc = "< Intra predicted picture"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_I: _NV_ENC_PIC_TYPE = 2;
#[doc = "< IDR picture"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_IDR: _NV_ENC_PIC_TYPE = 3;
#[doc = "< Bi-directionally predicted with only Intra MBs"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_BI: _NV_ENC_PIC_TYPE = 4;
#[doc = "< Picture is skipped"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_SKIPPED: _NV_ENC_PIC_TYPE = 5;
#[doc = "< First picture in intra refresh cycle"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_INTRA_REFRESH: _NV_ENC_PIC_TYPE = 6;
#[doc = "< Non reference P picture"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_NONREF_P: _NV_ENC_PIC_TYPE = 7;
#[doc = "< Picture type unknown"]
pub const _NV_ENC_PIC_TYPE_NV_ENC_PIC_TYPE_UNKNOWN: _NV_ENC_PIC_TYPE = 255;
#[doc = " Input picture type"]
pub type _NV_ENC_PIC_TYPE = ::std::os::raw::c_int;
#[doc = " Input picture type"]
pub use self::_NV_ENC_PIC_TYPE as NV_ENC_PIC_TYPE;
#[doc = "< Driver selects Quarter-Pel motion vector precision by default"]
pub const _NV_ENC_MV_PRECISION_NV_ENC_MV_PRECISION_DEFAULT: _NV_ENC_MV_PRECISION = 0;
#[doc = "< Full-Pel motion vector precision"]
pub const _NV_ENC_MV_PRECISION_NV_ENC_MV_PRECISION_FULL_PEL: _NV_ENC_MV_PRECISION = 1;
#[doc = "< Half-Pel motion vector precision"]
pub const _NV_ENC_MV_PRECISION_NV_ENC_MV_PRECISION_HALF_PEL: _NV_ENC_MV_PRECISION = 2;
#[doc = "< Quarter-Pel motion vector precision"]
pub const _NV_ENC_MV_PRECISION_NV_ENC_MV_PRECISION_QUARTER_PEL: _NV_ENC_MV_PRECISION = 3;
#[doc = " Motion vector precisions"]
pub type _NV_ENC_MV_PRECISION = ::std::os::raw::c_int;
#[doc = " Motion vector precisions"]
pub use self::_NV_ENC_MV_PRECISION as NV_ENC_MV_PRECISION;
#[doc = "< Undefined buffer format"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_UNDEFINED: _NV_ENC_BUFFER_FORMAT = 0;
#[doc = "< Semi-Planar YUV [Y plane followed by interleaved UV plane]"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_NV12: _NV_ENC_BUFFER_FORMAT = 1;
#[doc = "< Planar YUV [Y plane followed by V and U planes]"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_YV12: _NV_ENC_BUFFER_FORMAT = 16;
#[doc = "< Planar YUV [Y plane followed by U and V planes]"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_IYUV: _NV_ENC_BUFFER_FORMAT = 256;
#[doc = "< Planar YUV [Y plane followed by U and V planes]"]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_YUV444: _NV_ENC_BUFFER_FORMAT = 4096;
#[doc = "< 10 bit Semi-Planar YUV [Y plane followed by interleaved UV plane]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_YUV420_10BIT: _NV_ENC_BUFFER_FORMAT = 65536;
#[doc = "< 10 bit Planar YUV444 [Y plane followed by U and V planes]. Each pixel of size 2 bytes. Most Significant 10 bits contain pixel data."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_YUV444_10BIT: _NV_ENC_BUFFER_FORMAT = 1048576;
#[doc = "< 8 bit Packed A8R8G8B8. This is a word-ordered format\nwhere a pixel is represented by a 32-bit word with B\nin the lowest 8 bits, G in the next 8 bits, R in the\n8 bits after that and A in the highest 8 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_ARGB: _NV_ENC_BUFFER_FORMAT = 16777216;
#[doc = "< 10 bit Packed A2R10G10B10. This is a word-ordered format\nwhere a pixel is represented by a 32-bit word with B\nin the lowest 10 bits, G in the next 10 bits, R in the\n10 bits after that and A in the highest 2 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_ARGB10: _NV_ENC_BUFFER_FORMAT = 33554432;
#[doc = "< 8 bit Packed A8Y8U8V8. This is a word-ordered format\nwhere a pixel is represented by a 32-bit word with V\nin the lowest 8 bits, U in the next 8 bits, Y in the\n8 bits after that and A in the highest 8 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_AYUV: _NV_ENC_BUFFER_FORMAT = 67108864;
#[doc = "< 8 bit Packed A8B8G8R8. This is a word-ordered format\nwhere a pixel is represented by a 32-bit word with R\nin the lowest 8 bits, G in the next 8 bits, B in the\n8 bits after that and A in the highest 8 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_ABGR: _NV_ENC_BUFFER_FORMAT = 268435456;
#[doc = "< 10 bit Packed A2B10G10R10. This is a word-ordered format\nwhere a pixel is represented by a 32-bit word with R\nin the lowest 10 bits, G in the next 10 bits, B in the\n10 bits after that and A in the highest 2 bits."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_ABGR10: _NV_ENC_BUFFER_FORMAT = 536870912;
#[doc = "< Buffer format representing one-dimensional buffer.\nThis format should be used only when registering the\nresource as output buffer, which will be used to write\nthe encoded bit stream or H.264 ME only mode output."]
pub const _NV_ENC_BUFFER_FORMAT_NV_ENC_BUFFER_FORMAT_U8: _NV_ENC_BUFFER_FORMAT = 1073741824;
#[doc = " Input buffer formats"]
pub type _NV_ENC_BUFFER_FORMAT = ::std::os::raw::c_int;
#[doc = " Input buffer formats"]
pub use self::_NV_ENC_BUFFER_FORMAT as NV_ENC_BUFFER_FORMAT;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AUTOSELECT: _NV_ENC_LEVEL = 0;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_1: _NV_ENC_LEVEL = 10;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_1b: _NV_ENC_LEVEL = 9;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_11: _NV_ENC_LEVEL = 11;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_12: _NV_ENC_LEVEL = 12;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_13: _NV_ENC_LEVEL = 13;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_2: _NV_ENC_LEVEL = 20;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_21: _NV_ENC_LEVEL = 21;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_22: _NV_ENC_LEVEL = 22;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_3: _NV_ENC_LEVEL = 30;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_31: _NV_ENC_LEVEL = 31;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_32: _NV_ENC_LEVEL = 32;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_4: _NV_ENC_LEVEL = 40;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_41: _NV_ENC_LEVEL = 41;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_42: _NV_ENC_LEVEL = 42;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_5: _NV_ENC_LEVEL = 50;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_51: _NV_ENC_LEVEL = 51;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_52: _NV_ENC_LEVEL = 52;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_60: _NV_ENC_LEVEL = 60;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_61: _NV_ENC_LEVEL = 61;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_H264_62: _NV_ENC_LEVEL = 62;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_1: _NV_ENC_LEVEL = 30;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_2: _NV_ENC_LEVEL = 60;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_21: _NV_ENC_LEVEL = 63;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_3: _NV_ENC_LEVEL = 90;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_31: _NV_ENC_LEVEL = 93;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_4: _NV_ENC_LEVEL = 120;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_41: _NV_ENC_LEVEL = 123;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_5: _NV_ENC_LEVEL = 150;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_51: _NV_ENC_LEVEL = 153;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_52: _NV_ENC_LEVEL = 156;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_6: _NV_ENC_LEVEL = 180;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_61: _NV_ENC_LEVEL = 183;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_HEVC_62: _NV_ENC_LEVEL = 186;
pub const _NV_ENC_LEVEL_NV_ENC_TIER_HEVC_MAIN: _NV_ENC_LEVEL = 0;
pub const _NV_ENC_LEVEL_NV_ENC_TIER_HEVC_HIGH: _NV_ENC_LEVEL = 1;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_2: _NV_ENC_LEVEL = 0;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_21: _NV_ENC_LEVEL = 1;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_22: _NV_ENC_LEVEL = 2;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_23: _NV_ENC_LEVEL = 3;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_3: _NV_ENC_LEVEL = 4;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_31: _NV_ENC_LEVEL = 5;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_32: _NV_ENC_LEVEL = 6;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_33: _NV_ENC_LEVEL = 7;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_4: _NV_ENC_LEVEL = 8;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_41: _NV_ENC_LEVEL = 9;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_42: _NV_ENC_LEVEL = 10;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_43: _NV_ENC_LEVEL = 11;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_5: _NV_ENC_LEVEL = 12;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_51: _NV_ENC_LEVEL = 13;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_52: _NV_ENC_LEVEL = 14;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_53: _NV_ENC_LEVEL = 15;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_6: _NV_ENC_LEVEL = 16;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_61: _NV_ENC_LEVEL = 17;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_62: _NV_ENC_LEVEL = 18;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_63: _NV_ENC_LEVEL = 19;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_7: _NV_ENC_LEVEL = 20;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_71: _NV_ENC_LEVEL = 21;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_72: _NV_ENC_LEVEL = 22;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_73: _NV_ENC_LEVEL = 23;
pub const _NV_ENC_LEVEL_NV_ENC_LEVEL_AV1_AUTOSELECT: _NV_ENC_LEVEL = 24;
pub const _NV_ENC_LEVEL_NV_ENC_TIER_AV1_0: _NV_ENC_LEVEL = 0;
pub const _NV_ENC_LEVEL_NV_ENC_TIER_AV1_1: _NV_ENC_LEVEL = 1;
#[doc = " Encoding levels"]
pub type _NV_ENC_LEVEL = ::std::os::raw::c_int;
#[doc = " Encoding levels"]
pub use self::_NV_ENC_LEVEL as NV_ENC_LEVEL;
#[doc = " This indicates that API call returned with no errors."]
pub const _NVENCSTATUS_NV_ENC_SUCCESS: _NVENCSTATUS = 0;
#[doc = " This indicates that no encode capable devices were detected."]
pub const _NVENCSTATUS_NV_ENC_ERR_NO_ENCODE_DEVICE: _NVENCSTATUS = 1;
#[doc = " This indicates that devices pass by the client is not supported."]
pub const _NVENCSTATUS_NV_ENC_ERR_UNSUPPORTED_DEVICE: _NVENCSTATUS = 2;
#[doc = " This indicates that the encoder device supplied by the client is not\n valid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_ENCODERDEVICE: _NVENCSTATUS = 3;
#[doc = " This indicates that device passed to the API call is invalid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_DEVICE: _NVENCSTATUS = 4;
#[doc = " This indicates that device passed to the API call is no longer available and\n needs to be reinitialized. The clients need to destroy the current encoder\n session by freeing the allocated input output buffers and destroying the device\n and create a new encoding session."]
pub const _NVENCSTATUS_NV_ENC_ERR_DEVICE_NOT_EXIST: _NVENCSTATUS = 5;
#[doc = " This indicates that one or more of the pointers passed to the API call\n is invalid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_PTR: _NVENCSTATUS = 6;
#[doc = " This indicates that completion event passed in ::NvEncEncodePicture() call\n is invalid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_EVENT: _NVENCSTATUS = 7;
#[doc = " This indicates that one or more of the parameter passed to the API call\n is invalid."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_PARAM: _NVENCSTATUS = 8;
#[doc = " This indicates that an API call was made in wrong sequence/order."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_CALL: _NVENCSTATUS = 9;
#[doc = " This indicates that the API call failed because it was unable to allocate\n enough memory to perform the requested operation."]
pub const _NVENCSTATUS_NV_ENC_ERR_OUT_OF_MEMORY: _NVENCSTATUS = 10;
#[doc = " This indicates that the encoder has not been initialized with\n ::NvEncInitializeEncoder() or that initialization has failed.\n The client cannot allocate input or output buffers or do any encoding\n related operation before successfully initializing the encoder."]
pub const _NVENCSTATUS_NV_ENC_ERR_ENCODER_NOT_INITIALIZED: _NVENCSTATUS = 11;
#[doc = " This indicates that an unsupported parameter was passed by the client."]
pub const _NVENCSTATUS_NV_ENC_ERR_UNSUPPORTED_PARAM: _NVENCSTATUS = 12;
#[doc = " This indicates that the ::NvEncLockBitstream() failed to lock the output\n buffer. This happens when the client makes a non blocking lock call to\n access the output bitstream by passing NV_ENC_LOCK_BITSTREAM::doNotWait flag.\n This is not a fatal error and client should retry the same operation after\n few milliseconds."]
pub const _NVENCSTATUS_NV_ENC_ERR_LOCK_BUSY: _NVENCSTATUS = 13;
#[doc = " This indicates that the size of the user buffer passed by the client is\n insufficient for the requested operation."]
pub const _NVENCSTATUS_NV_ENC_ERR_NOT_ENOUGH_BUFFER: _NVENCSTATUS = 14;
#[doc = " This indicates that an invalid struct version was used by the client."]
pub const _NVENCSTATUS_NV_ENC_ERR_INVALID_VERSION: _NVENCSTATUS = 15;
#[doc = " This indicates that ::NvEncMapInputResource() API failed to map the client\n provided input resource."]
pub const _NVENCSTATUS_NV_ENC_ERR_MAP_FAILED: _NVENCSTATUS = 16;
#[doc = " This indicates encode driver requires more input buffers to produce an output\n bitstream. If this error is returned from ::NvEncEncodePicture() API, this\n is not a fatal error. If the client is encoding with B frames then,\n ::NvEncEncodePicture() API might be buffering the input frame for re-ordering.\n\n A client operating in synchronous mode cannot call ::NvEncLockBitstream()\n API on the output bitstream buffer if ::NvEncEncodePicture() returned the\n ::NV_ENC_ERR_NEED_MORE_INPUT error code.\n The client must continue providing input frames until encode driver returns\n ::NV_ENC_SUCCESS. After receiving ::NV_ENC_SUCCESS status the client can call\n ::NvEncLockBitstream() API on the output buffers in the same order in which\n it has called ::NvEncEncodePicture()."]
pub const _NVENCSTATUS_NV_ENC_ERR_NEED_MORE_INPUT: _NVENCSTATUS = 17;
#[doc = " This indicates that the HW encoder is busy encoding and is unable to encode\n the input. The client should call ::NvEncEncodePicture() again after few\n milliseconds."]
pub const _NVENCSTATUS_NV_ENC_ERR_ENCODER_BUSY: _NVENCSTATUS = 18;
#[doc = " This indicates that the completion event passed in ::NvEncEncodePicture()\n API has not been registered with encoder driver using ::NvEncRegisterAsyncEvent()."]
pub const _NVENCSTATUS_NV_ENC_ERR_EVENT_NOT_REGISTERD: _NVENCSTATUS = 19;
#[doc = " This indicates that an unknown internal error has occurred."]
pub const _NVENCSTATUS_NV_ENC_ERR_GENERIC: _NVENCSTATUS = 20;
#[doc = " This indicates that the client is attempting to use a feature\n that is not available for the license type for the current system."]
pub const _NVENCSTATUS_NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY: _NVENCSTATUS = 21;
#[doc = " This indicates that the client is attempting to use a feature\n that is not implemented for the current version."]
pub const _NVENCSTATUS_NV_ENC_ERR_UNIMPLEMENTED: _NVENCSTATUS = 22;
#[doc = " This indicates that the ::NvEncRegisterResource API failed to register the resource."]
pub const _NVENCSTATUS_NV_ENC_ERR_RESOURCE_REGISTER_FAILED: _NVENCSTATUS = 23;
#[doc = " This indicates that the client is attempting to unregister a resource\n that has not been successfully registered."]
pub const _NVENCSTATUS_NV_ENC_ERR_RESOURCE_NOT_REGISTERED: _NVENCSTATUS = 24;
#[doc = " This indicates that the client is attempting to unmap a resource\n that has not been successfully mapped."]
pub const _NVENCSTATUS_NV_ENC_ERR_RESOURCE_NOT_MAPPED: _NVENCSTATUS = 25;
#[doc = " Error Codes"]
pub type _NVENCSTATUS = ::std::os::raw::c_int;
#[doc = " Error Codes"]
pub use self::_NVENCSTATUS as NVENCSTATUS;
#[doc = "< Encode the current picture as an Intra picture"]
pub const _NV_ENC_PIC_FLAGS_NV_ENC_PIC_FLAG_FORCEINTRA: _NV_ENC_PIC_FLAGS = 1;
#[doc = "< Encode the current picture as an IDR picture.\nThis flag is only valid when Picture type decision is taken by the Encoder\n[_NV_ENC_INITIALIZE_PARAMS::enablePTD == 1]."]
pub const _NV_ENC_PIC_FLAGS_NV_ENC_PIC_FLAG_FORCEIDR: _NV_ENC_PIC_FLAGS = 2;
#[doc = "< Write the sequence and picture header in encoded bitstream of the current picture"]
pub const _NV_ENC_PIC_FLAGS_NV_ENC_PIC_FLAG_OUTPUT_SPSPPS: _NV_ENC_PIC_FLAGS = 4;
#[doc = "< Indicates end of the input stream"]
pub const _NV_ENC_PIC_FLAGS_NV_ENC_PIC_FLAG_EOS: _NV_ENC_PIC_FLAGS = 8;
#[doc = " Encode Picture encode flags."]
pub type _NV_ENC_PIC_FLAGS = ::std::os::raw::c_int;
#[doc = " Encode Picture encode flags."]
pub use self::_NV_ENC_PIC_FLAGS as NV_ENC_PIC_FLAGS;
#[doc = "< Memory heap to be decided by the encoder driver based on the usage"]
pub const _NV_ENC_MEMORY_HEAP_NV_ENC_MEMORY_HEAP_AUTOSELECT: _NV_ENC_MEMORY_HEAP = 0;
#[doc = "< Memory heap is in local video memory"]
pub const _NV_ENC_MEMORY_HEAP_NV_ENC_MEMORY_HEAP_VID: _NV_ENC_MEMORY_HEAP = 1;
#[doc = "< Memory heap is in cached system memory"]
pub const _NV_ENC_MEMORY_HEAP_NV_ENC_MEMORY_HEAP_SYSMEM_CACHED: _NV_ENC_MEMORY_HEAP = 2;
#[doc = "< Memory heap is in uncached system memory"]
pub const _NV_ENC_MEMORY_HEAP_NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED: _NV_ENC_MEMORY_HEAP = 3;
#[doc = " Memory heap to allocate input and output buffers."]
pub type _NV_ENC_MEMORY_HEAP = ::std::os::raw::c_int;
#[doc = " Memory heap to allocate input and output buffers."]
pub use self::_NV_ENC_MEMORY_HEAP as NV_ENC_MEMORY_HEAP;
#[doc = "< B frame is not used for reference"]
pub const _NV_ENC_BFRAME_REF_MODE_NV_ENC_BFRAME_REF_MODE_DISABLED: _NV_ENC_BFRAME_REF_MODE = 0;
#[doc = "< Each B-frame will be used for reference"]
pub const _NV_ENC_BFRAME_REF_MODE_NV_ENC_BFRAME_REF_MODE_EACH: _NV_ENC_BFRAME_REF_MODE = 1;
#[doc = "< Only(Number of B-frame)/2 th B-frame will be used for reference"]
pub const _NV_ENC_BFRAME_REF_MODE_NV_ENC_BFRAME_REF_MODE_MIDDLE: _NV_ENC_BFRAME_REF_MODE = 2;
#[doc = " B-frame used as reference modes"]
pub type _NV_ENC_BFRAME_REF_MODE = ::std::os::raw::c_int;
#[doc = " B-frame used as reference modes"]
pub use self::_NV_ENC_BFRAME_REF_MODE as NV_ENC_BFRAME_REF_MODE;
#[doc = "< Entropy coding mode is auto selected by the encoder driver"]
pub const _NV_ENC_H264_ENTROPY_CODING_MODE_NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT:
    _NV_ENC_H264_ENTROPY_CODING_MODE = 0;
#[doc = "< Entropy coding mode is CABAC"]
pub const _NV_ENC_H264_ENTROPY_CODING_MODE_NV_ENC_H264_ENTROPY_CODING_MODE_CABAC:
    _NV_ENC_H264_ENTROPY_CODING_MODE = 1;
#[doc = "< Entropy coding mode is CAVLC"]
pub const _NV_ENC_H264_ENTROPY_CODING_MODE_NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC:
    _NV_ENC_H264_ENTROPY_CODING_MODE = 2;
#[doc = " H.264 entropy coding modes."]
pub type _NV_ENC_H264_ENTROPY_CODING_MODE = ::std::os::raw::c_int;
#[doc = " H.264 entropy coding modes."]
pub use self::_NV_ENC_H264_ENTROPY_CODING_MODE as NV_ENC_H264_ENTROPY_CODING_MODE;
#[doc = "< BDirect mode is auto selected by the encoder driver"]
pub const _NV_ENC_H264_BDIRECT_MODE_NV_ENC_H264_BDIRECT_MODE_AUTOSELECT: _NV_ENC_H264_BDIRECT_MODE =
    0;
#[doc = "< Disable BDirect mode"]
pub const _NV_ENC_H264_BDIRECT_MODE_NV_ENC_H264_BDIRECT_MODE_DISABLE: _NV_ENC_H264_BDIRECT_MODE = 1;
#[doc = "< Temporal BDirect mode"]
pub const _NV_ENC_H264_BDIRECT_MODE_NV_ENC_H264_BDIRECT_MODE_TEMPORAL: _NV_ENC_H264_BDIRECT_MODE =
    2;
#[doc = "< Spatial BDirect mode"]
pub const _NV_ENC_H264_BDIRECT_MODE_NV_ENC_H264_BDIRECT_MODE_SPATIAL: _NV_ENC_H264_BDIRECT_MODE = 3;
#[doc = " H.264 specific BDirect modes"]
pub type _NV_ENC_H264_BDIRECT_MODE = ::std::os::raw::c_int;
#[doc = " H.264 specific BDirect modes"]
pub use self::_NV_ENC_H264_BDIRECT_MODE as NV_ENC_H264_BDIRECT_MODE;
#[doc = "< FMO usage is auto selected by the encoder driver"]
pub const _NV_ENC_H264_FMO_MODE_NV_ENC_H264_FMO_AUTOSELECT: _NV_ENC_H264_FMO_MODE = 0;
#[doc = "< Enable FMO"]
pub const _NV_ENC_H264_FMO_MODE_NV_ENC_H264_FMO_ENABLE: _NV_ENC_H264_FMO_MODE = 1;
#[doc = "< Disable FMO"]
pub const _NV_ENC_H264_FMO_MODE_NV_ENC_H264_FMO_DISABLE: _NV_ENC_H264_FMO_MODE = 2;
#[doc = " H.264 specific FMO usage"]
pub type _NV_ENC_H264_FMO_MODE = ::std::os::raw::c_int;
#[doc = " H.264 specific FMO usage"]
pub use self::_NV_ENC_H264_FMO_MODE as NV_ENC_H264_FMO_MODE;
#[doc = "< Adaptive Transform 8x8 mode is auto selected by the encoder driver"]
pub const _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE_NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT:
    _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE = 0;
#[doc = "< Adaptive Transform 8x8 mode disabled"]
pub const _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE_NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE:
    _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE = 1;
#[doc = "< Adaptive Transform 8x8 mode should be used"]
pub const _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE_NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE:
    _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE = 2;
#[doc = " H.264 specific Adaptive Transform modes"]
pub type _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE = ::std::os::raw::c_int;
#[doc = " H.264 specific Adaptive Transform modes"]
pub use self::_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE as NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE;
#[doc = "< No Stereo packing required"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_NONE: _NV_ENC_STEREO_PACKING_MODE =
    0;
#[doc = "< Checkerboard mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD:
    _NV_ENC_STEREO_PACKING_MODE = 1;
#[doc = "< Column Interleave mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE:
    _NV_ENC_STEREO_PACKING_MODE = 2;
#[doc = "< Row Interleave mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE:
    _NV_ENC_STEREO_PACKING_MODE = 3;
#[doc = "< Side-by-side mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE:
    _NV_ENC_STEREO_PACKING_MODE = 4;
#[doc = "< Top-Bottom mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM:
    _NV_ENC_STEREO_PACKING_MODE = 5;
#[doc = "< Frame Sequential mode for packing stereo frames"]
pub const _NV_ENC_STEREO_PACKING_MODE_NV_ENC_STEREO_PACKING_MODE_FRAMESEQ:
    _NV_ENC_STEREO_PACKING_MODE = 6;
#[doc = " Stereo frame packing modes."]
pub type _NV_ENC_STEREO_PACKING_MODE = ::std::os::raw::c_int;
#[doc = " Stereo frame packing modes."]
pub use self::_NV_ENC_STEREO_PACKING_MODE as NV_ENC_STEREO_PACKING_MODE;
#[doc = "< input resource type is a directx9 surface"]
pub const _NV_ENC_INPUT_RESOURCE_TYPE_NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX:
    _NV_ENC_INPUT_RESOURCE_TYPE = 0;
#[doc = "< input resource type is a cuda device pointer surface"]
pub const _NV_ENC_INPUT_RESOURCE_TYPE_NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR:
    _NV_ENC_INPUT_RESOURCE_TYPE = 1;
#[doc = "< input resource type is a cuda array surface.\nThis array must be a 2D array and the CUDA_ARRAY3D_SURFACE_LDST\nflag must have been specified when creating it."]
pub const _NV_ENC_INPUT_RESOURCE_TYPE_NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY:
    _NV_ENC_INPUT_RESOURCE_TYPE = 2;
#[doc = "< input resource type is an OpenGL texture"]
pub const _NV_ENC_INPUT_RESOURCE_TYPE_NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX:
    _NV_ENC_INPUT_RESOURCE_TYPE = 3;
#[doc = "  Input Resource type"]
pub type _NV_ENC_INPUT_RESOURCE_TYPE = ::std::os::raw::c_int;
#[doc = "  Input Resource type"]
pub use self::_NV_ENC_INPUT_RESOURCE_TYPE as NV_ENC_INPUT_RESOURCE_TYPE;
#[doc = "< Registered surface will be used for input image"]
pub const _NV_ENC_BUFFER_USAGE_NV_ENC_INPUT_IMAGE: _NV_ENC_BUFFER_USAGE = 0;
#[doc = "< Registered surface will be used for output of H.264 ME only mode.\nThis buffer usage type is not supported for HEVC ME only mode."]
pub const _NV_ENC_BUFFER_USAGE_NV_ENC_OUTPUT_MOTION_VECTOR: _NV_ENC_BUFFER_USAGE = 1;
#[doc = "< Registered surface will be used for output bitstream in encoding"]
pub const _NV_ENC_BUFFER_USAGE_NV_ENC_OUTPUT_BITSTREAM: _NV_ENC_BUFFER_USAGE = 2;
#[doc = "  Buffer usage"]
pub type _NV_ENC_BUFFER_USAGE = ::std::os::raw::c_int;
#[doc = "  Buffer usage"]
pub use self::_NV_ENC_BUFFER_USAGE as NV_ENC_BUFFER_USAGE;
#[doc = "< encode device type is a directx9 device"]
pub const _NV_ENC_DEVICE_TYPE_NV_ENC_DEVICE_TYPE_DIRECTX: _NV_ENC_DEVICE_TYPE = 0;
#[doc = "< encode device type is a cuda device"]
pub const _NV_ENC_DEVICE_TYPE_NV_ENC_DEVICE_TYPE_CUDA: _NV_ENC_DEVICE_TYPE = 1;
#[doc = "< encode device type is an OpenGL device.\nUse of this device type is supported only on Linux"]
pub const _NV_ENC_DEVICE_TYPE_NV_ENC_DEVICE_TYPE_OPENGL: _NV_ENC_DEVICE_TYPE = 2;
#[doc = "  Encoder Device type"]
pub type _NV_ENC_DEVICE_TYPE = ::std::os::raw::c_int;
#[doc = "  Encoder Device type"]
pub use self::_NV_ENC_DEVICE_TYPE as NV_ENC_DEVICE_TYPE;
#[doc = "< Number of reference frames is auto selected by the encoder driver"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_AUTOSELECT: _NV_ENC_NUM_REF_FRAMES = 0;
#[doc = "< Number of reference frames equal to 1"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_1: _NV_ENC_NUM_REF_FRAMES = 1;
#[doc = "< Number of reference frames equal to 2"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_2: _NV_ENC_NUM_REF_FRAMES = 2;
#[doc = "< Number of reference frames equal to 3"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_3: _NV_ENC_NUM_REF_FRAMES = 3;
#[doc = "< Number of reference frames equal to 4"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_4: _NV_ENC_NUM_REF_FRAMES = 4;
#[doc = "< Number of reference frames equal to 5"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_5: _NV_ENC_NUM_REF_FRAMES = 5;
#[doc = "< Number of reference frames equal to 6"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_6: _NV_ENC_NUM_REF_FRAMES = 6;
#[doc = "< Number of reference frames equal to 7"]
pub const _NV_ENC_NUM_REF_FRAMES_NV_ENC_NUM_REF_FRAMES_7: _NV_ENC_NUM_REF_FRAMES = 7;
#[doc = " Number of reference frames"]
pub type _NV_ENC_NUM_REF_FRAMES = ::std::os::raw::c_int;
#[doc = " Number of reference frames"]
pub use self::_NV_ENC_NUM_REF_FRAMES as NV_ENC_NUM_REF_FRAMES;
#[doc = " Maximum number of B-Frames supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_NUM_MAX_BFRAMES: _NV_ENC_CAPS = 0;
#[doc = " Rate control modes supported.\n \\n The API return value is a bitmask of the values in NV_ENC_PARAMS_RC_MODE."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES: _NV_ENC_CAPS = 1;
#[doc = " Indicates HW support for field mode encoding.\n \\n 0 : Interlaced mode encoding is not supported.\n \\n 1 : Interlaced field mode encoding is supported.\n \\n 2 : Interlaced frame encoding and field mode encoding are both supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_FIELD_ENCODING: _NV_ENC_CAPS = 2;
#[doc = " Indicates HW support for monochrome mode encoding.\n \\n 0 : Monochrome mode not supported.\n \\n 1 : Monochrome mode supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_MONOCHROME: _NV_ENC_CAPS = 3;
#[doc = " Indicates HW support for FMO.\n \\n 0 : FMO not supported.\n \\n 1 : FMO supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_FMO: _NV_ENC_CAPS = 4;
#[doc = " Indicates HW capability for Quarter pel motion estimation.\n \\n 0 : Quarter-Pel Motion Estimation not supported.\n \\n 1 : Quarter-Pel Motion Estimation supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_QPELMV: _NV_ENC_CAPS = 5;
#[doc = " H.264 specific. Indicates HW support for BDirect modes.\n \\n 0 : BDirect mode encoding not supported.\n \\n 1 : BDirect mode encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_BDIRECT_MODE: _NV_ENC_CAPS = 6;
#[doc = " H264 specific. Indicates HW support for CABAC entropy coding mode.\n \\n 0 : CABAC entropy coding not supported.\n \\n 1 : CABAC entropy coding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_CABAC: _NV_ENC_CAPS = 7;
#[doc = " Indicates HW support for Adaptive Transform.\n \\n 0 : Adaptive Transform not supported.\n \\n 1 : Adaptive Transform supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM: _NV_ENC_CAPS = 8;
#[doc = " Indicates HW support for Multi View Coding.\n \\n 0 : Multi View Coding not supported.\n \\n 1 : Multi View Coding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_STEREO_MVC: _NV_ENC_CAPS = 9;
#[doc = " Indicates HW support for encoding Temporal layers.\n \\n 0 : Encoding Temporal layers not supported.\n \\n 1 : Encoding Temporal layers supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS: _NV_ENC_CAPS = 10;
#[doc = " Indicates HW support for Hierarchical P frames.\n \\n 0 : Hierarchical P frames not supported.\n \\n 1 : Hierarchical P frames supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES: _NV_ENC_CAPS = 11;
#[doc = " Indicates HW support for Hierarchical B frames.\n \\n 0 : Hierarchical B frames not supported.\n \\n 1 : Hierarchical B frames supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES: _NV_ENC_CAPS = 12;
#[doc = " Maximum Encoding level supported (See ::NV_ENC_LEVEL for details)."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_LEVEL_MAX: _NV_ENC_CAPS = 13;
#[doc = " Minimum Encoding level supported (See ::NV_ENC_LEVEL for details)."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_LEVEL_MIN: _NV_ENC_CAPS = 14;
#[doc = " Indicates HW support for separate colour plane encoding.\n \\n 0 : Separate colour plane encoding not supported.\n \\n 1 : Separate colour plane encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SEPARATE_COLOUR_PLANE: _NV_ENC_CAPS = 15;
#[doc = " Maximum output width supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_WIDTH_MAX: _NV_ENC_CAPS = 16;
#[doc = " Maximum output height supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_HEIGHT_MAX: _NV_ENC_CAPS = 17;
#[doc = " Indicates Temporal Scalability Support.\n \\n 0 : Temporal SVC encoding not supported.\n \\n 1 : Temporal SVC encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC: _NV_ENC_CAPS = 18;
#[doc = " Indicates Dynamic Encode Resolution Change Support.\n Support added from NvEncodeAPI version 2.0.\n \\n 0 : Dynamic Encode Resolution Change not supported.\n \\n 1 : Dynamic Encode Resolution Change supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE: _NV_ENC_CAPS = 19;
#[doc = " Indicates Dynamic Encode Bitrate Change Support.\n Support added from NvEncodeAPI version 2.0.\n \\n 0 : Dynamic Encode bitrate change not supported.\n \\n 1 : Dynamic Encode bitrate change supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE: _NV_ENC_CAPS = 20;
#[doc = " Indicates Forcing Constant QP On The Fly Support.\n Support added from NvEncodeAPI version 2.0.\n \\n 0 : Forcing constant QP on the fly not supported.\n \\n 1 : Forcing constant QP on the fly supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP: _NV_ENC_CAPS = 21;
#[doc = " Indicates Dynamic rate control mode Change Support.\n \\n 0 : Dynamic rate control mode change not supported.\n \\n 1 : Dynamic rate control mode change supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE: _NV_ENC_CAPS = 22;
#[doc = " Indicates Subframe readback support for slice-based encoding. If this feature is supported, it can be enabled by setting enableSubFrameWrite = 1.\n \\n 0 : Subframe readback not supported.\n \\n 1 : Subframe readback supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK: _NV_ENC_CAPS = 23;
#[doc = " Indicates Constrained Encoding mode support.\n Support added from NvEncodeAPI version 2.0.\n \\n 0 : Constrained encoding mode not supported.\n \\n 1 : Constrained encoding mode supported.\n If this mode is supported client can enable this during initialization.\n Client can then force a picture to be coded as constrained picture where\n in-loop filtering is disabled across slice boundaries and prediction vectors for inter\n macroblocks in each slice will be restricted to the slice region."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING: _NV_ENC_CAPS = 24;
#[doc = " Indicates Intra Refresh Mode Support.\n Support added from NvEncodeAPI version 2.0.\n \\n 0 : Intra Refresh Mode not supported.\n \\n 1 : Intra Refresh Mode supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_INTRA_REFRESH: _NV_ENC_CAPS = 25;
#[doc = " Indicates Custom VBV Buffer Size support. It can be used for capping frame size.\n Support added from NvEncodeAPI version 2.0.\n \\n 0 : Custom VBV buffer size specification from client, not supported.\n \\n 1 : Custom VBV buffer size specification from client, supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE: _NV_ENC_CAPS = 26;
#[doc = " Indicates Dynamic Slice Mode Support.\n Support added from NvEncodeAPI version 2.0.\n \\n 0 : Dynamic Slice Mode not supported.\n \\n 1 : Dynamic Slice Mode supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE: _NV_ENC_CAPS = 27;
#[doc = " Indicates Reference Picture Invalidation Support.\n Support added from NvEncodeAPI version 2.0.\n \\n 0 : Reference Picture Invalidation not supported.\n \\n 1 : Reference Picture Invalidation supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION: _NV_ENC_CAPS = 28;
#[doc = " Indicates support for Pre-Processing.\n The API return value is a bitmask of the values defined in ::NV_ENC_PREPROC_FLAGS"]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_PREPROC_SUPPORT: _NV_ENC_CAPS = 29;
#[doc = " Indicates support Async mode.\n \\n 0 : Async Encode mode not supported.\n \\n 1 : Async Encode mode supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT: _NV_ENC_CAPS = 30;
#[doc = " Maximum MBs per frame supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_MB_NUM_MAX: _NV_ENC_CAPS = 31;
#[doc = " Maximum aggregate throughput in MBs per sec."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_MB_PER_SEC_MAX: _NV_ENC_CAPS = 32;
#[doc = " Indicates HW support for YUV444 mode encoding.\n \\n 0 : YUV444 mode encoding not supported.\n \\n 1 : YUV444 mode encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_YUV444_ENCODE: _NV_ENC_CAPS = 33;
#[doc = " Indicates HW support for lossless encoding.\n \\n 0 : lossless encoding not supported.\n \\n 1 : lossless encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE: _NV_ENC_CAPS = 34;
#[doc = " Indicates HW support for Sample Adaptive Offset.\n \\n 0 : SAO not supported.\n \\n 1 : SAO encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_SAO: _NV_ENC_CAPS = 35;
#[doc = " Indicates HW support for Motion Estimation Only Mode.\n \\n 0 : MEOnly Mode not supported.\n \\n 1 : MEOnly Mode supported for I and P frames.\n \\n 2 : MEOnly Mode supported for I, P and B frames."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_MEONLY_MODE: _NV_ENC_CAPS = 36;
#[doc = " Indicates HW support for lookahead encoding (enableLookahead=1).\n \\n 0 : Lookahead not supported.\n \\n 1 : Lookahead supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_LOOKAHEAD: _NV_ENC_CAPS = 37;
#[doc = " Indicates HW support for temporal AQ encoding (enableTemporalAQ=1).\n \\n 0 : Temporal AQ not supported.\n \\n 1 : Temporal AQ supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ: _NV_ENC_CAPS = 38;
#[doc = " Indicates HW support for 10 bit encoding.\n \\n 0 : 10 bit encoding not supported.\n \\n 1 : 10 bit encoding supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_10BIT_ENCODE: _NV_ENC_CAPS = 39;
#[doc = " Maximum number of Long Term Reference frames supported"]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_NUM_MAX_LTR_FRAMES: _NV_ENC_CAPS = 40;
#[doc = " Indicates HW support for Weighted Prediction.\n \\n 0 : Weighted Prediction not supported.\n \\n 1 : Weighted Prediction supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_WEIGHTED_PREDICTION: _NV_ENC_CAPS = 41;
#[doc = " On managed (vGPU) platforms (Windows only), this API, in conjunction with other GRID Management APIs, can be used\n to estimate the residual capacity of the hardware encoder on the GPU as a percentage of the total available encoder capacity.\n This API can be called at any time; i.e. during the encode session or before opening the encode session.\n If the available encoder capacity is returned as zero, applications may choose to switch to software encoding\n and continue to call this API (e.g. polling once per second) until capacity becomes available.\n\n On bare metal (non-virtualized GPU) and linux platforms, this API always returns 100."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY: _NV_ENC_CAPS = 42;
#[doc = " Indicates B as reference support.\n \\n 0 : B as reference is not supported.\n \\n 1 : each B-Frame as reference is supported.\n \\n 2 : only Middle B-frame as reference is supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE: _NV_ENC_CAPS = 43;
#[doc = " Indicates HW support for Emphasis Level Map based delta QP computation.\n \\n 0 : Emphasis Level Map based delta QP not supported.\n \\n 1 : Emphasis Level Map based delta QP is supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_EMPHASIS_LEVEL_MAP: _NV_ENC_CAPS = 44;
#[doc = " Minimum input width supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_WIDTH_MIN: _NV_ENC_CAPS = 45;
#[doc = " Minimum input height supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_HEIGHT_MIN: _NV_ENC_CAPS = 46;
#[doc = " Indicates HW support for multiple reference frames."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES: _NV_ENC_CAPS = 47;
#[doc = " Indicates HW support for HEVC with alpha encoding.\n \\n 0 : HEVC with alpha encoding not supported.\n \\n 1 : HEVC with alpha encoding is supported."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SUPPORT_ALPHA_LAYER_ENCODING: _NV_ENC_CAPS = 48;
#[doc = " Indicates number of Encoding engines present on GPU."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_NUM_ENCODER_ENGINES: _NV_ENC_CAPS = 49;
#[doc = " Indicates single slice intra refresh support."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH: _NV_ENC_CAPS = 50;
#[doc = " Reserved - Not to be used by clients."]
pub const _NV_ENC_CAPS_NV_ENC_CAPS_EXPOSED_COUNT: _NV_ENC_CAPS = 51;
#[doc = " Encoder capabilities enumeration."]
pub type _NV_ENC_CAPS = ::std::os::raw::c_int;
#[doc = " Encoder capabilities enumeration."]
pub use self::_NV_ENC_CAPS as NV_ENC_CAPS;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_AUTOSELECT: _NV_ENC_HEVC_CUSIZE = 0;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_8x8: _NV_ENC_HEVC_CUSIZE = 1;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_16x16: _NV_ENC_HEVC_CUSIZE = 2;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_32x32: _NV_ENC_HEVC_CUSIZE = 3;
pub const _NV_ENC_HEVC_CUSIZE_NV_ENC_HEVC_CUSIZE_64x64: _NV_ENC_HEVC_CUSIZE = 4;
#[doc = "  HEVC CU SIZE"]
pub type _NV_ENC_HEVC_CUSIZE = ::std::os::raw::c_int;
#[doc = "  HEVC CU SIZE"]
pub use self::_NV_ENC_HEVC_CUSIZE as NV_ENC_HEVC_CUSIZE;
pub const _NV_ENC_AV1_PART_SIZE_NV_ENC_AV1_PART_SIZE_AUTOSELECT: _NV_ENC_AV1_PART_SIZE = 0;
pub const _NV_ENC_AV1_PART_SIZE_NV_ENC_AV1_PART_SIZE_4x4: _NV_ENC_AV1_PART_SIZE = 1;
pub const _NV_ENC_AV1_PART_SIZE_NV_ENC_AV1_PART_SIZE_8x8: _NV_ENC_AV1_PART_SIZE = 2;
pub const _NV_ENC_AV1_PART_SIZE_NV_ENC_AV1_PART_SIZE_16x16: _NV_ENC_AV1_PART_SIZE = 3;
pub const _NV_ENC_AV1_PART_SIZE_NV_ENC_AV1_PART_SIZE_32x32: _NV_ENC_AV1_PART_SIZE = 4;
pub const _NV_ENC_AV1_PART_SIZE_NV_ENC_AV1_PART_SIZE_64x64: _NV_ENC_AV1_PART_SIZE = 5;
#[doc = "  AV1 PART SIZE"]
pub type _NV_ENC_AV1_PART_SIZE = ::std::os::raw::c_int;
#[doc = "  AV1 PART SIZE"]
pub use self::_NV_ENC_AV1_PART_SIZE as NV_ENC_AV1_PART_SIZE;
pub const _NV_ENC_VUI_VIDEO_FORMAT_NV_ENC_VUI_VIDEO_FORMAT_COMPONENT: _NV_ENC_VUI_VIDEO_FORMAT = 0;
pub const _NV_ENC_VUI_VIDEO_FORMAT_NV_ENC_VUI_VIDEO_FORMAT_PAL: _NV_ENC_VUI_VIDEO_FORMAT = 1;
pub const _NV_ENC_VUI_VIDEO_FORMAT_NV_ENC_VUI_VIDEO_FORMAT_NTSC: _NV_ENC_VUI_VIDEO_FORMAT = 2;
pub const _NV_ENC_VUI_VIDEO_FORMAT_NV_ENC_VUI_VIDEO_FORMAT_SECAM: _NV_ENC_VUI_VIDEO_FORMAT = 3;
pub const _NV_ENC_VUI_VIDEO_FORMAT_NV_ENC_VUI_VIDEO_FORMAT_MAC: _NV_ENC_VUI_VIDEO_FORMAT = 4;
pub const _NV_ENC_VUI_VIDEO_FORMAT_NV_ENC_VUI_VIDEO_FORMAT_UNSPECIFIED: _NV_ENC_VUI_VIDEO_FORMAT =
    5;
#[doc = "  Enums related to fields in VUI parameters."]
pub type _NV_ENC_VUI_VIDEO_FORMAT = ::std::os::raw::c_int;
#[doc = "  Enums related to fields in VUI parameters."]
pub use self::_NV_ENC_VUI_VIDEO_FORMAT as NV_ENC_VUI_VIDEO_FORMAT;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_UNDEFINED:
    _NV_ENC_VUI_COLOR_PRIMARIES = 0;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_BT709:
    _NV_ENC_VUI_COLOR_PRIMARIES = 1;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_UNSPECIFIED:
    _NV_ENC_VUI_COLOR_PRIMARIES = 2;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_RESERVED:
    _NV_ENC_VUI_COLOR_PRIMARIES = 3;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_BT470M:
    _NV_ENC_VUI_COLOR_PRIMARIES = 4;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_BT470BG:
    _NV_ENC_VUI_COLOR_PRIMARIES = 5;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_SMPTE170M:
    _NV_ENC_VUI_COLOR_PRIMARIES = 6;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_SMPTE240M:
    _NV_ENC_VUI_COLOR_PRIMARIES = 7;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_FILM: _NV_ENC_VUI_COLOR_PRIMARIES =
    8;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_BT2020:
    _NV_ENC_VUI_COLOR_PRIMARIES = 9;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_SMPTE428:
    _NV_ENC_VUI_COLOR_PRIMARIES = 10;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_SMPTE431:
    _NV_ENC_VUI_COLOR_PRIMARIES = 11;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_SMPTE432:
    _NV_ENC_VUI_COLOR_PRIMARIES = 12;
pub const _NV_ENC_VUI_COLOR_PRIMARIES_NV_ENC_VUI_COLOR_PRIMARIES_JEDEC_P22:
    _NV_ENC_VUI_COLOR_PRIMARIES = 22;
pub type _NV_ENC_VUI_COLOR_PRIMARIES = ::std::os::raw::c_int;
pub use self::_NV_ENC_VUI_COLOR_PRIMARIES as NV_ENC_VUI_COLOR_PRIMARIES;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_UNDEFINED:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 0;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT709:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 1;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_UNSPECIFIED:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 2;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_RESERVED:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 3;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT470M:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 4;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT470BG:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 5;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE170M:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 6;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE240M:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 7;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LINEAR:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 8;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LOG:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 9;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LOG_SQRT:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 10;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_IEC61966_2_4:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 11;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT1361_ECG:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 12;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SRGB:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 13;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT2020_10:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 14;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT2020_12:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 15;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE2084:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 16;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE428:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 17;
pub const _NV_ENC_VUI_TRANSFER_CHARACTERISTIC_NV_ENC_VUI_TRANSFER_CHARACTERISTIC_ARIB_STD_B67:
    _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = 18;
pub type _NV_ENC_VUI_TRANSFER_CHARACTERISTIC = ::std::os::raw::c_int;
pub use self::_NV_ENC_VUI_TRANSFER_CHARACTERISTIC as NV_ENC_VUI_TRANSFER_CHARACTERISTIC;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_RGB: _NV_ENC_VUI_MATRIX_COEFFS = 0;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_BT709: _NV_ENC_VUI_MATRIX_COEFFS = 1;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_UNSPECIFIED:
    _NV_ENC_VUI_MATRIX_COEFFS = 2;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_RESERVED: _NV_ENC_VUI_MATRIX_COEFFS =
    3;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_FCC: _NV_ENC_VUI_MATRIX_COEFFS = 4;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_BT470BG: _NV_ENC_VUI_MATRIX_COEFFS = 5;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_SMPTE170M: _NV_ENC_VUI_MATRIX_COEFFS =
    6;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_SMPTE240M: _NV_ENC_VUI_MATRIX_COEFFS =
    7;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_YCGCO: _NV_ENC_VUI_MATRIX_COEFFS = 8;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_BT2020_NCL: _NV_ENC_VUI_MATRIX_COEFFS =
    9;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_BT2020_CL: _NV_ENC_VUI_MATRIX_COEFFS =
    10;
pub const _NV_ENC_VUI_MATRIX_COEFFS_NV_ENC_VUI_MATRIX_COEFFS_SMPTE2085: _NV_ENC_VUI_MATRIX_COEFFS =
    11;
pub type _NV_ENC_VUI_MATRIX_COEFFS = ::std::os::raw::c_int;
pub use self::_NV_ENC_VUI_MATRIX_COEFFS as NV_ENC_VUI_MATRIX_COEFFS;
#[doc = " Input struct for querying Encoding capabilities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CAPS_PARAM {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CAPS_PARAM_VER"]
    pub version: u32,
    #[doc = "< [in]: Specifies the encode capability to be queried. Client should pass a member for ::NV_ENC_CAPS enum."]
    pub capsToQuery: NV_ENC_CAPS,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CAPS_PARAM() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CAPS_PARAM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CAPS_PARAM>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CAPS_PARAM>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capsToQuery) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(capsToQuery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Input struct for querying Encoding capabilities."]
pub type NV_ENC_CAPS_PARAM = _NV_ENC_CAPS_PARAM;
#[doc = " Encoder Output parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_ENCODE_OUT_PARAMS {
    #[doc = "< [out]: Struct version."]
    pub version: u32,
    #[doc = "< [out]: Encoded bitstream size in bytes"]
    pub bitstreamSizeInBytes: u32,
    #[doc = "< [out]: Reserved and must be set to 0"]
    pub reserved: [u32; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_ENCODE_OUT_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_ENCODE_OUT_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_ENCODE_OUT_PARAMS>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_ENCODE_OUT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_ENCODE_OUT_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_ENCODE_OUT_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitstreamSizeInBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Encoder Output parameters"]
pub type NV_ENC_ENCODE_OUT_PARAMS = _NV_ENC_ENCODE_OUT_PARAMS;
#[doc = " Creation parameters for input buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CREATE_INPUT_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CREATE_INPUT_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [in]: Input frame width"]
    pub width: u32,
    #[doc = "< [in]: Input frame height"]
    pub height: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    #[doc = "< [in]: Input buffer format"]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Pointer to input buffer"]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Pointer to existing system memory buffer"]
    pub pSysMemBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 57usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_INPUT_BUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CREATE_INPUT_BUFFER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryHeap) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferFmt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSysMemBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(pSysMemBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for input buffer."]
pub type NV_ENC_CREATE_INPUT_BUFFER = _NV_ENC_CREATE_INPUT_BUFFER;
#[doc = " Creation parameters for output bitstream buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CREATE_BITSTREAM_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CREATE_BITSTREAM_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub size: u32,
    #[doc = "< [in]: Deprecated. Do not use"]
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Pointer to the output bitstream buffer"]
    pub bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [out]: Reserved and should not be used"]
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and should be set to 0"]
    pub reserved1: [u32; 58usize],
    #[doc = "< [in]: Reserved and should be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_BITSTREAM_BUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CREATE_BITSTREAM_BUFFER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryHeap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitstreamBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitstreamBufferPtr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for output bitstream buffer."]
pub type NV_ENC_CREATE_BITSTREAM_BUFFER = _NV_ENC_CREATE_BITSTREAM_BUFFER;
#[doc = " Structs needed for ME only mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_MVECTOR {
    #[doc = "< the x component of MV in quarter-pel units"]
    pub mvx: i16,
    #[doc = "< the y component of MV in quarter-pel units"]
    pub mvy: i16,
}
#[test]
fn bindgen_test_layout__NV_ENC_MVECTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_MVECTOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MVECTOR>(),
        4usize,
        concat!("Size of: ", stringify!(_NV_ENC_MVECTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MVECTOR>(),
        2usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MVECTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MVECTOR),
            "::",
            stringify!(mvx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MVECTOR),
            "::",
            stringify!(mvy)
        )
    );
}
#[doc = " Structs needed for ME only mode."]
pub type NV_ENC_MVECTOR = _NV_ENC_MVECTOR;
#[doc = " Motion vector structure per macroblock for H264 motion estimation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_H264_MV_DATA {
    #[doc = "< up to 4 vectors for 8x8 partition"]
    pub mv: [NV_ENC_MVECTOR; 4usize],
    #[doc = "< 0 (I), 1 (P), 2 (IPCM), 3 (B)"]
    pub mbType: u8,
    #[doc = "< Specifies the block partition type. 0:16x16, 1:8x8, 2:16x8, 3:8x16"]
    pub partitionType: u8,
    #[doc = "< reserved padding for alignment"]
    pub reserved: u16,
    pub mbCost: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_H264_MV_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_H264_MV_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_H264_MV_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_ENC_H264_MV_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_H264_MV_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_H264_MV_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mbType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partitionType) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(partitionType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbCost) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mbCost)
        )
    );
}
#[doc = " Motion vector structure per macroblock for H264 motion estimation."]
pub type NV_ENC_H264_MV_DATA = _NV_ENC_H264_MV_DATA;
#[doc = " Motion vector structure per CU for HEVC motion estimation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_HEVC_MV_DATA {
    #[doc = "< up to 4 vectors within a CU"]
    pub mv: [NV_ENC_MVECTOR; 4usize],
    #[doc = "< 0 (I), 1(P)"]
    pub cuType: u8,
    #[doc = "< 0: 8x8, 1: 16x16, 2: 32x32, 3: 64x64"]
    pub cuSize: u8,
    #[doc = "< The CU partition mode\n0 (2Nx2N), 1 (2NxN), 2(Nx2N), 3 (NxN),\n4 (2NxnU), 5 (2NxnD), 6(nLx2N), 7 (nRx2N)"]
    pub partitionMode: u8,
    #[doc = "< Marker to separate CUs in the current CTB from CUs in the next CTB"]
    pub lastCUInCTB: u8,
}
#[test]
fn bindgen_test_layout__NV_ENC_HEVC_MV_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_HEVC_MV_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_HEVC_MV_DATA>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_ENC_HEVC_MV_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_HEVC_MV_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(_NV_ENC_HEVC_MV_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cuType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(cuType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cuSize) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(cuSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partitionMode) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(partitionMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastCUInCTB) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(lastCUInCTB)
        )
    );
}
#[doc = " Motion vector structure per CU for HEVC motion estimation."]
pub type NV_ENC_HEVC_MV_DATA = _NV_ENC_HEVC_MV_DATA;
#[doc = " Creation parameters for output motion vector buffer for ME only mode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CREATE_MV_BUFFER {
    #[doc = "< [in]: Struct version. Must be set to NV_ENC_CREATE_MV_BUFFER_VER"]
    pub version: u32,
    #[doc = "< [out]: Pointer to the output motion vector buffer"]
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Reserved and should be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and should be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_MV_BUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CREATE_MV_BUFFER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Creation parameters for output motion vector buffer for ME only mode."]
pub type NV_ENC_CREATE_MV_BUFFER = _NV_ENC_CREATE_MV_BUFFER;
#[doc = " QP value for frames"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_QP {
    #[doc = "< [in]: Specifies QP value for P-frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpInterP: u32,
    #[doc = "< [in]: Specifies QP value for B-frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpInterB: u32,
    #[doc = "< [in]: Specifies QP value for Intra Frame. Even though this field is uint32_t for legacy reasons, the client should treat this as a signed parameter(int32_t) for cases in which negative QP values are to be specified."]
    pub qpIntra: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_QP() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_QP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_QP>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_QP>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpInterP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpInterB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpIntra) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpIntra)
        )
    );
}
#[doc = " QP value for frames"]
pub type NV_ENC_QP = _NV_ENC_QP;
#[doc = " Rate Control Configuration Parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_RC_PARAMS {
    pub version: u32,
    #[doc = "< [in]: Specifies the rate control mode. Check support for various rate control modes using ::NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES caps."]
    pub rateControlMode: NV_ENC_PARAMS_RC_MODE,
    #[doc = "< [in]: Specifies the initial QP to be used for encoding, these values would be used for all frames if in Constant QP mode."]
    pub constQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the average bitrate(in bits/sec) used for encoding."]
    pub averageBitRate: u32,
    #[doc = "< [in]: Specifies the maximum bitrate for the encoded output. This is used for VBR and ignored for CBR mode."]
    pub maxBitRate: u32,
    #[doc = "< [in]: Specifies the VBV(HRD) buffer size. in bits. Set 0 to use the default VBV  buffer size."]
    pub vbvBufferSize: u32,
    #[doc = "< [in]: Specifies the VBV(HRD) initial delay in bits. Set 0 to use the default VBV  initial delay ."]
    pub vbvInitialDelay: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Specifies the minimum QP used for rate control. Client must set NV_ENC_CONFIG::enableMinQP to 1."]
    pub minQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the maximum QP used for rate control. Client must set NV_ENC_CONFIG::enableMaxQP to 1."]
    pub maxQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the initial QP used for rate control. Client must set NV_ENC_CONFIG::enableInitialRCQP to 1."]
    pub initialRCQP: NV_ENC_QP,
    #[doc = "< [in]: Specifies the temporal layers (as a bitmask) whose QPs have changed. Valid max bitmask is [2^NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS - 1].\nApplicable only for constant QP mode (NV_ENC_RC_PARAMS::rateControlMode = NV_ENC_PARAMS_RC_CONSTQP)."]
    pub temporallayerIdxMask: u32,
    #[doc = "< [in]: Specifies the temporal layer QPs used for rate control. Temporal layer index is used as the array index.\nApplicable only for constant QP mode (NV_ENC_RC_PARAMS::rateControlMode = NV_ENC_PARAMS_RC_CONSTQP)."]
    pub temporalLayerQP: [u8; 8usize],
    #[doc = "< [in]: Target CQ (Constant Quality) level for VBR mode (range 0-51 with 0-automatic)"]
    pub targetQuality: u8,
    #[doc = "< [in]: Fractional part of target quality (as 8.8 fixed point format)"]
    pub targetQualityLSB: u8,
    #[doc = "< [in]: Maximum depth of lookahead with range 0-(31 - number of B frames).\nlookaheadDepth is only used if enableLookahead=1."]
    pub lookaheadDepth: u16,
    #[doc = "< [in]: Specifies the ratio of I frame bits to P frame bits in case of single frame VBV and CBR rate control mode,\nis set to 2 by default for low latency tuning info and 1 by default for ultra low latency tuning info"]
    pub lowDelayKeyFrameScale: u8,
    #[doc = "< [in]: Specifies the value of 'deltaQ_y_dc' in AV1."]
    pub yDcQPIndexOffset: i8,
    #[doc = "< [in]: Specifies the value of 'deltaQ_u_dc' in AV1."]
    pub uDcQPIndexOffset: i8,
    #[doc = "< [in]: Specifies the value of 'deltaQ_v_dc' in AV1 (for future use only - deltaQ_v_dc is currently always internally set to same value as deltaQ_u_dc)."]
    pub vDcQPIndexOffset: i8,
    #[doc = "< [in]: This flag is used to interpret values in array specified by NV_ENC_PIC_PARAMS::qpDeltaMap.\nSet this to NV_ENC_QP_MAP_EMPHASIS to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as Emphasis Level Map.\nEmphasis Level can be assigned any value specified in enum NV_ENC_EMPHASIS_MAP_LEVEL.\nEmphasis Level Map is used to specify regions to be encoded at varying levels of quality.\nThe hardware encoder adjusts the quantization within the image as per the provided emphasis map,\nby adjusting the quantization parameter (QP) assigned to each macroblock. This adjustment is commonly called \"Delta QP\".\nThe adjustment depends on the absolute QP decided by the rate control algorithm, and is applied after the rate control has decided each macroblock's QP.\nSince the Delta QP overrides rate control, enabling Emphasis Level Map may violate bitrate and VBV buffer size constraints.\nEmphasis Level Map is useful in situations where client has a priori knowledge of the image complexity (e.g. via use of NVFBC's Classification feature) and encoding those high-complexity areas at higher quality (lower QP) is important, even at the possible cost of violating bitrate/VBV buffer size constraints\nThis feature is not supported when AQ( Spatial/Temporal) is enabled.\nThis feature is only supported for H264 codec currently.\n\nSet this to NV_ENC_QP_MAP_DELTA to treat values specified by NV_ENC_PIC_PARAMS::qpDeltaMap as QP Delta. This specifies QP modifier to be applied on top of the QP chosen by rate control\n\nSet this to NV_ENC_QP_MAP_DISABLED to ignore NV_ENC_PIC_PARAMS::qpDeltaMap values. In this case, qpDeltaMap should be set to NULL.\n\nOther values are reserved for future use."]
    pub qpMapMode: NV_ENC_QP_MAP_MODE,
    #[doc = "< [in]: This flag is used to enable multi-pass encoding for a given ::NV_ENC_PARAMS_RC_MODE. This flag is not valid for H264 and HEVC MEOnly mode"]
    pub multiPass: NV_ENC_MULTI_PASS,
    #[doc = "< [in]: Specifies the ratio in which bitrate should be split between base and alpha layer. A value 'x' for this field will split the target bitrate in a ratio of x : 1 between base and alpha layer.\nThe default split ratio is 15."]
    pub alphaLayerBitrateRatio: u32,
    #[doc = "< [in]: Specifies the value of 'chroma_qp_index_offset' in H264 / 'pps_cb_qp_offset' in HEVC / 'deltaQ_u_ac' in AV1."]
    pub cbQPIndexOffset: i8,
    #[doc = "< [in]: Specifies the value of 'second_chroma_qp_index_offset' in H264 / 'pps_cr_qp_offset' in HEVC / 'deltaQ_v_ac' in AV1 (for future use only - deltaQ_v_ac is currently always internally set to same value as deltaQ_u_ac)."]
    pub crQPIndexOffset: i8,
    pub reserved2: u16,
    pub reserved: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_RC_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_RC_PARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_RC_PARAMS>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_RC_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rateControlMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(rateControlMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constQP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(constQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).averageBitRate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(averageBitRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBitRate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxBitRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vbvBufferSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vbvInitialDelay) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvInitialDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minQP) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(minQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxQP) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialRCQP) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(initialRCQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporallayerIdxMask) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporallayerIdxMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalLayerQP) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporalLayerQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetQuality) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQuality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetQualityLSB) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQualityLSB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookaheadDepth) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lookaheadDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lowDelayKeyFrameScale) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lowDelayKeyFrameScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yDcQPIndexOffset) as usize - ptr as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(yDcQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uDcQPIndexOffset) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(uDcQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vDcQPIndexOffset) as usize - ptr as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vDcQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpMapMode) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(qpMapMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiPass) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(multiPass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alphaLayerBitrateRatio) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(alphaLayerBitrateRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbQPIndexOffset) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(cbQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crQPIndexOffset) as usize - ptr as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(crQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
impl _NV_ENC_RC_PARAMS {
    #[inline]
    pub fn enableMinQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMinQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMaxQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMaxQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableInitialRCQP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableInitialRCQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitField1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLookahead(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableBadapt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableBadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTemporalAQ(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zeroReorderDelay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zeroReorderDelay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNonRefP(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableNonRefP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strictGOPTarget(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strictGOPTarget(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aqStrength(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aqStrength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableMinQP: u32,
        enableMaxQP: u32,
        enableInitialRCQP: u32,
        enableAQ: u32,
        reservedBitField1: u32,
        enableLookahead: u32,
        disableIadapt: u32,
        disableBadapt: u32,
        enableTemporalAQ: u32,
        zeroReorderDelay: u32,
        enableNonRefP: u32,
        strictGOPTarget: u32,
        aqStrength: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableMinQP: u32 = unsafe { ::std::mem::transmute(enableMinQP) };
            enableMinQP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableMaxQP: u32 = unsafe { ::std::mem::transmute(enableMaxQP) };
            enableMaxQP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableInitialRCQP: u32 = unsafe { ::std::mem::transmute(enableInitialRCQP) };
            enableInitialRCQP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableAQ: u32 = unsafe { ::std::mem::transmute(enableAQ) };
            enableAQ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reservedBitField1: u32 = unsafe { ::std::mem::transmute(reservedBitField1) };
            reservedBitField1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLookahead: u32 = unsafe { ::std::mem::transmute(enableLookahead) };
            enableLookahead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableIadapt: u32 = unsafe { ::std::mem::transmute(disableIadapt) };
            disableIadapt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableBadapt: u32 = unsafe { ::std::mem::transmute(disableBadapt) };
            disableBadapt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableTemporalAQ: u32 = unsafe { ::std::mem::transmute(enableTemporalAQ) };
            enableTemporalAQ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zeroReorderDelay: u32 = unsafe { ::std::mem::transmute(zeroReorderDelay) };
            zeroReorderDelay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableNonRefP: u32 = unsafe { ::std::mem::transmute(enableNonRefP) };
            enableNonRefP as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strictGOPTarget: u32 = unsafe { ::std::mem::transmute(strictGOPTarget) };
            strictGOPTarget as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let aqStrength: u32 = unsafe { ::std::mem::transmute(aqStrength) };
            aqStrength as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Rate Control Configuration Parameters"]
pub type NV_ENC_RC_PARAMS = _NV_ENC_RC_PARAMS;
#[doc = " Clock Timestamp set parameters\n For H264, this structure is used to populate Picture Timing SEI when NV_ENC_CONFIG_H264::enableTimeCode is set to 1.\n For HEVC, this structure is used to populate Time Code SEI when NV_ENC_CONFIG_HEVC::enableTimeCodeSEI is set to 1.\n For more details, refer to Annex D of ITU-T Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CLOCK_TIMESTAMP_SET {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in] Specifies the 'time_offset_value'"]
    pub timeOffset: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_CLOCK_TIMESTAMP_SET() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CLOCK_TIMESTAMP_SET> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CLOCK_TIMESTAMP_SET>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_ENC_CLOCK_TIMESTAMP_SET))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CLOCK_TIMESTAMP_SET>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CLOCK_TIMESTAMP_SET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CLOCK_TIMESTAMP_SET),
            "::",
            stringify!(timeOffset)
        )
    );
}
impl _NV_ENC_CLOCK_TIMESTAMP_SET {
    #[inline]
    pub fn countingType(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_countingType(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn discontinuityFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discontinuityFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cntDroppedFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cntDroppedFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn secondsValue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_secondsValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn minutesValue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_minutesValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn hoursValue(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hoursValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        countingType: u32,
        discontinuityFlag: u32,
        cntDroppedFrames: u32,
        nFrames: u32,
        secondsValue: u32,
        minutesValue: u32,
        hoursValue: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let countingType: u32 = unsafe { ::std::mem::transmute(countingType) };
            countingType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let discontinuityFlag: u32 = unsafe { ::std::mem::transmute(discontinuityFlag) };
            discontinuityFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cntDroppedFrames: u32 = unsafe { ::std::mem::transmute(cntDroppedFrames) };
            cntDroppedFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let nFrames: u32 = unsafe { ::std::mem::transmute(nFrames) };
            nFrames as u64
        });
        __bindgen_bitfield_unit.set(11usize, 6u8, {
            let secondsValue: u32 = unsafe { ::std::mem::transmute(secondsValue) };
            secondsValue as u64
        });
        __bindgen_bitfield_unit.set(17usize, 6u8, {
            let minutesValue: u32 = unsafe { ::std::mem::transmute(minutesValue) };
            minutesValue as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let hoursValue: u32 = unsafe { ::std::mem::transmute(hoursValue) };
            hoursValue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Clock Timestamp set parameters\n For H264, this structure is used to populate Picture Timing SEI when NV_ENC_CONFIG_H264::enableTimeCode is set to 1.\n For HEVC, this structure is used to populate Time Code SEI when NV_ENC_CONFIG_HEVC::enableTimeCodeSEI is set to 1.\n For more details, refer to Annex D of ITU-T Specification."]
pub type NV_ENC_CLOCK_TIMESTAMP_SET = _NV_ENC_CLOCK_TIMESTAMP_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_TIME_CODE {
    #[doc = "< [in] Display picStruct"]
    pub displayPicStruct: NV_ENC_DISPLAY_PIC_STRUCT,
    #[doc = "< [in] Clock Timestamp set"]
    pub clockTimestamp: [NV_ENC_CLOCK_TIMESTAMP_SET; 3usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_TIME_CODE() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_TIME_CODE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_TIME_CODE>(),
        28usize,
        concat!("Size of: ", stringify!(_NV_ENC_TIME_CODE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_TIME_CODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_TIME_CODE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPicStruct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_TIME_CODE),
            "::",
            stringify!(displayPicStruct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockTimestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_TIME_CODE),
            "::",
            stringify!(clockTimestamp)
        )
    );
}
pub type NV_ENC_TIME_CODE = _NV_ENC_TIME_CODE;
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS\n H264 Video Usability Info parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    #[doc = "< [in]: If set to 1 , it specifies that the overscanInfo is present"]
    pub overscanInfoPresentFlag: u32,
    #[doc = "< [in]: Specifies the overscan info(as defined in Annex E of the ITU-T Specification)."]
    pub overscanInfo: u32,
    #[doc = "< [in]: If set to 1, it specifies  that the videoFormat, videoFullRangeFlag and colourDescriptionPresentFlag are present."]
    pub videoSignalTypePresentFlag: u32,
    #[doc = "< [in]: Specifies the source video format(as defined in Annex E of the ITU-T Specification)."]
    pub videoFormat: NV_ENC_VUI_VIDEO_FORMAT,
    #[doc = "< [in]: Specifies the output range of the luma and chroma samples(as defined in Annex E of the ITU-T Specification)."]
    pub videoFullRangeFlag: u32,
    #[doc = "< [in]: If set to 1, it specifies that the colourPrimaries, transferCharacteristics and colourMatrix are present."]
    pub colourDescriptionPresentFlag: u32,
    #[doc = "< [in]: Specifies color primaries for converting to RGB(as defined in Annex E of the ITU-T Specification)"]
    pub colourPrimaries: NV_ENC_VUI_COLOR_PRIMARIES,
    #[doc = "< [in]: Specifies the opto-electronic transfer characteristics to use (as defined in Annex E of the ITU-T Specification)"]
    pub transferCharacteristics: NV_ENC_VUI_TRANSFER_CHARACTERISTIC,
    #[doc = "< [in]: Specifies the matrix coefficients used in deriving the luma and chroma from the RGB primaries (as defined in Annex E of the ITU-T Specification)."]
    pub colourMatrix: NV_ENC_VUI_MATRIX_COEFFS,
    #[doc = "< [in]: If set to 1 , it specifies that the chromaSampleLocationTop and chromaSampleLocationBot are present."]
    pub chromaSampleLocationFlag: u32,
    #[doc = "< [in]: Specifies the chroma sample location for top field(as defined in Annex E of the ITU-T Specification)"]
    pub chromaSampleLocationTop: u32,
    #[doc = "< [in]: Specifies the chroma sample location for bottom field(as defined in Annex E of the ITU-T Specification)"]
    pub chromaSampleLocationBot: u32,
    #[doc = "< [in]: If set to 1, it specifies the bitstream restriction parameters are present in the bitstream."]
    pub bitstreamRestrictionFlag: u32,
    #[doc = "< [in]: If set to 1, it specifies that the timingInfo is present and the 'numUnitInTicks' and 'timeScale' fields are specified by the application. */\n/**< [in]: If not set, the timingInfo may still be present with timing related fields calculated internally basedon the frame rate specified by the application."]
    pub timingInfoPresentFlag: u32,
    #[doc = "< [in]: Specifies the number of time units of the clock(as defined in Annex E of the ITU-T Specification)."]
    pub numUnitInTicks: u32,
    #[doc = "< [in]: Specifies the frquency of the clock(as defined in Annex E of the ITU-T Specification)."]
    pub timeScale: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 12usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_VUI_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CONFIG_H264_VUI_PARAMETERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        112usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overscanInfoPresentFlag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfoPresentFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overscanInfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).videoSignalTypePresentFlag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoSignalTypePresentFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).videoFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).videoFullRangeFlag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFullRangeFlag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).colourDescriptionPresentFlag) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourDescriptionPresentFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colourPrimaries) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourPrimaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transferCharacteristics) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(transferCharacteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colourMatrix) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourMatrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaSampleLocationFlag) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaSampleLocationTop) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationTop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaSampleLocationBot) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationBot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitstreamRestrictionFlag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(bitstreamRestrictionFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timingInfoPresentFlag) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(timingInfoPresentFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numUnitInTicks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(numUnitInTicks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeScale) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(timeScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS\n H264 Video Usability Info parameters"]
pub type NV_ENC_CONFIG_H264_VUI_PARAMETERS = _NV_ENC_CONFIG_H264_VUI_PARAMETERS;
#[doc = " \\struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS\n H264 Video Usability Info parameters"]
pub type NV_ENC_CONFIG_HEVC_VUI_PARAMETERS = NV_ENC_CONFIG_H264_VUI_PARAMETERS;
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE\n External motion vector hint counts per block type.\n H264 and AV1 support multiple hint while HEVC supports one hint for each valid candidate."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Reserved for future use."]
    pub reserved1: [u32; 3usize],
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE() {
    const UNINIT: ::std::mem::MaybeUninit<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE),
            "::",
            stringify!(reserved1)
        )
    );
}
impl _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    #[inline]
    pub fn numCandsPerBlk16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerSb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerSb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numCandsPerBlk16x16: u32,
        numCandsPerBlk16x8: u32,
        numCandsPerBlk8x16: u32,
        numCandsPerBlk8x8: u32,
        numCandsPerSb: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let numCandsPerBlk16x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x16) };
            numCandsPerBlk16x16 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let numCandsPerBlk16x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk16x8) };
            numCandsPerBlk16x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numCandsPerBlk8x16: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x16) };
            numCandsPerBlk8x16 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCandsPerBlk8x8: u32 = unsafe { ::std::mem::transmute(numCandsPerBlk8x8) };
            numCandsPerBlk8x8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let numCandsPerSb: u32 = unsafe { ::std::mem::transmute(numCandsPerSb) };
            numCandsPerSb as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE\n External motion vector hint counts per block type.\n H264 and AV1 support multiple hint while HEVC supports one hint for each valid candidate."]
pub type NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE = _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE;
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT\n External Motion Vector hint structure for H264 and HEVC."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _NVENC_EXTERNAL_ME_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Size of: ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
}
impl _NVENC_EXTERNAL_ME_HINT {
    #[inline]
    pub fn mvx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn mvy(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn refidx(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn partType(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_partType(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lastofPart(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastofPart(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lastOfMB(&self) -> i32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastOfMB(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mvx: i32,
        mvy: i32,
        refidx: i32,
        dir: i32,
        partType: i32,
        lastofPart: i32,
        lastOfMB: i32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let mvx: u32 = unsafe { ::std::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mvy: u32 = unsafe { ::std::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let refidx: u32 = unsafe { ::std::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dir: u32 = unsafe { ::std::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let partType: u32 = unsafe { ::std::mem::transmute(partType) };
            partType as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lastofPart: u32 = unsafe { ::std::mem::transmute(lastofPart) };
            lastofPart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lastOfMB: u32 = unsafe { ::std::mem::transmute(lastOfMB) };
            lastOfMB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_HINT\n External Motion Vector hint structure for H264 and HEVC."]
pub type NVENC_EXTERNAL_ME_HINT = _NVENC_EXTERNAL_ME_HINT;
#[doc = " \\struct _NVENC_EXTERNAL_ME_SB_HINT\n External Motion Vector SB hint structure for AV1"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct _NVENC_EXTERNAL_ME_SB_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_SB_HINT() {
    assert_eq!(
        ::std::mem::size_of::<_NVENC_EXTERNAL_ME_SB_HINT>(),
        6usize,
        concat!("Size of: ", stringify!(_NVENC_EXTERNAL_ME_SB_HINT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NVENC_EXTERNAL_ME_SB_HINT>(),
        2usize,
        concat!("Alignment of ", stringify!(_NVENC_EXTERNAL_ME_SB_HINT))
    );
}
impl _NVENC_EXTERNAL_ME_SB_HINT {
    #[inline]
    pub fn refidx(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn direction(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bi(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_bi(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn partition_type(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_partition_type(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn x8(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_x8(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn last_of_cu(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_last_of_cu(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_of_sb(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_last_of_sb(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mvx(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn cu_size(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cu_size(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mvy(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn y8(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_y8(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> i16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        refidx: i16,
        direction: i16,
        bi: i16,
        partition_type: i16,
        x8: i16,
        last_of_cu: i16,
        last_of_sb: i16,
        reserved0: i16,
        mvx: i16,
        cu_size: i16,
        mvy: i16,
        y8: i16,
        reserved1: i16,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let refidx: u16 = unsafe { ::std::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let direction: u16 = unsafe { ::std::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bi: u16 = unsafe { ::std::mem::transmute(bi) };
            bi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let partition_type: u16 = unsafe { ::std::mem::transmute(partition_type) };
            partition_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let x8: u16 = unsafe { ::std::mem::transmute(x8) };
            x8 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let last_of_cu: u16 = unsafe { ::std::mem::transmute(last_of_cu) };
            last_of_cu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let last_of_sb: u16 = unsafe { ::std::mem::transmute(last_of_sb) };
            last_of_sb as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved0: u16 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 14u8, {
            let mvx: u16 = unsafe { ::std::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cu_size: u16 = unsafe { ::std::mem::transmute(cu_size) };
            cu_size as u64
        });
        __bindgen_bitfield_unit.set(32usize, 12u8, {
            let mvy: u16 = unsafe { ::std::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(44usize, 3u8, {
            let y8: u16 = unsafe { ::std::mem::transmute(y8) };
            y8 as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let reserved1: u16 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NVENC_EXTERNAL_ME_SB_HINT\n External Motion Vector SB hint structure for AV1"]
pub type NVENC_EXTERNAL_ME_SB_HINT = _NVENC_EXTERNAL_ME_SB_HINT;
#[doc = " \\struct _NV_ENC_CONFIG_H264\n H264 encoder configuration parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CONFIG_H264 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Specifies the encoding level. Client is recommended to set this to NV_ENC_LEVEL_AUTOSELECT in order to enable the NvEncodeAPI interface to select the correct level."]
    pub level: u32,
    #[doc = "< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Set to 1 to enable 4:4:4 separate colour planes"]
    pub separateColourPlaneFlag: u32,
    #[doc = "< [in]: Specifies the deblocking filter mode. Permissible value range: [0,2]. This flag corresponds\nto the flag disable_deblocking_filter_idc specified in section 7.4.3 of H.264 specification,\nwhich specifies whether the operation of the deblocking filter shall be disabled across some\nblock edges of the slice and specifies for which edges the filtering is disabled. See section\n7.4.3 of H.264 specification for more details."]
    pub disableDeblockingFilterIDC: u32,
    #[doc = "< [in]: Specifies number of temporal layers to be used for hierarchical coding / temporal SVC. Valid value range is [1,::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS]"]
    pub numTemporalLayers: u32,
    #[doc = "< [in]: Specifies the SPS id of the sequence header"]
    pub spsId: u32,
    #[doc = "< [in]: Specifies the PPS id of the picture header"]
    pub ppsId: u32,
    #[doc = "< [in]: Specifies the AdaptiveTransform Mode. Check support for AdaptiveTransform mode using ::NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM caps."]
    pub adaptiveTransformMode: NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,
    #[doc = "< [in]: Specified the FMO Mode. Check support for FMO using ::NV_ENC_CAPS_SUPPORT_FMO caps."]
    pub fmoMode: NV_ENC_H264_FMO_MODE,
    #[doc = "< [in]: Specifies the BDirect mode. Check support for BDirect mode using ::NV_ENC_CAPS_SUPPORT_BDIRECT_MODE caps."]
    pub bdirectMode: NV_ENC_H264_BDIRECT_MODE,
    #[doc = "< [in]: Specifies the entropy coding mode. Check support for CABAC mode using ::NV_ENC_CAPS_SUPPORT_CABAC caps."]
    pub entropyCodingMode: NV_ENC_H264_ENTROPY_CODING_MODE,
    #[doc = "< [in]: Specifies the stereo frame packing mode which is to be signaled in frame packing arrangement SEI"]
    pub stereoMode: NV_ENC_STEREO_PACKING_MODE,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set.\nWill be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the DPB size used for encoding. Setting it to 0 will let driver use the default DPB size.\nThe low latency application which wants to invalidate reference frame as an error resilience tool\nis recommended to use a large DPB size so that the encoder can keep old reference frames which can be used if recent\nframes are invalidated."]
    pub maxNumRefFrames: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices\nsliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3 numSlices in Picture.\nWhen forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting\nWhen sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:\nsliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)\nsliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)\nsliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)\nsliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the H264 video usability info parameters"]
    pub h264VUIParameters: NV_ENC_CONFIG_H264_VUI_PARAMETERS,
    #[doc = "< [in]: Specifies the number of LTR frames. This parameter has different meaning in two LTR modes.\nIn \"LTR Trust\" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR.\nIn \"LTR Per Picture\" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB."]
    pub ltrNumFrames: u32,
    #[doc = "< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_H264::enableLTR for description of the two modes.\nSet to 1 to use \"LTR Trust\" mode of LTR operation. Clients are discouraged to use \"LTR Trust\" mode as this mode may\nbe deprecated in future releases.\nSet to 0 when using \"LTR Per Picture\" mode of LTR operation."]
    pub ltrTrustMode: u32,
    #[doc = "< [in]: Specifies the chroma format. Should be set to 1 for yuv420 input, 3 for yuv444 input.\nCheck support for YUV444 encoding using ::NV_ENC_CAPS_SUPPORT_YUV444_ENCODE caps."]
    pub chromaFormatIDC: u32,
    #[doc = "< [in]: Specifies the max temporal layer used for temporal SVC / hierarchical coding.\nDefaut value of this field is NV_ENC_CAPS::NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS. Note that the value NV_ENC_CONFIG_H264::maxNumRefFrames should\nbe greater than or equal to (NV_ENC_CONFIG_H264::maxTemporalLayers - 2) * 2, for NV_ENC_CONFIG_H264::maxTemporalLayers >= 2."]
    pub maxTemporalLayers: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame.\nCheck support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame.\nCheck support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 267usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CONFIG_H264> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idrPeriod) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).separateColourPlaneFlag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(separateColourPlaneFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableDeblockingFilterIDC) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(disableDeblockingFilterIDC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numTemporalLayers) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numTemporalLayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spsId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppsId) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adaptiveTransformMode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(adaptiveTransformMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmoMode) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(fmoMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bdirectMode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(bdirectMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entropyCodingMode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(entropyCodingMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stereoMode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(stereoMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intraRefreshPeriod) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intraRefreshCnt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxNumRefFrames) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxNumRefFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceMode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceModeData) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h264VUIParameters) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(h264VUIParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrNumFrames) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrTrustMode) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaFormatIDC) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(chromaFormatIDC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTemporalLayers) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxTemporalLayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useBFramesAsRef) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRefL0) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRefL1) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_H264 {
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableStereoMVC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableStereoMVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalPFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalPFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalBFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalBFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputFramePackingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputFramePackingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableVFR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableVFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qpPrimeYZeroTransformBypassFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qpPrimeYZeroTransformBypassFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSVCPrefixNalu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSVCPrefixNalu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableScalabilityInfoSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableScalabilityInfoSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTimeCode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTimeCode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableTemporalSVC: u32,
        enableStereoMVC: u32,
        hierarchicalPFrames: u32,
        hierarchicalBFrames: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        disableSPSPPS: u32,
        outputFramePackingSEI: u32,
        outputRecoveryPointSEI: u32,
        enableIntraRefresh: u32,
        enableConstrainedEncoding: u32,
        repeatSPSPPS: u32,
        enableVFR: u32,
        enableLTR: u32,
        qpPrimeYZeroTransformBypassFlag: u32,
        useConstrainedIntraPred: u32,
        enableFillerDataInsertion: u32,
        disableSVCPrefixNalu: u32,
        enableScalabilityInfoSEI: u32,
        singleSliceIntraRefresh: u32,
        enableTimeCode: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::std::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableStereoMVC: u32 = unsafe { ::std::mem::transmute(enableStereoMVC) };
            enableStereoMVC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hierarchicalPFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalPFrames) };
            hierarchicalPFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hierarchicalBFrames: u32 = unsafe { ::std::mem::transmute(hierarchicalBFrames) };
            hierarchicalBFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let outputFramePackingSEI: u32 =
                unsafe { ::std::mem::transmute(outputFramePackingSEI) };
            outputFramePackingSEI as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::std::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableVFR: u32 = unsafe { ::std::mem::transmute(enableVFR) };
            enableVFR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let qpPrimeYZeroTransformBypassFlag: u32 =
                unsafe { ::std::mem::transmute(qpPrimeYZeroTransformBypassFlag) };
            qpPrimeYZeroTransformBypassFlag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let disableSVCPrefixNalu: u32 = unsafe { ::std::mem::transmute(disableSVCPrefixNalu) };
            disableSVCPrefixNalu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let enableScalabilityInfoSEI: u32 =
                unsafe { ::std::mem::transmute(enableScalabilityInfoSEI) };
            enableScalabilityInfoSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::std::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let enableTimeCode: u32 = unsafe { ::std::mem::transmute(enableTimeCode) };
            enableTimeCode as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_H264\n H264 encoder configuration parameters"]
pub type NV_ENC_CONFIG_H264 = _NV_ENC_CONFIG_H264;
#[doc = " \\struct _NV_ENC_CONFIG_HEVC\n HEVC encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CONFIG_HEVC {
    #[doc = "< [in]: Specifies the level of the encoded bitstream."]
    pub level: u32,
    #[doc = "< [in]: Specifies the level tier of the encoded bitstream."]
    pub tier: u32,
    #[doc = "< [in]: Specifies the minimum size of luma coding unit."]
    pub minCUSize: NV_ENC_HEVC_CUSIZE,
    #[doc = "< [in]: Specifies the maximum size of luma coding unit. Currently NVENC SDK only supports maxCUSize equal to NV_ENC_HEVC_CUSIZE_32x32."]
    pub maxCUSize: NV_ENC_HEVC_CUSIZE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Specifies the IDR interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG. Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set.\nWill be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the maximum number of references frames in the DPB."]
    pub maxNumRefFramesInDPB: u32,
    #[doc = "< [in]: This parameter has different meaning in two LTR modes.\nIn \"LTR Trust\" mode (ltrTrustMode = 1), encoder will mark the first ltrNumFrames base layer reference frames within each IDR interval as LTR.\nIn \"LTR Per Picture\" mode (ltrTrustMode = 0 and ltrMarkFrame = 1), ltrNumFrames specifies maximum number of LTR frames in DPB.\nThese ltrNumFrames acts as a guidance to the encoder and are not necessarily honored. To achieve a right balance between the encoding\nquality and keeping LTR frames in the DPB queue, the encoder can internally limit the number of LTR frames.\nThe number of LTR frames actually used depends upon the encoding preset being used; Faster encoding presets will use fewer LTR frames."]
    pub ltrNumFrames: u32,
    #[doc = "< [in]: Specifies the VPS id of the video parameter set"]
    pub vpsId: u32,
    #[doc = "< [in]: Specifies the SPS id of the sequence header"]
    pub spsId: u32,
    #[doc = "< [in]: Specifies the PPS id of the picture header"]
    pub ppsId: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices\nsliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture\nWhen sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:\nsliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)\nsliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)\nsliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)\nsliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the max temporal layer used for hierarchical coding."]
    pub maxTemporalLayersMinus1: u32,
    #[doc = "< [in]: Specifies the HEVC video usability info parameters"]
    pub hevcVUIParameters: NV_ENC_CONFIG_HEVC_VUI_PARAMETERS,
    #[doc = "< [in]: Specifies the LTR operating mode. See comments near NV_ENC_CONFIG_HEVC::enableLTR for description of the two modes.\nSet to 1 to use \"LTR Trust\" mode of LTR operation. Clients are discouraged to use \"LTR Trust\" mode as this mode may\nbe deprecated in future releases.\nSet to 0 when using \"LTR Per Picture\" mode of LTR operation."]
    pub ltrTrustMode: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using  ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L0, that can be used by hardware for prediction of a frame.\nCheck support for numRefL0 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of reference frames in reference picture list L1, that can be used by hardware for prediction of a frame.\nCheck support for numRefL1 using ::NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES caps."]
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 214usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CONFIG_HEVC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_HEVC>(),
        1560usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(tier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minCUSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(minCUSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxCUSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxCUSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idrPeriod) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intraRefreshPeriod) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intraRefreshCnt) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxNumRefFramesInDPB) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxNumRefFramesInDPB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrNumFrames) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vpsId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(vpsId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spsId) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppsId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceMode) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceModeData) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTemporalLayersMinus1) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxTemporalLayersMinus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hevcVUIParameters) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(hevcVUIParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrTrustMode) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useBFramesAsRef) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRefL0) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRefL1) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_HEVC {
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableDeblockAcrossSliceBoundary(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableDeblockAcrossSliceBoundary(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAlphaLayerEncoding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAlphaLayerEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputTimeCodeSEI(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputTimeCodeSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        useConstrainedIntraPred: u32,
        disableDeblockAcrossSliceBoundary: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        enableLTR: u32,
        disableSPSPPS: u32,
        repeatSPSPPS: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        pixelBitDepthMinus8: u32,
        enableFillerDataInsertion: u32,
        enableConstrainedEncoding: u32,
        enableAlphaLayerEncoding: u32,
        singleSliceIntraRefresh: u32,
        outputRecoveryPointSEI: u32,
        outputTimeCodeSEI: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::std::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disableDeblockAcrossSliceBoundary: u32 =
                unsafe { ::std::mem::transmute(disableDeblockAcrossSliceBoundary) };
            disableDeblockAcrossSliceBoundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::std::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::std::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputAUD: u32 = unsafe { ::std::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLTR: u32 = unsafe { ::std::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::std::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::std::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::std::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let pixelBitDepthMinus8: u32 = unsafe { ::std::mem::transmute(pixelBitDepthMinus8) };
            pixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::std::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::std::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enableAlphaLayerEncoding: u32 =
                unsafe { ::std::mem::transmute(enableAlphaLayerEncoding) };
            enableAlphaLayerEncoding as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::std::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::std::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let outputTimeCodeSEI: u32 = unsafe { ::std::mem::transmute(outputTimeCodeSEI) };
            outputTimeCodeSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_HEVC\n HEVC encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG_HEVC = _NV_ENC_CONFIG_HEVC;
#[doc = " \\struct _NV_ENC_FILM_GRAIN_PARAMS_AV1\n AV1 Film Grain Parameters structure"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_FILM_GRAIN_PARAMS_AV1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: pointYValue[i]: x coordinate for i-th point of luma piecewise linear scaling function. Values on a scale of 0...255"]
    pub pointYValue: [u8; 14usize],
    #[doc = "< [in]: pointYScaling[i]: i-th point output value of luma piecewise linear scaling function"]
    pub pointYScaling: [u8; 14usize],
    #[doc = "< [in]: pointCbValue[i]: x coordinate for i-th point of cb piecewise linear scaling function. Values on a scale of 0...255"]
    pub pointCbValue: [u8; 10usize],
    #[doc = "< [in]: pointCbScaling[i]: i-th point output value of cb piecewise linear scaling function"]
    pub pointCbScaling: [u8; 10usize],
    #[doc = "< [in]: pointCrValue[i]: x coordinate for i-th point of cr piecewise linear scaling function. Values on a scale of 0...255"]
    pub pointCrValue: [u8; 10usize],
    #[doc = "< [in]: pointCrScaling[i]: i-th point output value of cr piecewise linear scaling function"]
    pub pointCrScaling: [u8; 10usize],
    #[doc = "< [in]: Specifies auto-regressive coefficients used for the Y plane"]
    pub arCoeffsYPlus128: [u8; 24usize],
    #[doc = "< [in]: Specifies auto-regressive coefficients used for the U plane"]
    pub arCoeffsCbPlus128: [u8; 25usize],
    #[doc = "< [in]: Specifies auto-regressive coefficients used for the V plane"]
    pub arCoeffsCrPlus128: [u8; 25usize],
    #[doc = "< [in]: Reserved bytes -  should be set to 0"]
    pub reserved2: [u8; 2usize],
    #[doc = "< [in]: Represents a multiplier for the cb component used in derivation of the input index to the cb component scaling function"]
    pub cbMult: u8,
    #[doc = "< [in]: represents a multiplier for the average luma component used in derivation of the input index to the cb component scaling function."]
    pub cbLumaMult: u8,
    #[doc = "< [in]: Represents an offset used in derivation of the input index to the cb component scaling function"]
    pub cbOffset: u16,
    #[doc = "< [in]: Represents a multiplier for the cr component used in derivation of the input index to the cr component scaling function"]
    pub crMult: u8,
    #[doc = "< [in]: represents a multiplier for the average luma component used in derivation of the input index to the cr component scaling function."]
    pub crLumaMult: u8,
    #[doc = "< [in]: Represents an offset used in derivation of the input index to the cr component scaling function"]
    pub crOffset: u16,
}
#[test]
fn bindgen_test_layout__NV_ENC_FILM_GRAIN_PARAMS_AV1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_FILM_GRAIN_PARAMS_AV1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_FILM_GRAIN_PARAMS_AV1>(),
        156usize,
        concat!("Size of: ", stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_FILM_GRAIN_PARAMS_AV1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointYValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointYValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointYScaling) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointYScaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointCbValue) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointCbValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointCbScaling) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointCbScaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointCrValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointCrValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointCrScaling) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointCrScaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arCoeffsYPlus128) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(arCoeffsYPlus128)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arCoeffsCbPlus128) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(arCoeffsCbPlus128)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arCoeffsCrPlus128) as usize - ptr as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(arCoeffsCrPlus128)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbMult) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(cbMult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbLumaMult) as usize - ptr as usize },
        149usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(cbLumaMult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbOffset) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(cbOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crMult) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(crMult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crLumaMult) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(crLumaMult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crOffset) as usize - ptr as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(crOffset)
        )
    );
}
impl _NV_ENC_FILM_GRAIN_PARAMS_AV1 {
    #[inline]
    pub fn applyGrain(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyGrain(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaScalingFromLuma(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chromaScalingFromLuma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlapFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlapFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clipToRestrictedRange(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clipToRestrictedRange(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn grainScalingMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grainScalingMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn arCoeffLag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arCoeffLag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn numYPoints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numYPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCbPoints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCbPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCrPoints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCrPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn arCoeffShiftMinus6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arCoeffShiftMinus6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn grainScaleShift(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grainScaleShift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyGrain: u32,
        chromaScalingFromLuma: u32,
        overlapFlag: u32,
        clipToRestrictedRange: u32,
        grainScalingMinus8: u32,
        arCoeffLag: u32,
        numYPoints: u32,
        numCbPoints: u32,
        numCrPoints: u32,
        arCoeffShiftMinus6: u32,
        grainScaleShift: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyGrain: u32 = unsafe { ::std::mem::transmute(applyGrain) };
            applyGrain as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chromaScalingFromLuma: u32 =
                unsafe { ::std::mem::transmute(chromaScalingFromLuma) };
            chromaScalingFromLuma as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let overlapFlag: u32 = unsafe { ::std::mem::transmute(overlapFlag) };
            overlapFlag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clipToRestrictedRange: u32 =
                unsafe { ::std::mem::transmute(clipToRestrictedRange) };
            clipToRestrictedRange as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let grainScalingMinus8: u32 = unsafe { ::std::mem::transmute(grainScalingMinus8) };
            grainScalingMinus8 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let arCoeffLag: u32 = unsafe { ::std::mem::transmute(arCoeffLag) };
            arCoeffLag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numYPoints: u32 = unsafe { ::std::mem::transmute(numYPoints) };
            numYPoints as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCbPoints: u32 = unsafe { ::std::mem::transmute(numCbPoints) };
            numCbPoints as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let numCrPoints: u32 = unsafe { ::std::mem::transmute(numCrPoints) };
            numCrPoints as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let arCoeffShiftMinus6: u32 = unsafe { ::std::mem::transmute(arCoeffShiftMinus6) };
            arCoeffShiftMinus6 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let grainScaleShift: u32 = unsafe { ::std::mem::transmute(grainScaleShift) };
            grainScaleShift as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_FILM_GRAIN_PARAMS_AV1\n AV1 Film Grain Parameters structure"]
pub type NV_ENC_FILM_GRAIN_PARAMS_AV1 = _NV_ENC_FILM_GRAIN_PARAMS_AV1;
#[doc = " \\struct _NV_ENC_CONFIG_AV1\n AV1 encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CONFIG_AV1 {
    #[doc = "< [in]: Specifies the level of the encoded bitstream."]
    pub level: u32,
    #[doc = "< [in]: Specifies the level tier of the encoded bitstream."]
    pub tier: u32,
    #[doc = "< [in]: Specifies the minimum size of luma coding block partition."]
    pub minPartSize: NV_ENC_AV1_PART_SIZE,
    #[doc = "< [in]: Specifies the maximum size of luma coding block partition."]
    pub maxPartSize: NV_ENC_AV1_PART_SIZE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Specifies the IDR/Key frame interval. If not set, this is made equal to gopLength in NV_ENC_CONFIG.Low latency application client can set IDR interval to NVENC_INFINITE_GOPLENGTH so that IDR frames are not inserted automatically."]
    pub idrPeriod: u32,
    #[doc = "< [in]: Specifies the interval between successive intra refresh if enableIntrarefresh is set. Requires enableIntraRefresh to be set.\nWill be disabled if NV_ENC_CONFIG::gopLength is not set to NVENC_INFINITE_GOPLENGTH."]
    pub intraRefreshPeriod: u32,
    #[doc = "< [in]: Specifies the length of intra refresh in number of frames for periodic intra refresh. This value should be smaller than intraRefreshPeriod"]
    pub intraRefreshCnt: u32,
    #[doc = "< [in]: Specifies the maximum number of references frames in the DPB."]
    pub maxNumRefFramesInDPB: u32,
    #[doc = "< [in]: This parameter in conjunction with the flag enableCustomTileConfig and the array tileWidths[] specifies the way in which the picture is divided into tile columns.\nWhen enableCustomTileConfig == 0, the picture will be uniformly divided into numTileColumns tile columns. If numTileColumns is not a power of 2,\nit will be rounded down to the next power of 2 value. If numTileColumns == 0, the picture will be coded with the smallest number of vertical tiles as allowed by standard.\nWhen enableCustomTileConfig == 1, numTileColumns must be > 0 and <= NV_MAX_TILE_COLS_AV1 and tileWidths must point to a valid array of numTileColumns entries.\nEntry i specifies the width in 64x64 CTU unit of tile colum i. The sum of all the entries should be equal to the picture width in 64x64 CTU units."]
    pub numTileColumns: u32,
    #[doc = "< [in]: This parameter in conjunction with the flag enableCustomTileConfig and the array tileHeights[] specifies the way in which the picture is divided into tiles rows\nWhen enableCustomTileConfig == 0, the picture will be uniformly divided into numTileRows tile rows. If numTileRows is not a power of 2,\nit will be rounded down to the next power of 2 value. If numTileRows == 0, the picture will be coded with the smallest number of horizontal tiles as allowed by standard.\nWhen enableCustomTileConfig == 1, numTileRows must be > 0 and <= NV_MAX_TILE_ROWS_AV1 and tileHeights must point to a valid array of numTileRows entries.\nEntry i specifies the height in 64x64 CTU unit of tile row i. The sum of all the entries should be equal to the picture hieght in 64x64 CTU units."]
    pub numTileRows: u32,
    #[doc = "< [in]: If enableCustomTileConfig == 1, tileWidths[i] specifies the width of tile column i in 64x64 CTU unit, with 0 <= i <= numTileColumns -1."]
    pub tileWidths: *mut u32,
    #[doc = "< [in]: If enableCustomTileConfig == 1, tileHeights[i] specifies the height of tile row i in 64x64 CTU unit, with 0 <= i <= numTileRows -1."]
    pub tileHeights: *mut u32,
    #[doc = "< [in]: Specifies the max temporal layer used for hierarchical coding."]
    pub maxTemporalLayersMinus1: u32,
    #[doc = "< [in]: as defined in section of ISO/IEC 23091-4/ITU-T H.273"]
    pub colorPrimaries: NV_ENC_VUI_COLOR_PRIMARIES,
    #[doc = "< [in]: as defined in section of ISO/IEC 23091-4/ITU-T H.273"]
    pub transferCharacteristics: NV_ENC_VUI_TRANSFER_CHARACTERISTIC,
    #[doc = "< [in]: as defined in section of ISO/IEC 23091-4/ITU-T H.273"]
    pub matrixCoefficients: NV_ENC_VUI_MATRIX_COEFFS,
    #[doc = "< [in]: 0: studio swing representation - 1: full swing representation"]
    pub colorRange: u32,
    #[doc = "< [in]: 0: unknown\n1: Horizontally collocated with luma (0,0) sample, between two vertical samples\n2: Co-located with luma (0,0) sample"]
    pub chromaSamplePosition: u32,
    #[doc = "< [in]: Specifies the B-Frame as reference mode. Check support for useBFramesAsRef mode using  ::NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE caps."]
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    #[doc = "< [in]: If enableFilmGrainParams == 1, filmGrainParams must point to a valid NV_ENC_FILM_GRAIN_PARAMS_AV1 structure"]
    pub filmGrainParams: *mut NV_ENC_FILM_GRAIN_PARAMS_AV1,
    #[doc = "< [in]: Specifies max number of forward reference frame used for prediction of a frame. It must be in range 1-4 (Last, Last2, last3 and Golden). It's a suggestive value not necessarily be honored always."]
    pub numFwdRefs: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Specifies max number of L1 list reference frame used for prediction of a frame. It must be in range 1-3 (Backward, Altref2, Altref). It's a suggestive value not necessarily be honored always."]
    pub numBwdRefs: NV_ENC_NUM_REF_FRAMES,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 235usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 62usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_AV1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CONFIG_AV1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_AV1>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_AV1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_AV1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_AV1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(tier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minPartSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(minPartSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxPartSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(maxPartSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idrPeriod) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intraRefreshPeriod) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intraRefreshCnt) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxNumRefFramesInDPB) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(maxNumRefFramesInDPB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numTileColumns) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(numTileColumns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numTileRows) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(numTileRows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tileWidths) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(tileWidths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tileHeights) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(tileHeights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTemporalLayersMinus1) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(maxTemporalLayersMinus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorPrimaries) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(colorPrimaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transferCharacteristics) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(transferCharacteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrixCoefficients) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(matrixCoefficients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorRange) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(colorRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromaSamplePosition) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(chromaSamplePosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useBFramesAsRef) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filmGrainParams) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(filmGrainParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numFwdRefs) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(numFwdRefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numBwdRefs) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(numBwdRefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_AV1 {
    #[inline]
    pub fn outputAnnexBFormat(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAnnexBFormat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTimingInfo(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTimingInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableDecoderModelInfo(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableDecoderModelInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFrameIdNumbers(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFrameIdNumbers(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSeqHdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSeqHdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSeqHdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSeqHdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn enableBitstreamPadding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableBitstreamPadding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableCustomTileConfig(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableCustomTileConfig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFilmGrainParams(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFilmGrainParams(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inputPixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_inputPixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        outputAnnexBFormat: u32,
        enableTimingInfo: u32,
        enableDecoderModelInfo: u32,
        enableFrameIdNumbers: u32,
        disableSeqHdr: u32,
        repeatSeqHdr: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        enableBitstreamPadding: u32,
        enableCustomTileConfig: u32,
        enableFilmGrainParams: u32,
        inputPixelBitDepthMinus8: u32,
        pixelBitDepthMinus8: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let outputAnnexBFormat: u32 = unsafe { ::std::mem::transmute(outputAnnexBFormat) };
            outputAnnexBFormat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableTimingInfo: u32 = unsafe { ::std::mem::transmute(enableTimingInfo) };
            enableTimingInfo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableDecoderModelInfo: u32 =
                unsafe { ::std::mem::transmute(enableDecoderModelInfo) };
            enableDecoderModelInfo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableFrameIdNumbers: u32 = unsafe { ::std::mem::transmute(enableFrameIdNumbers) };
            enableFrameIdNumbers as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableSeqHdr: u32 = unsafe { ::std::mem::transmute(disableSeqHdr) };
            disableSeqHdr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let repeatSeqHdr: u32 = unsafe { ::std::mem::transmute(repeatSeqHdr) };
            repeatSeqHdr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::std::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::std::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enableBitstreamPadding: u32 =
                unsafe { ::std::mem::transmute(enableBitstreamPadding) };
            enableBitstreamPadding as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableCustomTileConfig: u32 =
                unsafe { ::std::mem::transmute(enableCustomTileConfig) };
            enableCustomTileConfig as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableFilmGrainParams: u32 =
                unsafe { ::std::mem::transmute(enableFilmGrainParams) };
            enableFilmGrainParams as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let inputPixelBitDepthMinus8: u32 =
                unsafe { ::std::mem::transmute(inputPixelBitDepthMinus8) };
            inputPixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let pixelBitDepthMinus8: u32 = unsafe { ::std::mem::transmute(pixelBitDepthMinus8) };
            pixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_AV1\n AV1 encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG_AV1 = _NV_ENC_CONFIG_AV1;
#[doc = " \\struct _NV_ENC_CONFIG_H264_MEONLY\n H264 encoder configuration parameters for ME only Mode\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CONFIG_H264_MEONLY {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_MEONLY() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CONFIG_H264_MEONLY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_CONFIG_H264_MEONLY {
    #[inline]
    pub fn disablePartition16x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x16(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition16x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIntraSearch(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIntraSearch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bStereoEnable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bStereoEnable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disablePartition16x16: u32,
        disablePartition8x16: u32,
        disablePartition16x8: u32,
        disablePartition8x8: u32,
        disableIntraSearch: u32,
        bStereoEnable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disablePartition16x16: u32 =
                unsafe { ::std::mem::transmute(disablePartition16x16) };
            disablePartition16x16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disablePartition8x16: u32 = unsafe { ::std::mem::transmute(disablePartition8x16) };
            disablePartition8x16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disablePartition16x8: u32 = unsafe { ::std::mem::transmute(disablePartition16x8) };
            disablePartition16x8 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disablePartition8x8: u32 = unsafe { ::std::mem::transmute(disablePartition8x8) };
            disablePartition8x8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableIntraSearch: u32 = unsafe { ::std::mem::transmute(disableIntraSearch) };
            disableIntraSearch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bStereoEnable: u32 = unsafe { ::std::mem::transmute(bStereoEnable) };
            bStereoEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_CONFIG_H264_MEONLY\n H264 encoder configuration parameters for ME only Mode\n"]
pub type NV_ENC_CONFIG_H264_MEONLY = _NV_ENC_CONFIG_H264_MEONLY;
#[doc = " \\struct _NV_ENC_CONFIG_HEVC_MEONLY\n HEVC encoder configuration parameters for ME only Mode\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_CONFIG_HEVC_MEONLY {
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 256usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved1: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC_MEONLY() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CONFIG_HEVC_MEONLY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG_HEVC_MEONLY\n HEVC encoder configuration parameters for ME only Mode\n"]
pub type NV_ENC_CONFIG_HEVC_MEONLY = _NV_ENC_CONFIG_HEVC_MEONLY;
#[doc = " \\struct _NV_ENC_CODEC_CONFIG\n Codec-specific encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_CONFIG {
    #[doc = "< [in]: Specifies the H.264-specific encoder configuration."]
    pub h264Config: NV_ENC_CONFIG_H264,
    #[doc = "< [in]: Specifies the HEVC-specific encoder configuration."]
    pub hevcConfig: NV_ENC_CONFIG_HEVC,
    #[doc = "< [in]: Specifies the AV1-specific encoder configuration."]
    pub av1Config: NV_ENC_CONFIG_AV1,
    #[doc = "< [in]: Specifies the H.264-specific ME only encoder configuration."]
    pub h264MeOnlyConfig: NV_ENC_CONFIG_H264_MEONLY,
    #[doc = "< [in]: Specifies the HEVC-specific ME only encoder configuration."]
    pub hevcMeOnlyConfig: NV_ENC_CONFIG_HEVC_MEONLY,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 320usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_CONFIG() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CODEC_CONFIG> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CODEC_CONFIG>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CODEC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h264Config) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264Config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hevcConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av1Config) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(av1Config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h264MeOnlyConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264MeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hevcMeOnlyConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcMeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " \\struct _NV_ENC_CODEC_CONFIG\n Codec-specific encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CODEC_CONFIG = _NV_ENC_CODEC_CONFIG;
#[doc = " \\struct _NV_ENC_CONFIG\n Encoder configuration parameters to be set during initialization."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_CONFIG_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the codec profile GUID. If client specifies \\p NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID the NvEncodeAPI interface will select the appropriate codec profile."]
    pub profileGUID: GUID,
    #[doc = "< [in]: Specifies the number of pictures in one GOP. Low latency application client can set goplength to NVENC_INFINITE_GOPLENGTH so that keyframes are not inserted automatically."]
    pub gopLength: u32,
    #[doc = "< [in]: Specifies the GOP pattern as follows: \\p frameIntervalP = 0: I, 1: IPP, 2: IBP, 3: IBBP  If goplength is set to NVENC_INFINITE_GOPLENGTH \\p frameIntervalP should be set to 1."]
    pub frameIntervalP: i32,
    #[doc = "< [in]: Set this to 1 to enable monochrome encoding for this session."]
    pub monoChromeEncoding: u32,
    #[doc = "< [in]: Specifies the frame/field mode.\nCheck support for field encoding using ::NV_ENC_CAPS_SUPPORT_FIELD_ENCODING caps.\nUsing a frameFieldMode other than NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME for RGB input is not supported."]
    pub frameFieldMode: NV_ENC_PARAMS_FRAME_FIELD_MODE,
    #[doc = "< [in]: Specifies the desired motion vector prediction precision."]
    pub mvPrecision: NV_ENC_MV_PRECISION,
    #[doc = "< [in]: Specifies the rate control parameters for the current encoding session."]
    pub rcParams: NV_ENC_RC_PARAMS,
    #[doc = "< [in]: Specifies the codec specific config parameters through this union."]
    pub encodeCodecConfig: NV_ENC_CODEC_CONFIG,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 278usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CONFIG> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CONFIG>(),
        3584usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profileGUID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(profileGUID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gopLength) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(gopLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameIntervalP) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameIntervalP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monoChromeEncoding) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(monoChromeEncoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameFieldMode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameFieldMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvPrecision) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(mvPrecision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(rcParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encodeCodecConfig) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(encodeCodecConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_CONFIG\n Encoder configuration parameters to be set during initialization."]
pub type NV_ENC_CONFIG = _NV_ENC_CONFIG;
#[doc = "< Undefined tuningInfo. Invalid value for encoding."]
pub const NV_ENC_TUNING_INFO_NV_ENC_TUNING_INFO_UNDEFINED: NV_ENC_TUNING_INFO = 0;
#[doc = "< Tune presets for latency tolerant encoding."]
pub const NV_ENC_TUNING_INFO_NV_ENC_TUNING_INFO_HIGH_QUALITY: NV_ENC_TUNING_INFO = 1;
#[doc = "< Tune presets for low latency streaming."]
pub const NV_ENC_TUNING_INFO_NV_ENC_TUNING_INFO_LOW_LATENCY: NV_ENC_TUNING_INFO = 2;
#[doc = "< Tune presets for ultra low latency streaming."]
pub const NV_ENC_TUNING_INFO_NV_ENC_TUNING_INFO_ULTRA_LOW_LATENCY: NV_ENC_TUNING_INFO = 3;
#[doc = "< Tune presets for lossless encoding."]
pub const NV_ENC_TUNING_INFO_NV_ENC_TUNING_INFO_LOSSLESS: NV_ENC_TUNING_INFO = 4;
#[doc = "< Count number of tuningInfos. Invalid value."]
pub const NV_ENC_TUNING_INFO_NV_ENC_TUNING_INFO_COUNT: NV_ENC_TUNING_INFO = 5;
#[doc = "  Tuning information of NVENC encoding (TuningInfo is not applicable to H264 and HEVC MEOnly mode)."]
pub type NV_ENC_TUNING_INFO = ::std::os::raw::c_int;
#[doc = " \\struct _NV_ENC_INITIALIZE_PARAMS\n Encode Session Initialization parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_INITIALIZE_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the Encode GUID for which the encoder is being created. ::NvEncInitializeEncoder() API will fail if this is not set, or set to unsupported value."]
    pub encodeGUID: GUID,
    #[doc = "< [in]: Specifies the preset for encoding. If the preset GUID is set then , the preset configuration will be applied before any other parameter."]
    pub presetGUID: GUID,
    #[doc = "< [in]: Specifies the encode width. If not set ::NvEncInitializeEncoder() API will fail."]
    pub encodeWidth: u32,
    #[doc = "< [in]: Specifies the encode height. If not set ::NvEncInitializeEncoder() API will fail."]
    pub encodeHeight: u32,
    #[doc = "< [in]: Specifies the display aspect ratio width (H264/HEVC) or the render width (AV1)."]
    pub darWidth: u32,
    #[doc = "< [in]: Specifies the display aspect ratio height (H264/HEVC) or the render height (AV1)."]
    pub darHeight: u32,
    #[doc = "< [in]: Specifies the numerator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen )."]
    pub frameRateNum: u32,
    #[doc = "< [in]: Specifies the denominator for frame rate used for encoding in frames per second ( Frame rate = frameRateNum / frameRateDen )."]
    pub frameRateDen: u32,
    #[doc = "< [in]: Set this to 1 to enable asynchronous mode and is expected to use events to get picture completion notification."]
    pub enableEncodeAsync: u32,
    #[doc = "< [in]: Set this to 1 to enable the Picture Type Decision is be taken by the NvEncodeAPI interface."]
    pub enablePTD: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Reserved private data buffer size and must be set to 0"]
    pub privDataSize: u32,
    #[doc = "< [in]: Reserved private data buffer and must be set to NULL"]
    pub privData: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies the advanced codec specific structure. If client has sent a valid codec config structure, it will override parameters set by the NV_ENC_INITIALIZE_PARAMS::presetGUID parameter. If set to NULL the NvEncodeAPI interface will use the NV_ENC_INITIALIZE_PARAMS::presetGUID to set the codec specific parameters.\nClient can also optionally query the NvEncodeAPI interface to get codec specific parameters for a presetGUID using ::NvEncGetEncodePresetConfig() API. It can then modify (if required) some of the codec config parameters and send down a custom config structure as part of ::_NV_ENC_INITIALIZE_PARAMS.\nEven in this case client is recommended to pass the same preset guid it has used in ::NvEncGetEncodePresetConfig() API to query the config structure; as NV_ENC_INITIALIZE_PARAMS::presetGUID. This will not override the custom config structure but will be used to determine other Encoder HW specific parameters not exposed in the API."]
    pub encodeConfig: *mut NV_ENC_CONFIG,
    #[doc = "< [in]: Maximum encode width to be used for current Encode session.\nClient should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encoder will not allow dynamic resolution change."]
    pub maxEncodeWidth: u32,
    #[doc = "< [in]: Maximum encode height to be allowed for current Encode session.\nClient should allocate output buffers according to this dimension for dynamic resolution change. If set to 0, Encode will not allow dynamic resolution change."]
    pub maxEncodeHeight: u32,
    #[doc = "< [in]: If Client wants to pass external motion vectors in NV_ENC_PIC_PARAMS::meExternalHints buffer it must specify the maximum number of hint candidates per block per direction for the encode session.\nThe NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[0] is for L0 predictors and NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[1] is for L1 predictors.\nThis client must also set NV_ENC_INITIALIZE_PARAMS::enableExternalMEHints to 1."]
    pub maxMEHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Tuning Info of NVENC encoding(TuningInfo is not applicable to H264 and HEVC meonly mode)."]
    pub tuningInfo: NV_ENC_TUNING_INFO,
    #[doc = "< [in]: Input buffer format. Used only when DX12 interface type is used"]
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 287usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_INITIALIZE_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_INITIALIZE_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        1808usize,
        concat!("Size of: ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encodeGUID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeGUID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presetGUID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(presetGUID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encodeWidth) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encodeHeight) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).darWidth) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).darHeight) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameRateNum) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameRateDen) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateDen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableEncodeAsync) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enableEncodeAsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enablePTD) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enablePTD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privDataSize) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privDataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).privData) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encodeConfig) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxEncodeWidth) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxEncodeHeight) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxMEHintCountsPerBlock) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxMEHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tuningInfo) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(tuningInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferFormat) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_INITIALIZE_PARAMS {
    #[inline]
    pub fn reportSliceOffsets(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reportSliceOffsets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableSubFrameWrite(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableSubFrameWrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableExternalMEHints(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExternalMEHints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMEOnlyMode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMEOnlyMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableWeightedPrediction(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableWeightedPrediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableOutputInVidmem(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputInVidmem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reportSliceOffsets: u32,
        enableSubFrameWrite: u32,
        enableExternalMEHints: u32,
        enableMEOnlyMode: u32,
        enableWeightedPrediction: u32,
        enableOutputInVidmem: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reportSliceOffsets: u32 = unsafe { ::std::mem::transmute(reportSliceOffsets) };
            reportSliceOffsets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableSubFrameWrite: u32 = unsafe { ::std::mem::transmute(enableSubFrameWrite) };
            enableSubFrameWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableExternalMEHints: u32 =
                unsafe { ::std::mem::transmute(enableExternalMEHints) };
            enableExternalMEHints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableMEOnlyMode: u32 = unsafe { ::std::mem::transmute(enableMEOnlyMode) };
            enableMEOnlyMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enableWeightedPrediction: u32 =
                unsafe { ::std::mem::transmute(enableWeightedPrediction) };
            enableWeightedPrediction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableOutputInVidmem: u32 = unsafe { ::std::mem::transmute(enableOutputInVidmem) };
            enableOutputInVidmem as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_INITIALIZE_PARAMS\n Encode Session Initialization parameters."]
pub type NV_ENC_INITIALIZE_PARAMS = _NV_ENC_INITIALIZE_PARAMS;
#[doc = " \\struct _NV_ENC_RECONFIGURE_PARAMS\n Encode Session Reconfigured parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_RECONFIGURE_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_RECONFIGURE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Encoder session re-initialization parameters.\nIf reInitEncodeParams.encodeConfig is NULL and\nreInitEncodeParams.presetGUID is the same as the preset\nGUID specified on the call to NvEncInitializeEncoder(),\nEncodeAPI will continue to use the existing encode\nconfiguration.\nIf reInitEncodeParams.encodeConfig is NULL and\nreInitEncodeParams.presetGUID is different from the preset\nGUID specified on the call to NvEncInitializeEncoder(),\nEncodeAPI will try to use the default configuration for\nthe preset specified by reInitEncodeParams.presetGUID.\nIn this case, reconfiguration may fail if the new\nconfiguration is incompatible with the existing\nconfiguration (e.g. the new configuration results in\na change in the GOP structure)."]
    pub reInitEncodeParams: NV_ENC_INITIALIZE_PARAMS,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_RECONFIGURE_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_RECONFIGURE_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        1824usize,
        concat!("Size of: ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reInitEncodeParams) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(reInitEncodeParams)
        )
    );
}
impl _NV_ENC_RECONFIGURE_PARAMS {
    #[inline]
    pub fn resetEncoder(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resetEncoder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceIDR(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceIDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resetEncoder: u32,
        forceIDR: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resetEncoder: u32 = unsafe { ::std::mem::transmute(resetEncoder) };
            resetEncoder as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceIDR: u32 = unsafe { ::std::mem::transmute(forceIDR) };
            forceIDR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_RECONFIGURE_PARAMS\n Encode Session Reconfigured parameters."]
pub type NV_ENC_RECONFIGURE_PARAMS = _NV_ENC_RECONFIGURE_PARAMS;
#[doc = " \\struct _NV_ENC_PRESET_CONFIG\n Encoder preset config"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PRESET_CONFIG {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_PRESET_CONFIG_VER."]
    pub version: u32,
    #[doc = "< [out]: preset config returned by the Nvidia Video Encoder interface."]
    pub presetCfg: NV_ENC_CONFIG,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 255usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PRESET_CONFIG() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_PRESET_CONFIG> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PRESET_CONFIG>(),
        5128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PRESET_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).presetCfg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(presetCfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        3592usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        4616usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_PRESET_CONFIG\n Encoder preset config"]
pub type NV_ENC_PRESET_CONFIG = _NV_ENC_PRESET_CONFIG;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_MVC\n MVC-specific parameters to be sent on a per-frame basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_MVC {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_MVC_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the view ID associated with the current input view."]
    pub viewID: u32,
    #[doc = "< [in]: Specifies the temporal ID associated with the current input view."]
    pub temporalID: u32,
    #[doc = "< [in]: Specifies the priority ID associated with the current input view. Reserved and ignored by the NvEncodeAPI interface."]
    pub priorityID: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 12usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 8usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_MVC() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_MVC> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(temporalID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priorityID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(priorityID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_MVC\n MVC-specific parameters to be sent on a per-frame basis."]
pub type NV_ENC_PIC_PARAMS_MVC = _NV_ENC_PIC_PARAMS_MVC;
#[doc = " \\union _NV_ENC_PIC_PARAMS_H264_EXT\n H264 extension  picture parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_PIC_PARAMS_H264_EXT {
    #[doc = "< [in]: Specifies the MVC picture parameters."]
    pub mvcPicParams: NV_ENC_PIC_PARAMS_MVC,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 32usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264_EXT() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_H264_EXT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvcPicParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(mvcPicParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " \\union _NV_ENC_PIC_PARAMS_H264_EXT\n H264 extension  picture parameters"]
pub type NV_ENC_PIC_PARAMS_H264_EXT = _NV_ENC_PIC_PARAMS_H264_EXT;
#[doc = " \\struct _NV_ENC_SEI_PAYLOAD\n  User SEI message"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_SEI_PAYLOAD {
    #[doc = "< [in] SEI payload size in bytes. SEI payload must be byte aligned, as described in Annex D"]
    pub payloadSize: u32,
    #[doc = "< [in] SEI payload types and syntax can be found in Annex D of the H.264 Specification."]
    pub payloadType: u32,
    #[doc = "< [in] pointer to user data"]
    pub payload: *mut u8,
}
#[test]
fn bindgen_test_layout__NV_ENC_SEI_PAYLOAD() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_SEI_PAYLOAD> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_SEI_PAYLOAD>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_SEI_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payloadSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payloadType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " \\struct _NV_ENC_SEI_PAYLOAD\n  User SEI message"]
pub type NV_ENC_SEI_PAYLOAD = _NV_ENC_SEI_PAYLOAD;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_H264\n H264 specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_H264 {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved3: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the colour plane ID associated with the current input."]
    pub colourPlaneId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt.\nWhen outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message\nforceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Deprecated."]
    pub sliceTypeData: *mut u8,
    #[doc = "< [in]: Deprecated."]
    pub sliceTypeArrayCnt: u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  seiPayloadArray array."]
    pub seiPayloadArrayCnt: u32,
    #[doc = "< [in]: Array of SEI payloads which will be inserted for this frame."]
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices\nsliceMode = 0 MB based slices, sliceMode = 1 Byte based slices, sliceMode = 2 MB row based slices, sliceMode = 3, numSlices in Picture\nWhen forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting\nWhen sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:\nsliceMode = 0, sliceModeData specifies # of MBs in each slice (except last slice)\nsliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)\nsliceMode = 2, sliceModeData specifies # of MB rows in each slice (except last slice)\nsliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the long term referenceframe index to use for marking this frame as LTR."]
    pub ltrMarkFrameIdx: u32,
    #[doc = "< [in]: Specifies the associated bitmap of LTR frame indices to use when encoding this frame."]
    pub ltrUseFrameBitmap: u32,
    #[doc = "< [in]: Not supported. Reserved for future use and must be set to 0."]
    pub ltrUsageMode: u32,
    #[doc = "< [in]: Specifies the number of slices to be forced to Intra in the current picture.\nThis option along with forceIntraSliceIdx[] array needs to be used with sliceMode = 3 only"]
    pub forceIntraSliceCount: u32,
    #[doc = "< [in]: Slice indices to be forced to intra in the current picture. Each slice index should be <= num_slices_in_picture -1. Index starts from 0 for first slice.\nThe number of entries in this array should be equal to forceIntraSliceCount"]
    pub forceIntraSliceIdx: *mut u32,
    #[doc = "< [in]: Specifies the H264 extension config parameters using this config."]
    pub h264ExtPicParams: NV_ENC_PIC_PARAMS_H264_EXT,
    #[doc = "< [in]: Specifies the clock timestamp sets used in picture timing SEI. Applicable only when NV_ENC_CONFIG_H264::enableTimeCode is set to 1."]
    pub timeCode: NV_ENC_TIME_CODE,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: [u32; 203usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_H264> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_H264>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPOCSyntax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refPicFlag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colourPlaneId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(colourPlaneId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).forceIntraRefreshWithFrameCnt) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceTypeData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceTypeArrayCnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seiPayloadArrayCnt) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seiPayloadArray) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceMode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceModeData) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrMarkFrameIdx) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrUseFrameBitmap) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrUsageMode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forceIntraSliceCount) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forceIntraSliceIdx) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h264ExtPicParams) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(h264ExtPicParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeCode) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(timeCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_PIC_PARAMS_H264 {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_H264\n H264 specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_H264 = _NV_ENC_PIC_PARAMS_H264;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_HEVC\n HEVC specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_HEVC {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the temporal id of the picture"]
    pub temporalId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt.\nWhen outputRecoveryPointSEI is set this is value is used for recovery_frame_cnt in recovery point SEI message\nforceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Array which specifies the slice type used to force intra slice for a particular slice. Currently supported only for NV_ENC_CONFIG_H264::sliceMode == 3.\nClient should allocate array of size sliceModeData where sliceModeData is specified in field of ::_NV_ENC_CONFIG_H264\nArray element with index n corresponds to nth slice. To force a particular slice to intra client should set corresponding array element to NV_ENC_SLICE_TYPE_I\nall other array elements should be set to NV_ENC_SLICE_TYPE_DEFAULT"]
    pub sliceTypeData: *mut u8,
    #[doc = "< [in]: Client should set this to the number of elements allocated in sliceTypeData array. If sliceTypeData is NULL then this should be set to 0"]
    pub sliceTypeArrayCnt: u32,
    #[doc = "< [in]: This parameter in conjunction with sliceModeData specifies the way in which the picture is divided into slices\nsliceMode = 0 CTU based slices, sliceMode = 1 Byte based slices, sliceMode = 2 CTU row based slices, sliceMode = 3, numSlices in Picture\nWhen forceIntraRefreshWithFrameCnt is set it will have priority over sliceMode setting\nWhen sliceMode == 0 and sliceModeData == 0 whole picture will be coded with one slice"]
    pub sliceMode: u32,
    #[doc = "< [in]: Specifies the parameter needed for sliceMode. For:\nsliceMode = 0, sliceModeData specifies # of CTUs in each slice (except last slice)\nsliceMode = 1, sliceModeData specifies maximum # of bytes in each slice (except last slice)\nsliceMode = 2, sliceModeData specifies # of CTU rows in each slice (except last slice)\nsliceMode = 3, sliceModeData specifies number of slices in the picture. Driver will divide picture into slices optimally"]
    pub sliceModeData: u32,
    #[doc = "< [in]: Specifies the long term reference frame index to use for marking this frame as LTR."]
    pub ltrMarkFrameIdx: u32,
    #[doc = "< [in]: Specifies the associated bitmap of LTR frame indices to use when encoding this frame."]
    pub ltrUseFrameBitmap: u32,
    #[doc = "< [in]: Not supported. Reserved for future use and must be set to 0."]
    pub ltrUsageMode: u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  seiPayloadArray array."]
    pub seiPayloadArrayCnt: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: u32,
    #[doc = "< [in]: Array of SEI payloads which will be inserted for this frame."]
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: Specifies the clock timestamp sets used in time code SEI. Applicable only when NV_ENC_CONFIG_HEVC::enableTimeCodeSEI is set to 1."]
    pub timeCode: NV_ENC_TIME_CODE,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved2: [u32; 237usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved3: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_HEVC() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_HEVC> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPOCSyntax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refPicFlag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).forceIntraRefreshWithFrameCnt) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceTypeData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceTypeArrayCnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceMode) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceModeData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrMarkFrameIdx) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrUseFrameBitmap) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrUsageMode) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seiPayloadArrayCnt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seiPayloadArray) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeCode) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(timeCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved3)
        )
    );
}
impl _NV_ENC_PIC_PARAMS_HEVC {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::std::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::std::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::std::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::std::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_HEVC\n HEVC specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_HEVC = _NV_ENC_PIC_PARAMS_HEVC;
#[doc = " \\struct _NV_ENC_PIC_PARAMS_AV1\n AV1 specific enc pic params. sent on a per frame basis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_AV1 {
    #[doc = "< [in]: Specifies the display POC syntax This is required to be set if client is handling the picture type decision."]
    pub displayPOCSyntax: u32,
    #[doc = "< [in]: Set to 1 for a reference picture. This is ignored if NV_ENC_INITIALIZE_PARAMS::enablePTD is set to 1."]
    pub refPicFlag: u32,
    #[doc = "< [in]: Specifies the temporal id of the picture"]
    pub temporalId: u32,
    #[doc = "< [in]: Forces an intra refresh with duration equal to intraRefreshFrameCnt.\nforceIntraRefreshWithFrameCnt cannot be used if B frames are used in the GOP structure specified"]
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: This parameter in conjunction with the flag enableCustomTileConfig and the array tileWidths[] specifies the way in which the picture is divided into tile columns.\nWhen enableCustomTileConfig == 0, the picture will be uniformly divided into numTileColumns tile columns. If numTileColumns is not a power of 2,\nit will be rounded down to the next power of 2 value. If numTileColumns == 0, the picture will be coded with the smallest number of vertical tiles as allowed by standard.\nWhen enableCustomTileConfig == 1, numTileColumns must be > 0 and <= NV_MAX_TILE_COLS_AV1 and tileWidths must point to a valid array of numTileColumns entries.\nEntry i specifies the width in 64x64 CTU unit of tile colum i. The sum of all the entries should be equal to the picture width in 64x64 CTU units."]
    pub numTileColumns: u32,
    #[doc = "< [in]: This parameter in conjunction with the flag enableCustomTileConfig and the array tileHeights[] specifies the way in which the picture is divided into tiles rows\nWhen enableCustomTileConfig == 0, the picture will be uniformly divided into numTileRows tile rows. If numTileRows is not a power of 2,\nit will be rounded down to the next power of 2 value. If numTileRows == 0, the picture will be coded with the smallest number of horizontal tiles as allowed by standard.\nWhen enableCustomTileConfig == 1, numTileRows must be > 0 and <= NV_MAX_TILE_ROWS_AV1 and tileHeights must point to a valid array of numTileRows entries.\nEntry i specifies the height in 64x64 CTU unit of tile row i. The sum of all the entries should be equal to the picture hieght in 64x64 CTU units."]
    pub numTileRows: u32,
    #[doc = "< [in]: If enableCustomTileConfig == 1, tileWidths[i] specifies the width of tile column i in 64x64 CTU unit, with 0 <= i <= numTileColumns -1."]
    pub tileWidths: *mut u32,
    #[doc = "< [in]: If enableCustomTileConfig == 1, tileHeights[i] specifies the height of tile row i in 64x64 CTU unit, with 0 <= i <= numTileRows -1."]
    pub tileHeights: *mut u32,
    #[doc = "< [in]: Specifies the number of elements allocated in  obuPayloadArray array."]
    pub obuPayloadArrayCnt: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: u32,
    #[doc = "< [in]: Array of OBU payloads which will be inserted for this frame."]
    pub obuPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    #[doc = "< [in]: If filmGrainParamsUpdate == 1, filmGrainParams must point to a valid NV_ENC_FILM_GRAIN_PARAMS_AV1 structure"]
    pub filmGrainParams: *mut NV_ENC_FILM_GRAIN_PARAMS_AV1,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved2: [u32; 247usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved3: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_AV1() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_AV1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS_AV1>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_AV1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS_AV1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_AV1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayPOCSyntax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refPicFlag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).forceIntraRefreshWithFrameCnt) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numTileColumns) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(numTileColumns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numTileRows) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(numTileRows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tileWidths) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(tileWidths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tileHeights) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(tileHeights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obuPayloadArrayCnt) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(obuPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obuPayloadArray) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(obuPayloadArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filmGrainParams) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(filmGrainParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(reserved3)
        )
    );
}
impl _NV_ENC_PIC_PARAMS_AV1 {
    #[inline]
    pub fn goldenFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_goldenFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn arfFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arfFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn arf2FrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arf2FrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bwdFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bwdFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlayFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlayFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn showExistingFrameFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_showExistingFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errorResilientModeFlag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_errorResilientModeFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tileConfigUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tileConfigUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableCustomTileConfig(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableCustomTileConfig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filmGrainParamsUpdate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filmGrainParamsUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        goldenFrameFlag: u32,
        arfFrameFlag: u32,
        arf2FrameFlag: u32,
        bwdFrameFlag: u32,
        overlayFrameFlag: u32,
        showExistingFrameFlag: u32,
        errorResilientModeFlag: u32,
        tileConfigUpdate: u32,
        enableCustomTileConfig: u32,
        filmGrainParamsUpdate: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let goldenFrameFlag: u32 = unsafe { ::std::mem::transmute(goldenFrameFlag) };
            goldenFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let arfFrameFlag: u32 = unsafe { ::std::mem::transmute(arfFrameFlag) };
            arfFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let arf2FrameFlag: u32 = unsafe { ::std::mem::transmute(arf2FrameFlag) };
            arf2FrameFlag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bwdFrameFlag: u32 = unsafe { ::std::mem::transmute(bwdFrameFlag) };
            bwdFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let overlayFrameFlag: u32 = unsafe { ::std::mem::transmute(overlayFrameFlag) };
            overlayFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let showExistingFrameFlag: u32 =
                unsafe { ::std::mem::transmute(showExistingFrameFlag) };
            showExistingFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let errorResilientModeFlag: u32 =
                unsafe { ::std::mem::transmute(errorResilientModeFlag) };
            errorResilientModeFlag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tileConfigUpdate: u32 = unsafe { ::std::mem::transmute(tileConfigUpdate) };
            tileConfigUpdate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableCustomTileConfig: u32 =
                unsafe { ::std::mem::transmute(enableCustomTileConfig) };
            enableCustomTileConfig as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let filmGrainParamsUpdate: u32 =
                unsafe { ::std::mem::transmute(filmGrainParamsUpdate) };
            filmGrainParamsUpdate as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS_AV1\n AV1 specific enc pic params. sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS_AV1 = _NV_ENC_PIC_PARAMS_AV1;
#[doc = " Codec specific per-picture encoding parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_PIC_PARAMS {
    #[doc = "< [in]: H264 encode picture params."]
    pub h264PicParams: NV_ENC_PIC_PARAMS_H264,
    #[doc = "< [in]: HEVC encode picture params."]
    pub hevcPicParams: NV_ENC_PIC_PARAMS_HEVC,
    #[doc = "< [in]: AV1 encode picture params."]
    pub av1PicParams: NV_ENC_PIC_PARAMS_AV1,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: [u32; 256usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_PIC_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_CODEC_PIC_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h264PicParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(h264PicParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hevcPicParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(hevcPicParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).av1PicParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(av1PicParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Codec specific per-picture encoding parameters."]
pub type NV_ENC_CODEC_PIC_PARAMS = _NV_ENC_CODEC_PIC_PARAMS;
#[doc = " \\struct _NV_ENC_PIC_PARAMS\n Encoding parameters that need to be sent on a per frame basis."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_PIC_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the input frame width"]
    pub inputWidth: u32,
    #[doc = "< [in]: Specifies the input frame height"]
    pub inputHeight: u32,
    #[doc = "< [in]: Specifies the input buffer pitch. If pitch value is not known, set this to inputWidth."]
    pub inputPitch: u32,
    #[doc = "< [in]: Specifies bit-wise OR of encode picture flags. See ::NV_ENC_PIC_FLAGS enum."]
    pub encodePicFlags: u32,
    #[doc = "< [in]: Specifies the frame index associated with the input frame [optional]."]
    pub frameIdx: u32,
    #[doc = "< [in]: Specifies opaque data which is associated with the encoded frame, but not actually encoded in the output bitstream.\nThis opaque data can be used later to uniquely refer to the corresponding encoded frame. For example, it can be used\nfor identifying the frame to be invalidated in the reference picture buffer, if lost at the client."]
    pub inputTimeStamp: u64,
    #[doc = "< [in]: Specifies duration of the input picture"]
    pub inputDuration: u64,
    #[doc = "< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the output buffer pointer.\nIf NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to output buffer. Client should use a pointer obtained from ::NvEncCreateBitstreamBuffer() API.\nIf NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for NV_ENC_ENCODE_OUT_PARAMS struct and encoded bitstream data. Client\nshould use a pointer obtained from ::NvEncMapInputResource() API, when mapping this output buffer and assign it to NV_ENC_PIC_PARAMS::outputBitstream.\nFirst 256 bytes of this buffer should be interpreted as NV_ENC_ENCODE_OUT_PARAMS struct followed by encoded bitstream data. Recommended size for output buffer is sum of size of\nNV_ENC_ENCODE_OUT_PARAMS struct and twice the input frame size for lower resolution eg. CIF and 1.5 times the input frame size for higher resolutions. If encoded bitstream size is\ngreater than the allocated buffer size for encoded bitstream, then the output buffer will have encoded bitstream data equal to buffer size. All CUDA operations on this buffer must use\nthe default stream."]
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Specifies an event to be signaled on completion of encoding of this Frame [only if operating in Asynchronous mode]. Each output buffer should be associated with a distinct event pointer."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies the input buffer format."]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Specifies structure of the input picture."]
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    #[doc = "< [in]: Specifies input picture type. Client required to be set explicitly by the client if the client has not set NV_ENC_INITALIZE_PARAMS::enablePTD to 1 while calling NvInitializeEncoder."]
    pub pictureType: NV_ENC_PIC_TYPE,
    #[doc = "< [in]: Specifies the codec specific per-picture encoding parameters."]
    pub codecPicParams: NV_ENC_CODEC_PIC_PARAMS,
    #[doc = "< [in]: For H264 and Hevc, specifies the number of hint candidates per block per direction for the current frame. meHintCountsPerBlock[0] is for L0 predictors and meHintCountsPerBlock[1] is for L1 predictors.\nThe candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder initialization."]
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: For H264 and Hevc, Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock.\nThe total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8\n+ 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1)"]
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 6usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 2usize],
    #[doc = "< [in]: Specifies the pointer to signed byte array containing value per MB for H264, per CTB for HEVC and per SB for AV1 in raster scan order for the current picture, which will be interpreted depending on NV_ENC_RC_PARAMS::qpMapMode.\nIf NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DELTA, qpDeltaMap specifies QP modifier per MB for H264, per CTB for HEVC and per SB for AV1. This QP modifier will be applied on top of the QP chosen by rate control.\nIf NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_EMPHASIS, qpDeltaMap specifies Emphasis Level Map per MB for H264. This level value along with QP chosen by rate control is used to\ncompute the QP modifier, which in turn is applied on top of QP chosen by rate control.\nIf NV_ENC_RC_PARAMS::qpMapMode is NV_ENC_QP_MAP_DISABLED, value in qpDeltaMap will be ignored."]
    pub qpDeltaMap: *mut i8,
    #[doc = "< [in]: Specifies the size in bytes of qpDeltaMap surface allocated by client and pointed to by NV_ENC_PIC_PARAMS::qpDeltaMap. Surface (array) should be picWidthInMbs * picHeightInMbs for H264, picWidthInCtbs * picHeightInCtbs for HEVC and\npicWidthInSbs * picHeightInSbs for AV1"]
    pub qpDeltaMapSize: u32,
    #[doc = "< [in]: Reserved bitfields and must be set to 0"]
    pub reservedBitFields: u32,
    #[doc = "< [in]: Specifies temporal distance for reference picture (NVENC_EXTERNAL_ME_HINT::refidx = 0) used during external ME with NV_ENC_INITALIZE_PARAMS::enablePTD = 1 . meHintRefPicDist[0] is for L0 hints and meHintRefPicDist[1] is for L1 hints.\nIf not set, will internally infer distance of 1. Ignored for NV_ENC_INITALIZE_PARAMS::enablePTD = 0"]
    pub meHintRefPicDist: [u16; 2usize],
    #[doc = "< [in]: Specifies the input alpha buffer pointer. Client must use a pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource() APIs.\nApplicable only when encoding hevc with alpha layer is enabled."]
    pub alphaBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: For AV1,Specifies the pointer to ME external SB hints for the current frame. The size of ME hint buffer should be equal to meSbHintsCount."]
    pub meExternalSbHints: *mut NVENC_EXTERNAL_ME_SB_HINT,
    #[doc = "< [in]: For AV1, specifies the total number of external ME SB hint candidates for the frame\nNV_ENC_PIC_PARAMS::meSbHintsCount must never exceed the total number of SBs in frame * the max number of candidates per SB provided during encoder initialization.\nThe max number of candidates per SB is maxMeHintCountsPerBlock[0].numCandsPerSb + maxMeHintCountsPerBlock[1].numCandsPerSb"]
    pub meSbHintsCount: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved3: [u32; 285usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved4: [*mut ::std::os::raw::c_void; 58usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_PIC_PARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_PIC_PARAMS>(),
        3360usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputHeight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputPitch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encodePicFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(encodePicFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameIdx) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputTimeStamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputDuration) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputDuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputBitstream) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).completionEvent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferFmt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pictureStruct) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pictureType) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codecPicParams) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(codecPicParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meHintCountsPerBlock) as usize - ptr as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meExternalHints) as usize - ptr as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpDeltaMap) as usize - ptr as usize },
        1712usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qpDeltaMapSize) as usize - ptr as usize },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMapSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedBitFields) as usize - ptr as usize },
        1724usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reservedBitFields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meHintRefPicDist) as usize - ptr as usize },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintRefPicDist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alphaBuffer) as usize - ptr as usize },
        1736usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(alphaBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meExternalSbHints) as usize - ptr as usize },
        1744usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meExternalSbHints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meSbHintsCount) as usize - ptr as usize },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meSbHintsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        1756usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        2896usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved4)
        )
    );
}
#[doc = " \\struct _NV_ENC_PIC_PARAMS\n Encoding parameters that need to be sent on a per frame basis."]
pub type NV_ENC_PIC_PARAMS = _NV_ENC_PIC_PARAMS;
#[doc = " \\struct _NV_ENC_MEONLY_PARAMS\n MEOnly parameters that need to be sent on a per motion estimation basis.\n NV_ENC_MEONLY_PARAMS::meExternalHints is supported for H264 only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_MEONLY_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to NV_ENC_MEONLY_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the input frame width"]
    pub inputWidth: u32,
    #[doc = "< [in]: Specifies the input frame height"]
    pub inputHeight: u32,
    #[doc = "< [in]: Specifies the input buffer pointer. Client must use a pointer obtained from NvEncCreateInputBuffer() or NvEncMapInputResource() APIs."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the reference frame pointer"]
    pub referenceFrame: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the output buffer pointer.\nIf NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 0, specifies the pointer to motion vector data buffer allocated by NvEncCreateMVBuffer.\nClient must lock mvBuffer using ::NvEncLockBitstream() API to get the motion vector data.\nIf NV_ENC_INITIALIZE_PARAMS::enableOutputInVidmem is set to 1, client should allocate buffer in video memory for storing the motion vector data. The size of this buffer must\nbe equal to total number of macroblocks multiplied by size of NV_ENC_H264_MV_DATA struct. Client should use a pointer obtained from ::NvEncMapInputResource() API, when mapping this\noutput buffer and assign it to NV_ENC_MEONLY_PARAMS::mvBuffer. All CUDA operations on this buffer must use the default stream."]
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    #[doc = "< [in]: Specifies the input buffer format."]
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Specifies an event to be signaled on completion of motion estimation\nof this Frame [only if operating in Asynchronous mode].\nEach output buffer should be associated with a distinct event pointer."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Specifies left or right viewID if NV_ENC_CONFIG_H264_MEONLY::bStereoEnable is set.\nviewID can be 0,1 if bStereoEnable is set, 0 otherwise."]
    pub viewID: u32,
    #[doc = "< [in]: Specifies the number of hint candidates per block for the current frame. meHintCountsPerBlock[0] is for L0 predictors.\nThe candidate count in NV_ENC_PIC_PARAMS::meHintCountsPerBlock[lx] must never exceed NV_ENC_INITIALIZE_PARAMS::maxMEHintCountsPerBlock[lx] provided during encoder initialization."]
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    #[doc = "< [in]: Specifies the pointer to ME external hints for the current frame. The size of ME hint buffer should be equal to number of macroblocks * the total number of candidates per macroblock.\nThe total number of candidates per MB per direction = 1*meHintCountsPerBlock[Lx].numCandsPerBlk16x16 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk16x8 + 2*meHintCountsPerBlock[Lx].numCandsPerBlk8x8\n+ 4*meHintCountsPerBlock[Lx].numCandsPerBlk8x8. For frames using bidirectional ME , the total number of candidates for single macroblock is sum of total number of candidates per MB for each direction (L0 and L1)"]
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 243usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 59usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_MEONLY_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_MEONLY_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MEONLY_PARAMS>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MEONLY_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputHeight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).referenceFrame) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(referenceFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mvBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferFmt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).completionEvent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).viewID) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meHintCountsPerBlock) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meExternalHints) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_MEONLY_PARAMS\n MEOnly parameters that need to be sent on a per motion estimation basis.\n NV_ENC_MEONLY_PARAMS::meExternalHints is supported for H264 only."]
pub type NV_ENC_MEONLY_PARAMS = _NV_ENC_MEONLY_PARAMS;
#[doc = " \\struct _NV_ENC_LOCK_BITSTREAM\n Bitstream buffer lock parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_LOCK_BITSTREAM {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_LOCK_BITSTREAM_VER."]
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Pointer to the bitstream buffer being locked."]
    pub outputBitstream: *mut ::std::os::raw::c_void,
    #[doc = "< [in, out]: Array which receives the slice (H264/HEVC) or tile (AV1) offsets. This is not supported if NV_ENC_CONFIG_H264::sliceMode is 1 on Kepler GPUs. Array size must be equal to size of frame in MBs."]
    pub sliceOffsets: *mut u32,
    #[doc = "< [out]: Frame no. for which the bitstream is being retrieved."]
    pub frameIdx: u32,
    #[doc = "< [out]: The NvEncodeAPI interface status for the locked picture."]
    pub hwEncodeStatus: u32,
    #[doc = "< [out]: Number of slices (H264/HEVC) or tiles (AV1) in the encoded picture. Will be reported only if NV_ENC_INITIALIZE_PARAMS::reportSliceOffsets set to 1."]
    pub numSlices: u32,
    #[doc = "< [out]: Actual number of bytes generated and copied to the memory pointed by bitstreamBufferPtr.\nWhen HEVC alpha layer encoding is enabled, this field reports the total encoded size in bytes i.e it is the encoded size of the base plus the alpha layer.\nFor AV1 when enablePTD is set, this field reports the total encoded size in bytes of all the encoded frames packed into the current output surface i.e. show frame plus all preceding no-show frames"]
    pub bitstreamSizeInBytes: u32,
    #[doc = "< [out]: Presentation timestamp associated with the encoded output."]
    pub outputTimeStamp: u64,
    #[doc = "< [out]: Presentation duration associates with the encoded output."]
    pub outputDuration: u64,
    #[doc = "< [out]: Pointer to the generated output bitstream.\nFor MEOnly mode _NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr should be typecast to\nNV_ENC_H264_MV_DATA/NV_ENC_HEVC_MV_DATA pointer respectively for H264/HEVC"]
    pub bitstreamBufferPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Picture type of the encoded picture."]
    pub pictureType: NV_ENC_PIC_TYPE,
    #[doc = "< [out]: Structure of the generated output picture."]
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    #[doc = "< [out]: Average QP of the frame."]
    pub frameAvgQP: u32,
    #[doc = "< [out]: Total SATD cost for whole frame."]
    pub frameSatd: u32,
    #[doc = "< [out]: Frame index associated with this LTR frame."]
    pub ltrFrameIdx: u32,
    #[doc = "< [out]: Bitmap of LTR frames indices which were used for encoding this frame. Value of 0 if no LTR frames were used."]
    pub ltrFrameBitmap: u32,
    #[doc = "< [out]: TemporalId value of the frame when using temporalSVC encoding"]
    pub temporalId: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: [u32; 12usize],
    #[doc = "< [out]: For H264, Number of Intra MBs in the encoded frame. For HEVC, Number of Intra CTBs in the encoded frame. For AV1, Number of Intra SBs in the encoded show frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub intraMBCount: u32,
    #[doc = "< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame. For AV1, Number of Inter SBs in the encoded show frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub interMBCount: u32,
    #[doc = "< [out]: Average Motion Vector in X direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub averageMVX: i32,
    #[doc = "< [out]: Average Motion Vector in y direction for the encoded frame. Supported only if _NV_ENC_LOCK_BITSTREAM::getRCStats set to 1."]
    pub averageMVY: i32,
    #[doc = "< [out]: Number of bytes generated for the alpha layer in the encoded output. Applicable only when HEVC with alpha encoding is enabled."]
    pub alphaLayerSizeInBytes: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 218usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_BITSTREAM() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_LOCK_BITSTREAM> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_LOCK_BITSTREAM>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_LOCK_BITSTREAM>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputBitstream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceOffsets) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameIdx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hwEncodeStatus) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(hwEncodeStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numSlices) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitstreamSizeInBytes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputTimeStamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputDuration) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputDuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitstreamBufferPtr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pictureType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pictureStruct) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameAvgQP) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameSatd) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameSatd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrFrameIdx) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrFrameBitmap) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameBitmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporalId) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intraMBCount) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interMBCount) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).averageMVX) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).averageMVY) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alphaLayerSizeInBytes) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(alphaLayerSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_LOCK_BITSTREAM {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn getRCStats(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_getRCStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        ltrFrame: u32,
        getRCStats: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let getRCStats: u32 = unsafe { ::std::mem::transmute(getRCStats) };
            getRCStats as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_LOCK_BITSTREAM\n Bitstream buffer lock parameters."]
pub type NV_ENC_LOCK_BITSTREAM = _NV_ENC_LOCK_BITSTREAM;
#[doc = " \\struct _NV_ENC_LOCK_INPUT_BUFFER\n Uncompressed Input Buffer lock parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_LOCK_INPUT_BUFFER {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_LOCK_INPUT_BUFFER_VER."]
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]:  Pointer to the input buffer to be locked, client should pass the pointer obtained from ::NvEncCreateInputBuffer() or ::NvEncMapInputResource API."]
    pub inputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [out]: Pointed to the locked input buffer data. Client can only access input buffer using the \\p bufferDataPtr."]
    pub bufferDataPtr: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Pitch of the locked input buffer."]
    pub pitch: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved1: [u32; 251usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_INPUT_BUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_LOCK_INPUT_BUFFER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferDataPtr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(bufferDataPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_LOCK_INPUT_BUFFER {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::std::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_LOCK_INPUT_BUFFER\n Uncompressed Input Buffer lock parameters."]
pub type NV_ENC_LOCK_INPUT_BUFFER = _NV_ENC_LOCK_INPUT_BUFFER;
#[doc = " \\struct _NV_ENC_MAP_INPUT_RESOURCE\n Map an input resource to a Nvidia Encoder Input Buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_MAP_INPUT_RESOURCE {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_MAP_INPUT_RESOURCE_VER."]
    pub version: u32,
    #[doc = "< [in]:  Deprecated. Do not use."]
    pub subResourceIndex: u32,
    #[doc = "< [in]:  Deprecated. Do not use."]
    pub inputResource: *mut ::std::os::raw::c_void,
    #[doc = "< [in]:  The Registered resource handle obtained by calling NvEncRegisterInputResource."]
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    #[doc = "< [out]: Mapped pointer corresponding to the registeredResource. This pointer must be used in NV_ENC_PIC_PARAMS::inputBuffer parameter in ::NvEncEncodePicture() API."]
    pub mappedResource: NV_ENC_INPUT_PTR,
    #[doc = "< [out]: Buffer format of the outputResource. This buffer format must be used in NV_ENC_PIC_PARAMS::bufferFmt if client using the above mapped resource pointer."]
    pub mappedBufferFmt: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]:  Reserved and must be set to 0."]
    pub reserved1: [u32; 251usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 63usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_MAP_INPUT_RESOURCE() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_MAP_INPUT_RESOURCE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subResourceIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputResource) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(inputResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registeredResource) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mappedResource) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mappedBufferFmt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedBufferFmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_MAP_INPUT_RESOURCE\n Map an input resource to a Nvidia Encoder Input Buffer"]
pub type NV_ENC_MAP_INPUT_RESOURCE = _NV_ENC_MAP_INPUT_RESOURCE;
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX\n NV_ENC_REGISTER_RESOURCE::resourceToRegister must be a pointer to a variable of this type,\n when NV_ENC_REGISTER_RESOURCE::resourceType is NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX {
    #[doc = "< [in]: The name of the texture to be used."]
    pub texture: u32,
    #[doc = "< [in]: Accepted values are GL_TEXTURE_RECTANGLE and GL_TEXTURE_2D."]
    pub target: u32,
}
#[test]
fn bindgen_test_layout__NV_ENC_INPUT_RESOURCE_OPENGL_TEX() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).texture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX),
            "::",
            stringify!(target)
        )
    );
}
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX\n NV_ENC_REGISTER_RESOURCE::resourceToRegister must be a pointer to a variable of this type,\n when NV_ENC_REGISTER_RESOURCE::resourceType is NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
pub type NV_ENC_INPUT_RESOURCE_OPENGL_TEX = _NV_ENC_INPUT_RESOURCE_OPENGL_TEX;
#[doc = " \\struct NV_ENC_FENCE_POINT_D3D12\n Fence and fence value for synchronization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_FENCE_POINT_D3D12 {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_FENCE_POINT_D3D12_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: u32,
    #[doc = "< [in]: Pointer to ID3D12Fence. This fence object is used for synchronization."]
    pub pFence: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Fence value to reach or exceed before the GPU operation."]
    pub waitValue: u64,
    #[doc = "< [in]: Fence value to set the fence to, after the GPU operation."]
    pub signalValue: u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 7usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_FENCE_POINT_D3D12() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_FENCE_POINT_D3D12> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_FENCE_POINT_D3D12>(),
        64usize,
        concat!("Size of: ", stringify!(_NV_ENC_FENCE_POINT_D3D12))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_FENCE_POINT_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_FENCE_POINT_D3D12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pFence) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(pFence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).waitValue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(waitValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalValue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(signalValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(reserved1)
        )
    );
}
impl _NV_ENC_FENCE_POINT_D3D12 {
    #[inline]
    pub fn bWait(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSignal(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSignal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitField(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bWait: u32,
        bSignal: u32,
        reservedBitField: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bWait: u32 = unsafe { ::std::mem::transmute(bWait) };
            bWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSignal: u32 = unsafe { ::std::mem::transmute(bSignal) };
            bSignal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reservedBitField: u32 = unsafe { ::std::mem::transmute(reservedBitField) };
            reservedBitField as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct NV_ENC_FENCE_POINT_D3D12\n Fence and fence value for synchronization."]
pub type NV_ENC_FENCE_POINT_D3D12 = _NV_ENC_FENCE_POINT_D3D12;
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_D3D12\n NV_ENC_PIC_PARAMS::inputBuffer and NV_ENC_PIC_PARAMS::alphaBuffer must be a pointer to a struct of this type,\n when D3D12 interface is used"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_INPUT_RESOURCE_D3D12 {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_INPUT_RESOURCE_D3D12_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: u32,
    #[doc = "< [in]: Specifies the input surface pointer. Client must use a pointer obtained from NvEncMapInputResource() in NV_ENC_MAP_INPUT_RESOURCE::mappedResource\nwhen mapping the input surface."]
    pub pInputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the fence and corresponding fence values to do GPU wait and signal."]
    pub inputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 16usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 16usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_INPUT_RESOURCE_D3D12() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_INPUT_RESOURCE_D3D12> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_INPUT_RESOURCE_D3D12>(),
        272usize,
        concat!("Size of: ", stringify!(_NV_ENC_INPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_INPUT_RESOURCE_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_INPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pInputBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(pInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputFencePoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(inputFencePoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_INPUT_RESOURCE_D3D12\n NV_ENC_PIC_PARAMS::inputBuffer and NV_ENC_PIC_PARAMS::alphaBuffer must be a pointer to a struct of this type,\n when D3D12 interface is used"]
pub type NV_ENC_INPUT_RESOURCE_D3D12 = _NV_ENC_INPUT_RESOURCE_D3D12;
#[doc = " \\struct _NV_ENC_OUTPUT_RESOURCE_D3D12\n NV_ENC_PIC_PARAMS::outputBitstream and NV_ENC_LOCK_BITSTREAM::outputBitstream must be a pointer to a struct of this type,\n when D3D12 interface is used"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_OUTPUT_RESOURCE_D3D12_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: u32,
    #[doc = "< [in]: Specifies the output buffer pointer. Client must use a pointer obtained from NvEncMapInputResource() in NV_ENC_MAP_INPUT_RESOURCE::mappedResource\nwhen mapping output bitstream buffer"]
    pub pOutputBuffer: NV_ENC_INPUT_PTR,
    #[doc = "< [in]: Specifies the fence and corresponding fence values to do GPU wait and signal."]
    pub outputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 16usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 16usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_OUTPUT_RESOURCE_D3D12() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_OUTPUT_RESOURCE_D3D12> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_OUTPUT_RESOURCE_D3D12>(),
        272usize,
        concat!("Size of: ", stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_OUTPUT_RESOURCE_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pOutputBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(pOutputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputFencePoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(outputFencePoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_OUTPUT_RESOURCE_D3D12\n NV_ENC_PIC_PARAMS::outputBitstream and NV_ENC_LOCK_BITSTREAM::outputBitstream must be a pointer to a struct of this type,\n when D3D12 interface is used"]
pub type NV_ENC_OUTPUT_RESOURCE_D3D12 = _NV_ENC_OUTPUT_RESOURCE_D3D12;
#[doc = " \\struct _NV_ENC_REGISTER_RESOURCE\n Register a resource for future use with the Nvidia Video Encoder Interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_REGISTER_RESOURCE {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_REGISTER_RESOURCE_VER."]
    pub version: u32,
    #[doc = "< [in]: Specifies the type of resource to be registered.\nSupported values are\n::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX,\n::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR,\n::NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX"]
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
    #[doc = "< [in]: Input frame width."]
    pub width: u32,
    #[doc = "< [in]: Input frame height."]
    pub height: u32,
    #[doc = "< [in]: Input buffer pitch.\nFor ::NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX resources, set this to 0.\nFor ::NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR resources, set this to\nthe pitch as obtained from cuMemAllocPitch(), or to the width in\nbytes (if this resource was created by using cuMemAlloc()). This\nvalue must be a multiple of 4.\nFor ::NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY resources, set this to the\nwidth of the allocation in bytes (i.e.\nCUDA_ARRAY3D_DESCRIPTOR::Width * CUDA_ARRAY3D_DESCRIPTOR::NumChannels).\nFor ::NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX resources, set this to the\ntexture width multiplied by the number of components in the texture\nformat."]
    pub pitch: u32,
    #[doc = "< [in]: Subresource Index of the DirectX resource to be registered. Should be set to 0 for other interfaces."]
    pub subResourceIndex: u32,
    #[doc = "< [in]: Handle to the resource that is being registered."]
    pub resourceToRegister: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Registered resource handle. This should be used in future interactions with the Nvidia Video Encoder Interface."]
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    #[doc = "< [in]: Buffer format of resource to be registered."]
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    #[doc = "< [in]: Usage of resource to be registered."]
    pub bufferUsage: NV_ENC_BUFFER_USAGE,
    #[doc = "< [in]: Specifies the input fence and corresponding fence values to do GPU wait and signal.\nTo be used only when NV_ENC_REGISTER_RESOURCE::resourceToRegister represents D3D12 surface and\nNV_ENC_BUFFER_USAGE::bufferUsage is NV_ENC_INPUT_IMAGE.\nThe fence NV_ENC_FENCE_POINT_D3D12::pFence and NV_ENC_FENCE_POINT_D3D12::waitValue will be used to do GPU wait\nbefore starting GPU operation, if NV_ENC_FENCE_POINT_D3D12::bWait is set.\nThe fence NV_ENC_FENCE_POINT_D3D12::pFence and NV_ENC_FENCE_POINT_D3D12::signalValue will be used to do GPU signal\nwhen GPU operation finishes, if NV_ENC_FENCE_POINT_D3D12::bSignal is set."]
    pub pInputFencePoint: *mut NV_ENC_FENCE_POINT_D3D12,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved1: [u32; 247usize],
    #[doc = "< [in]: Reserved and must be set to NULL."]
    pub reserved2: [*mut ::std::os::raw::c_void; 61usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_REGISTER_RESOURCE() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_REGISTER_RESOURCE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_REGISTER_RESOURCE>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_REGISTER_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subResourceIndex) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceToRegister) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceToRegister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registeredResource) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferFormat) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferUsage) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pInputFencePoint) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pInputFencePoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_REGISTER_RESOURCE\n Register a resource for future use with the Nvidia Video Encoder Interface."]
pub type NV_ENC_REGISTER_RESOURCE = _NV_ENC_REGISTER_RESOURCE;
#[doc = " \\struct _NV_ENC_STAT\n Encode Stats structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_STAT {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_STAT_VER."]
    pub version: u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [out]: Specifies the pointer to output bitstream."]
    pub outputBitStream: NV_ENC_OUTPUT_PTR,
    #[doc = "< [out]: Size of generated bitstream in bytes."]
    pub bitStreamSize: u32,
    #[doc = "< [out]: Picture type of encoded picture. See ::NV_ENC_PIC_TYPE."]
    pub picType: u32,
    #[doc = "< [out]: Offset of last valid bytes of completed bitstream"]
    pub lastValidByteOffset: u32,
    #[doc = "< [out]: Offsets of each slice"]
    pub sliceOffsets: [u32; 16usize],
    #[doc = "< [out]: Picture number"]
    pub picIdx: u32,
    #[doc = "< [out]: Average QP of the frame."]
    pub frameAvgQP: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< [out]: Frame index associated with this LTR frame."]
    pub ltrFrameIdx: u32,
    #[doc = "< [out]: For H264, Number of Intra MBs in the encoded frame. For HEVC, Number of Intra CTBs in the encoded frame."]
    pub intraMBCount: u32,
    #[doc = "< [out]: For H264, Number of Inter MBs in the encoded frame, includes skip MBs. For HEVC, Number of Inter CTBs in the encoded frame."]
    pub interMBCount: u32,
    #[doc = "< [out]: Average Motion Vector in X direction for the encoded frame."]
    pub averageMVX: i32,
    #[doc = "< [out]: Average Motion Vector in y direction for the encoded frame."]
    pub averageMVY: i32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved1: [u32; 226usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_STAT() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_STAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_STAT>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_STAT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputBitStream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(outputBitStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitStreamSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(bitStreamSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastValidByteOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(lastValidByteOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceOffsets) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picIdx) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameAvgQP) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ltrFrameIdx) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intraMBCount) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interMBCount) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).averageMVX) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).averageMVY) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _NV_ENC_STAT {
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ltrFrame: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::std::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::std::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\struct _NV_ENC_STAT\n Encode Stats structure."]
pub type NV_ENC_STAT = _NV_ENC_STAT;
#[doc = " \\struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD\n Sequence and picture paramaters payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    #[doc = "< [in]:  Struct version. Must be set to ::NV_ENC_INITIALIZE_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]:  Specifies the size of the spsppsBuffer provided by the client"]
    pub inBufferSize: u32,
    #[doc = "< [in]:  Specifies the SPS id to be used in sequence header. Default value is 0."]
    pub spsId: u32,
    #[doc = "< [in]:  Specifies the PPS id to be used in picture header. Default value is 0."]
    pub ppsId: u32,
    #[doc = "< [in]:  Specifies bitstream header pointer of size NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize.\nIt is the client's responsibility to manage this memory."]
    pub spsppsBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Size of the sequence and picture header in bytes."]
    pub outSPSPPSPayloadSize: *mut u32,
    #[doc = "< [in]:  Reserved and must be set to 0"]
    pub reserved: [u32; 250usize],
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_SEQUENCE_PARAM_PAYLOAD() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_SEQUENCE_PARAM_PAYLOAD> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inBufferSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(inBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spsId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppsId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spsppsBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsppsBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outSPSPPSPayloadSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(outSPSPPSPayloadSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD\n Sequence and picture paramaters payload."]
pub type NV_ENC_SEQUENCE_PARAM_PAYLOAD = _NV_ENC_SEQUENCE_PARAM_PAYLOAD;
#[doc = " Event registration/unregistration parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_EVENT_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_EVENT_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved: u32,
    #[doc = "< [in]: Handle to event to be registered/unregistered with the NvEncodeAPI interface."]
    pub completionEvent: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 253usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_EVENT_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_EVENT_PARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_EVENT_PARAMS>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_EVENT_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).completionEvent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Event registration/unregistration parameters."]
pub type NV_ENC_EVENT_PARAMS = _NV_ENC_EVENT_PARAMS;
#[doc = " Encoder Session Creation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    #[doc = "< [in]: Struct version. Must be set to ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER."]
    pub version: u32,
    #[doc = "< [in]: Specified the device Type"]
    pub deviceType: NV_ENC_DEVICE_TYPE,
    #[doc = "< [in]: Pointer to client device."]
    pub device: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: Reserved and must be set to 0."]
    pub reserved: *mut ::std::os::raw::c_void,
    #[doc = "< [in]: API version. Should be set to NVENCAPI_VERSION."]
    pub apiVersion: u32,
    #[doc = "< [in]: Reserved and must be set to 0"]
    pub reserved1: [u32; 253usize],
    #[doc = "< [in]: Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 64usize],
}
#[test]
fn bindgen_test_layout__NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        1552usize,
        concat!(
            "Size of: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apiVersion) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(apiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " Encoder Session Creation parameters"]
pub type NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS = _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS;
extern "C" {
    #[doc = " \\brief Opens an encoding session.\n\n Deprecated.\n\n \\return\n ::NV_ENC_ERR_INVALID_CALL\\n\n"]
    pub fn NvEncOpenEncodeSession(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves the number of supported encode GUIDs.\n\n The function returns the number of codec GUIDs supported by the NvEncodeAPI\n interface.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [out] encodeGUIDCount\n   Number of supported encode GUIDs.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodeGUIDCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves an array of supported encoder codec GUIDs.\n\n The function returns an array of codec GUIDs supported by the NvEncodeAPI interface.\n The client must allocate an array where the NvEncodeAPI interface can\n fill the supported GUIDs and pass the pointer in \\p *GUIDs parameter.\n The size of the array can be determined by using ::NvEncGetEncodeGUIDCount() API.\n The Nvidia Encoding interface returns the number of codec GUIDs it has actually\n filled in the GUID array in the \\p GUIDCount parameter.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] guidArraySize\n   Number of GUIDs to retrieved. Should be set to the number retrieved using\n   ::NvEncGetEncodeGUIDCount.\n \\param [out] GUIDs\n   Array of supported Encode GUIDs.\n \\param [out] GUIDCount\n   Number of supported Encode GUIDs.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodeGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves the number of supported profile GUIDs.\n\n The function returns the number of profile GUIDs supported for a given codec.\n The client must first enumerate the codec GUIDs supported by the NvEncodeAPI\n interface. After determining the codec GUID, it can query the NvEncodeAPI\n interface to determine the number of profile GUIDs supported for a particular\n codec GUID.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   The codec GUID for which the profile GUIDs are being enumerated.\n \\param [out] encodeProfileGUIDCount\n   Number of encode profiles supported for the given encodeGUID.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodeProfileGUIDCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves an array of supported encode profile GUIDs.\n\n The function returns an array of supported profile GUIDs for a particular\n codec GUID. The client must allocate an array where the NvEncodeAPI interface\n can populate the profile GUIDs. The client can determine the array size using\n ::NvEncGetEncodeProfileGUIDCount() API. The client must also validiate that the\n NvEncodeAPI interface supports the GUID the client wants to pass as \\p encodeGUID\n parameter.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   The encode GUID whose profile GUIDs are being enumerated.\n \\param [in] guidArraySize\n   Number of GUIDs to be retrieved. Should be set to the number retrieved using\n   ::NvEncGetEncodeProfileGUIDCount.\n \\param [out] profileGUIDs\n   Array of supported Encode Profile GUIDs\n \\param [out] GUIDCount\n   Number of valid encode profile GUIDs in \\p profileGUIDs array.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodeProfileGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieve the number of supported Input formats.\n\n The function returns the number of supported input formats. The client must\n query the NvEncodeAPI interface to determine the supported input formats\n before creating the input surfaces.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   Encode GUID, corresponding to which the number of supported input formats\n   is to be retrieved.\n \\param [out] inputFmtCount\n   Number of input formats supported for specified Encode GUID.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncGetInputFormatCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves an array of supported Input formats\n\n Returns an array of supported input formats  The client must use the input\n format to create input surface using ::NvEncCreateInputBuffer() API.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   Encode GUID, corresponding to which the number of supported input formats\n   is to be retrieved.\n\\param [in] inputFmtArraySize\n   Size input format count array passed in \\p inputFmts.\n\\param [out] inputFmts\n   Array of input formats supported for this Encode GUID.\n\\param [out] inputFmtCount\n   The number of valid input format types returned by the NvEncodeAPI\n   interface in \\p inputFmts array.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetInputFormats(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves the capability value for a specified encoder attribute.\n\n The function returns the capability value for a given encoder attribute. The\n client must validate the encodeGUID using ::NvEncGetEncodeGUIDs() API before\n calling this function. The encoder attribute being queried are enumerated in\n ::NV_ENC_CAPS_PARAM enum.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   Encode GUID, corresponding to which the capability attribute is to be retrieved.\n \\param [in] capsParam\n   Used to specify attribute being queried. Refer ::NV_ENC_CAPS_PARAM for  more\n details.\n \\param [out] capsVal\n   The value corresponding to the capability attribute being queried.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncGetEncodeCaps(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Retrieves the number of supported preset GUIDs.\n\n The function returns the number of preset GUIDs available for a given codec.\n The client must validate the codec GUID using ::NvEncGetEncodeGUIDs() API\n before calling this function.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   Encode GUID, corresponding to which the number of supported presets is to\n   be retrieved.\n \\param [out] encodePresetGUIDCount\n   Receives the number of supported preset GUIDs.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodePresetCount(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Receives an array of supported encoder preset GUIDs.\n\n The function returns an array of encode preset GUIDs available for a given codec.\n The client can directly use one of the preset GUIDs based upon the use case\n or target device. The preset GUID chosen can be directly used in\n NV_ENC_INITIALIZE_PARAMS::presetGUID parameter to ::NvEncEncodePicture() API.\n Alternately client can  also use the preset GUID to retrieve the encoding config\n parameters being used by NvEncodeAPI interface for that given preset, using\n ::NvEncGetEncodePresetConfig() API. It can then modify preset config parameters\n as per its use case and send it to NvEncodeAPI interface as part of\n NV_ENC_INITIALIZE_PARAMS::encodeConfig parameter for NvEncInitializeEncoder()\n API.\n\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   Encode GUID, corresponding to which the list of supported presets is to be\n   retrieved.\n \\param [in] guidArraySize\n   Size of array of preset GUIDs passed in \\p preset GUIDs\n \\param [out] presetGUIDs\n   Array of supported Encode preset GUIDs from the NvEncodeAPI interface\n   to client.\n \\param [out] encodePresetGUIDCount\n   Receives the number of preset GUIDs returned by the NvEncodeAPI\n   interface.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodePresetGUIDs(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Returns a preset config structure supported for given preset GUID.\n\n The function returns a preset config structure for a given preset GUID.\n NvEncGetEncodePresetConfig() API is not applicable to AV1.\n Before using this function the client must enumerate the preset GUIDs available for\n a given codec. The preset config structure can be modified by the client depending\n upon its use case and can be then used to initialize the encoder using\n ::NvEncInitializeEncoder() API. The client can use this function only if it\n wants to modify the NvEncodeAPI preset configuration, otherwise it can\n directly use the preset GUID.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   Encode GUID, corresponding to which the list of supported presets is to be\n   retrieved.\n \\param [in] presetGUID\n   Preset GUID, corresponding to which the Encoding configurations is to be\n   retrieved.\n \\param [out] presetConfig\n   The requested Preset Encoder Attribute set. Refer ::_NV_ENC_CONFIG for\n    more details.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodePresetConfig(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Returns a preset config structure supported for given preset GUID.\n\n The function returns a preset config structure for a given preset GUID and tuning info.\n NvEncGetEncodePresetConfigEx() API is not applicable to H264 and HEVC meonly mode.\n Before using this function the client must enumerate the preset GUIDs available for\n a given codec. The preset config structure can be modified by the client depending\n upon its use case and can be then used to initialize the encoder using\n ::NvEncInitializeEncoder() API. The client can use this function only if it\n wants to modify the NvEncodeAPI preset configuration, otherwise it can\n directly use the preset GUID.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encodeGUID\n   Encode GUID, corresponding to which the list of supported presets is to be\n   retrieved.\n \\param [in] presetGUID\n   Preset GUID, corresponding to which the Encoding configurations is to be\n   retrieved.\n \\param [in] tuningInfo\n   tuning info, corresponding to which the Encoding configurations is to be\n   retrieved.\n \\param [out] presetConfig\n   The requested Preset Encoder Attribute set. Refer ::_NV_ENC_CONFIG for\n    more details.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodePresetConfigEx(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Initialize the encoder.\n\n This API must be used to initialize the encoder. The initialization parameter\n is passed using \\p *createEncodeParams  The client must send the following\n fields of the _NV_ENC_INITIALIZE_PARAMS structure with a valid value.\n - NV_ENC_INITIALIZE_PARAMS::encodeGUID\n - NV_ENC_INITIALIZE_PARAMS::encodeWidth\n - NV_ENC_INITIALIZE_PARAMS::encodeHeight\n\n The client can pass a preset GUID directly to the NvEncodeAPI interface using\n NV_ENC_INITIALIZE_PARAMS::presetGUID field. If the client doesn't pass\n NV_ENC_INITIALIZE_PARAMS::encodeConfig structure, the codec specific parameters\n will be selected based on the preset GUID. The preset GUID must have been\n validated by the client using ::NvEncGetEncodePresetGUIDs() API.\n If the client passes a custom ::_NV_ENC_CONFIG structure through\n NV_ENC_INITIALIZE_PARAMS::encodeConfig , it will override the codec specific parameters\n based on the preset GUID. It is recommended that even if the client passes a custom config,\n it should also send a preset GUID. In this case, the preset GUID passed by the client\n will not override any of the custom config parameters programmed by the client,\n it is only used as a hint by the NvEncodeAPI interface to determine certain encoder parameters\n which are not exposed to the client.\n\n There are two modes of operation for the encoder namely:\n - Asynchronous mode\n - Synchronous mode\n\n The client can select asynchronous or synchronous mode by setting the \\p\n enableEncodeAsync field in ::_NV_ENC_INITIALIZE_PARAMS to 1 or 0 respectively.\n\\par Asynchronous mode of operation:\n The Asynchronous mode can be enabled by setting NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1.\n The client operating in asynchronous mode must allocate completion event object\n for each output buffer and pass the completion event object in the\n ::NvEncEncodePicture() API. The client can create another thread and wait on\n the event object to be signaled by NvEncodeAPI interface on completion of the\n encoding process for the output frame. This should unblock the main thread from\n submitting work to the encoder. When the event is signaled the client can call\n NvEncodeAPI interfaces to copy the bitstream data using ::NvEncLockBitstream()\n API. This is the preferred mode of operation.\n\n NOTE: Asynchronous mode is not supported on Linux.\n\n\\par Synchronous mode of operation:\n The client can select synchronous mode by setting NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0.\n The client working in synchronous mode can work in a single threaded or multi\n threaded mode. The client need not allocate any event objects. The client can\n only lock the bitstream data after NvEncodeAPI interface has returned\n ::NV_ENC_SUCCESS from encode picture. The NvEncodeAPI interface can return\n ::NV_ENC_ERR_NEED_MORE_INPUT error code from ::NvEncEncodePicture() API. The\n client must not lock the output buffer in such case but should send the next\n frame for encoding. The client must keep on calling ::NvEncEncodePicture() API\n until it returns ::NV_ENC_SUCCESS. \\n\n The client must always lock the bitstream data in order in which it has submitted.\n This is true for both asynchronous and synchronous mode.\n\n\\par Picture type decision:\n If the client is taking the picture type decision and it must disable the picture\n type decision module in NvEncodeAPI by setting NV_ENC_INITIALIZE_PARAMS::enablePTD\n to 0. In this case the client is  required to send the picture in encoding\n order to NvEncodeAPI by doing the re-ordering for B frames. \\n\n If the client doesn't want to take the picture type decision it can enable\n picture type decision module in the NvEncodeAPI interface by setting\n NV_ENC_INITIALIZE_PARAMS::enablePTD to 1 and send the input pictures in display\n order.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] createEncodeParams\n   Refer ::_NV_ENC_INITIALIZE_PARAMS for details.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncInitializeEncoder(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Allocates Input buffer.\n\n This function is used to allocate an input buffer. The client must enumerate\n the input buffer format before allocating the input buffer resources. The\n NV_ENC_INPUT_PTR returned by the NvEncodeAPI interface in the\n NV_ENC_CREATE_INPUT_BUFFER::inputBuffer field can be directly used in\n ::NvEncEncodePicture() API. The number of input buffers to be allocated by the\n client must be at least 4 more than the number of B frames being used for encoding.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] createInputBufferParams\n  Pointer to the ::NV_ENC_CREATE_INPUT_BUFFER structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncCreateInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Release an input buffers.\n\n This function is used to free an input buffer. If the client has allocated\n any input buffer using ::NvEncCreateInputBuffer() API, it must free those\n input buffers by calling this function. The client must release the input\n buffers before destroying the encoder using ::NvEncDestroyEncoder() API.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] inputBuffer\n   Pointer to the input buffer to be released.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncDestroyInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Set input and output CUDA stream for specified encoder attribute.\n\n Encoding may involve CUDA pre-processing on the input and post-processing on encoded output.\n This function is used to set input and output CUDA streams to pipeline the CUDA pre-processing\n and post-processing tasks. Clients should call this function before the call to\n NvEncUnlockInputBuffer(). If this function is not called, the default CUDA stream is used for\n input and output processing. After a successful call to this function, the streams specified\n in that call will replace the previously-used streams.\n This API is supported for NVCUVID interface only.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] inputStream\n   Pointer to CUstream which is used to process ::NV_ENC_PIC_PARAMS::inputFrame for encode.\n   In case of ME-only mode, inputStream is used to process ::NV_ENC_MEONLY_PARAMS::inputBuffer and\n   ::NV_ENC_MEONLY_PARAMS::referenceFrame\n \\param [in] outputStream\n  Pointer to CUstream which is used to process ::NV_ENC_PIC_PARAMS::outputBuffer for encode.\n  In case of ME-only mode, outputStream is used to process ::NV_ENC_MEONLY_PARAMS::mvBuffer\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncSetIOCudaStreams(
        encoder: *mut ::std::os::raw::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Allocates an output bitstream buffer\n\n This function is used to allocate an output bitstream buffer and returns a\n NV_ENC_OUTPUT_PTR to bitstream  buffer to the client in the\n NV_ENC_CREATE_BITSTREAM_BUFFER::bitstreamBuffer field.\n The client can only call this function after the encoder session has been\n initialized using ::NvEncInitializeEncoder() API. The minimum number of output\n buffers allocated by the client must be at least 4 more than the number of B\n B frames being used for encoding. The client can only access the output\n bitstream data by locking the \\p bitstreamBuffer using the ::NvEncLockBitstream()\n function.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] createBitstreamBufferParams\n   Pointer ::NV_ENC_CREATE_BITSTREAM_BUFFER for details.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncCreateBitstreamBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Release a bitstream buffer.\n\n This function is used to release the output bitstream buffer allocated using\n the ::NvEncCreateBitstreamBuffer() function. The client must release the output\n bitstreamBuffer using this function before destroying the encoder session.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] bitstreamBuffer\n   Pointer to the bitstream buffer being released.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncDestroyBitstreamBuffer(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Submit an input picture for encoding.\n\n This function is used to submit an input picture buffer for encoding. The\n encoding parameters are passed using \\p *encodePicParams which is a pointer\n to the ::_NV_ENC_PIC_PARAMS structure.\n\n If the client has set NV_ENC_INITIALIZE_PARAMS::enablePTD to 0, then it must\n send a valid value for the following fields.\n - NV_ENC_PIC_PARAMS::pictureType\n - NV_ENC_PIC_PARAMS_H264::displayPOCSyntax (H264 only)\n - NV_ENC_PIC_PARAMS_H264::frameNumSyntax(H264 only)\n - NV_ENC_PIC_PARAMS_H264::refPicFlag(H264 only)\n\n\\par MVC Encoding:\n For MVC encoding the client must call encode picture API for each view separately\n and must pass valid view id in NV_ENC_PIC_PARAMS_MVC::viewID field. Currently\n NvEncodeAPI only support stereo MVC so client must send viewID as 0 for base\n view and view ID as 1 for dependent view.\n\n\\par Asynchronous Encoding\n If the client has enabled asynchronous mode of encoding by setting\n NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 1 in the ::NvEncInitializeEncoder()\n API ,then the client must send a valid NV_ENC_PIC_PARAMS::completionEvent.\n Incase of asynchronous mode of operation, client can queue the ::NvEncEncodePicture()\n API commands from the main thread and then queue output buffers to be processed\n to a secondary worker thread. Before the locking the output buffers in the\n secondary thread , the client must wait on NV_ENC_PIC_PARAMS::completionEvent\n it has queued in ::NvEncEncodePicture() API call. The client must always process\n completion event and the output buffer in the same order in which they have been\n submitted for encoding. The NvEncodeAPI interface is responsible for any\n re-ordering required for B frames and will always ensure that encoded bitstream\n data is written in the same order in which output buffer is submitted.\n The NvEncodeAPI interface may return ::NV_ENC_ERR_NEED_MORE_INPUT error code for\n some ::NvEncEncodePicture() API calls but the client must not treat it as a fatal error.\n The NvEncodeAPI interface might not be able to submit an input picture buffer for encoding\n immediately due to re-ordering for B frames.\n\\code\nThe below example shows how  asynchronous encoding in case of 1 B frames\n------------------------------------------------------------------------\nSuppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..)\nand 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to\nkeep a copy of the input buffers for re-ordering and it allocates following\ninternal buffers (NvI1, NvI2...). These internal buffers are managed by NvEncodeAPI\nand the client is not responsible for the allocating or freeing the memory of\nthe internal buffers.\n\na) The client main thread will queue the following encode frame calls.\nNote the picture type is unknown to the client, the decision is being taken by\nNvEncodeAPI interface. The client should pass ::_NV_ENC_PIC_PARAMS parameter\nconsisting of allocated input buffer, output buffer and output events in successive\n::NvEncEncodePicture() API calls along with other required encode picture params.\nFor example:\n1st EncodePicture parameters - (I1, O1, E1)\n2nd EncodePicture parameters - (I2, O2, E2)\n3rd EncodePicture parameters - (I3, O3, E3)\n\nb) NvEncodeAPI SW will receive the following encode Commands from the client.\nThe left side shows input from client in the form (Input buffer, Output Buffer,\nOutput Event). The right hand side shows a possible picture type decision take by\nthe NvEncodeAPI interface.\n(I1, O1, E1)    ---P1 Frame\n(I2, O2, E2)    ---B2 Frame\n(I3, O3, E3)    ---P3 Frame\n\nc) NvEncodeAPI interface will make a copy of the input buffers to its internal\nbuffers for re-ordering. These copies are done as part of nvEncEncodePicture\nfunction call from the client and NvEncodeAPI interface is responsible for\nsynchronization of copy operation with the actual encoding operation.\nI1 --> NvI1\nI2 --> NvI2\nI3 --> NvI3\n\nd) The NvEncodeAPI encodes I1 as P frame and submits I1 to encoder HW and returns ::NV_ENC_SUCCESS.\nThe NvEncodeAPI tries to encode I2 as B frame and fails with ::NV_ENC_ERR_NEED_MORE_INPUT error code.\nThe error is not fatal and it notifies client that I2 is not submitted to encoder immediately.\nThe NvEncodeAPI encodes I3 as P frame and submits I3 for encoding which will be used as  backward\nreference frame for I2. The NvEncodeAPI then submits I2 for encoding and returns ::NV_ENC_SUCESS.\nBoth the submission are part of the same ::NvEncEncodePicture() function call.\n\ne) After returning from ::NvEncEncodePicture() call , the client must queue the output\nbitstream  processing work to the secondary thread. The output bitstream processing\nfor asynchronous mode consist of first waiting on completion event(E1, E2..)\nand then locking the output bitstream buffer(O1, O2..) for reading the encoded\ndata. The work queued to the secondary thread by the client is in the following order\n(I1, O1, E1)\n(I2, O2, E2)\n(I3, O3, E3)\nNote they are in the same order in which client calls ::NvEncEncodePicture() API\nin \\p step a).\n\nf) NvEncodeAPI interface  will do the re-ordering such that Encoder HW will receive\nthe following encode commands:\n(NvI1, O1, E1)   ---P1 Frame\n(NvI3, O2, E2)   ---P3 Frame\n(NvI2, O3, E3)   ---B2 frame\n\ng) After the encoding operations are completed, the events will be signaled\nby NvEncodeAPI interface in the following order :\n(O1, E1) ---P1 Frame ,output bitstream copied to O1 and event E1 signaled.\n(O2, E2) ---P3 Frame ,output bitstream copied to O2 and event E2 signaled.\n(O3, E3) ---B2 Frame ,output bitstream copied to O3 and event E3 signaled.\n\nh) The client must lock the bitstream data using ::NvEncLockBitstream() API in\nthe order O1,O2,O3  to read the encoded data, after waiting for the events\nto be signaled in the same order i.e E1, E2 and E3.The output processing is\ndone in the secondary thread in the following order:\nWaits on E1, copies encoded bitstream from O1\nWaits on E2, copies encoded bitstream from O2\nWaits on E3, copies encoded bitstream from O3\n\n-Note the client will receive the events signaling and output buffer in the\nsame order in which they have submitted for encoding.\n-Note the LockBitstream will have picture type field which will notify the\noutput picture type to the clients.\n-Note the input, output buffer and the output completion event are free to be\nreused once NvEncodeAPI interfaced has signaled the event and the client has\ncopied the data from the output buffer.\n\n \\endcode\n\n\\par Synchronous Encoding\n The client can enable synchronous mode of encoding by setting\n NV_ENC_INITIALIZE_PARAMS::enableEncodeAsync to 0 in ::NvEncInitializeEncoder() API.\n The NvEncodeAPI interface may return ::NV_ENC_ERR_NEED_MORE_INPUT error code for\n some ::NvEncEncodePicture() API calls when NV_ENC_INITIALIZE_PARAMS::enablePTD\n is set to 1, but the client must not treat it as a fatal error. The NvEncodeAPI\n interface might not be able to submit an input picture buffer for encoding\n immediately due to re-ordering for B frames. The NvEncodeAPI interface cannot\n submit the input picture which is decided to be encoded as B frame as it waits\n for backward reference from  temporally subsequent frames. This input picture\n is buffered internally and waits for more input picture to arrive. The client\n must not call ::NvEncLockBitstream() API on the output buffers whose\n ::NvEncEncodePicture() API returns ::NV_ENC_ERR_NEED_MORE_INPUT. The client must\n wait for the NvEncodeAPI interface to return ::NV_ENC_SUCCESS before locking the\n output bitstreams to read the encoded bitstream data. The following example\n explains the scenario with synchronous encoding with 2 B frames.\n\\code\nThe below example shows how  synchronous encoding works in case of 1 B frames\n-----------------------------------------------------------------------------\nSuppose the client allocated 4 input buffers(I1,I2..), 4 output buffers(O1,O2..)\nand 4 completion events(E1, E2, ...). The NvEncodeAPI interface will need to\nkeep a copy of the input buffers for re-ordering and it allocates following\ninternal buffers (NvI1, NvI2...). These internal buffers are managed by NvEncodeAPI\nand the client is not responsible for the allocating or freeing the memory of\nthe internal buffers.\n\nThe client calls ::NvEncEncodePicture() API with input buffer I1 and output buffer O1.\nThe NvEncodeAPI decides to encode I1 as P frame and submits it to encoder\nHW and returns ::NV_ENC_SUCCESS.\nThe client can now read the encoded data by locking the output O1 by calling\nNvEncLockBitstream API.\n\nThe client calls ::NvEncEncodePicture() API with input buffer I2 and output buffer O2.\nThe NvEncodeAPI decides to encode I2 as B frame and buffers I2 by copying it\nto internal buffer and returns ::NV_ENC_ERR_NEED_MORE_INPUT.\nThe error is not fatal and it notifies client that it cannot read the encoded\ndata by locking the output O2 by calling ::NvEncLockBitstream() API without submitting\nmore work to the NvEncodeAPI interface.\n\nThe client calls ::NvEncEncodePicture() with input buffer I3 and output buffer O3.\nThe NvEncodeAPI decides to encode I3 as P frame and it first submits I3 for\nencoding which will be used as backward reference frame for I2.\nThe NvEncodeAPI then submits I2 for encoding and returns ::NV_ENC_SUCESS. Both\nthe submission are part of the same ::NvEncEncodePicture() function call.\nThe client can now read the encoded data for both the frames by locking the output\nO2 followed by  O3 ,by calling ::NvEncLockBitstream() API.\n\nThe client must always lock the output in the same order in which it has submitted\nto receive the encoded bitstream in correct encoding order.\n\n \\endcode\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] encodePicParams\n   Pointer to the ::_NV_ENC_PIC_PARAMS structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_ENCODER_BUSY \\n\n ::NV_ENC_ERR_NEED_MORE_INPUT \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncEncodePicture(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Lock output bitstream buffer\n\n This function is used to lock the bitstream buffer to read the encoded data.\n The client can only access the encoded data by calling this function.\n The pointer to client accessible encoded data is returned in the\n NV_ENC_LOCK_BITSTREAM::bitstreamBufferPtr field. The size of the encoded data\n in the output buffer is returned in the NV_ENC_LOCK_BITSTREAM::bitstreamSizeInBytes\n The NvEncodeAPI interface also returns the output picture type and picture structure\n of the encoded frame in NV_ENC_LOCK_BITSTREAM::pictureType and\n NV_ENC_LOCK_BITSTREAM::pictureStruct fields respectively. If the client has\n set NV_ENC_LOCK_BITSTREAM::doNotWait to 1, the function might return\n ::NV_ENC_ERR_LOCK_BUSY if client is operating in synchronous mode. This is not\n a fatal failure if NV_ENC_LOCK_BITSTREAM::doNotWait is set to 1. In the above case the client can\n retry the function after few milliseconds.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] lockBitstreamBufferParams\n   Pointer to the ::_NV_ENC_LOCK_BITSTREAM structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_LOCK_BUSY \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncLockBitstream(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Unlock the output bitstream buffer\n\n This function is used to unlock the output bitstream buffer after the client\n has read the encoded data from output buffer. The client must call this function\n to unlock the output buffer which it has previously locked using ::NvEncLockBitstream()\n function. Using a locked bitstream buffer in ::NvEncEncodePicture() API will cause\n the function to fail.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] bitstreamBuffer\n   bitstream buffer pointer being unlocked\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncUnlockBitstream(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Locks an input buffer\n\n This function is used to lock the input buffer to load the uncompressed YUV\n pixel data into input buffer memory. The client must pass the NV_ENC_INPUT_PTR\n it had previously allocated using ::NvEncCreateInputBuffer()in the\n NV_ENC_LOCK_INPUT_BUFFER::inputBuffer field.\n The NvEncodeAPI interface returns pointer to client accessible input buffer\n memory in NV_ENC_LOCK_INPUT_BUFFER::bufferDataPtr field.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] lockInputBufferParams\n   Pointer to the ::_NV_ENC_LOCK_INPUT_BUFFER structure\n\n \\return\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_LOCK_BUSY \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncLockInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Unlocks the input buffer\n\n This function is used to unlock the input buffer memory previously locked for\n uploading YUV pixel data. The input buffer must be unlocked before being used\n again for encoding, otherwise NvEncodeAPI will fail the ::NvEncEncodePicture()\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] inputBuffer\n   Pointer to the input buffer that is being unlocked.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n\n"]
    pub fn NvEncUnlockInputBuffer(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get encoding statistics.\n\n This function is used to retrieve the encoding statistics.\n This API is not supported when encode device type is CUDA.\n Note that this API will be removed in future Video Codec SDK release.\n Clients should use NvEncLockBitstream() API to retrieve the encoding statistics.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] encodeStats\n   Pointer to the ::_NV_ENC_STAT structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetEncodeStats(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get encoded sequence and picture header.\n\n This function can be used to retrieve the sequence and picture header out of\n band. The client must call this function only after the encoder has been\n initialized using ::NvEncInitializeEncoder() function. The client must\n allocate the memory where the NvEncodeAPI interface can copy the bitstream\n header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer.\n The size of buffer is passed in the field  NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize.\n The NvEncodeAPI interface will copy the bitstream header payload and returns\n the actual size of the bitstream header in the field\n NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize.\n The client must call  ::NvEncGetSequenceParams() function from the same thread which is\n being used to call ::NvEncEncodePicture() function.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] sequenceParamPayload\n   Pointer to the ::_NV_ENC_SEQUENCE_PARAM_PAYLOAD structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetSequenceParams(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get sequence and picture header.\n\n This function can be used to retrieve the sequence and picture header out of band, even when\n encoder has not been initialized using ::NvEncInitializeEncoder() function.\n The client must allocate the memory where the NvEncodeAPI interface can copy the bitstream\n header and pass the pointer to the memory in NV_ENC_SEQUENCE_PARAM_PAYLOAD::spsppsBuffer.\n The size of buffer is passed in the field  NV_ENC_SEQUENCE_PARAM_PAYLOAD::inBufferSize.\n If encoder has not been initialized using ::NvEncInitializeEncoder() function, client must\n send NV_ENC_INITIALIZE_PARAMS as input. The NV_ENC_INITIALIZE_PARAMS passed must be same as the\n one which will be used for initializing encoder using ::NvEncInitializeEncoder() function later.\n If encoder is already initialized using ::NvEncInitializeEncoder() function, the provided\n NV_ENC_INITIALIZE_PARAMS structure is ignored. The NvEncodeAPI interface will copy the bitstream\n header payload and returns the actual size of the bitstream header in the field\n NV_ENC_SEQUENCE_PARAM_PAYLOAD::outSPSPPSPayloadSize. The client must call  ::NvEncGetSequenceParamsEx()\n function from the same thread which is being used to call ::NvEncEncodePicture() function.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] encInitParams\n   Pointer to the _NV_ENC_INITIALIZE_PARAMS structure.\n \\param [in,out] sequenceParamPayload\n   Pointer to the ::_NV_ENC_SEQUENCE_PARAM_PAYLOAD structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncGetSequenceParamEx(
        encoder: *mut ::std::os::raw::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Register event for notification to encoding completion.\n\n This function is used to register the completion event with NvEncodeAPI\n interface. The event is required when the client has configured the encoder to\n work in asynchronous mode. In this mode the client needs to send a completion\n event with every output buffer. The NvEncodeAPI interface will signal the\n completion of the encoding process using this event. Only after the event is\n signaled the client can get the encoded data using ::NvEncLockBitstream() function.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] eventParams\n   Pointer to the ::_NV_ENC_EVENT_PARAMS structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncRegisterAsyncEvent(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Unregister completion event.\n\n This function is used to unregister completion event which has been previously\n registered using ::NvEncRegisterAsyncEvent() function. The client must unregister\n all events before destroying the encoder using ::NvEncDestroyEncoder() function.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] eventParams\n   Pointer to the ::_NV_ENC_EVENT_PARAMS structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncUnregisterAsyncEvent(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Map an externally created input resource pointer for encoding.\n\n Maps an externally allocated input resource [using and returns a NV_ENC_INPUT_PTR\n which can be used for encoding in the ::NvEncEncodePicture() function. The\n mapped resource is returned in the field NV_ENC_MAP_INPUT_RESOURCE::outputResourcePtr.\n The NvEncodeAPI interface also returns the buffer format of the mapped resource\n in the field NV_ENC_MAP_INPUT_RESOURCE::outbufferFmt.\n This function provides synchronization guarantee that any graphics work submitted\n on the input buffer is completed before the buffer is used for encoding. This is\n also true for compute (i.e. CUDA) work, provided that the previous workload using\n the input resource was submitted to the default stream.\n The client should not access any input buffer while they are mapped by the encoder.\n For D3D12 interface type, this function does not provide synchronization guarantee.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] mapInputResParams\n   Pointer to the ::_NV_ENC_MAP_INPUT_RESOURCE structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED \\n\n ::NV_ENC_ERR_MAP_FAILED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncMapInputResource(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief  UnMaps a NV_ENC_INPUT_PTR  which was mapped for encoding\n\n\n UnMaps an input buffer which was previously mapped using ::NvEncMapInputResource()\n API. The mapping created using ::NvEncMapInputResource() should be invalidated\n using this API before the external resource is destroyed by the client. The client\n must unmap the buffer after ::NvEncLockBitstream() API returns successfully for encode\n work submitted using the mapped input buffer.\n\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] mappedInputBuffer\n   Pointer to the NV_ENC_INPUT_PTR\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED \\n\n ::NV_ENC_ERR_RESOURCE_NOT_MAPPED \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncUnmapInputResource(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Destroy Encoding Session\n\n Destroys the encoder session previously created using ::NvEncOpenEncodeSession()\n function. The client must flush the encoder before freeing any resources. In order\n to flush the encoder the client must pass a NULL encode picture packet and either\n wait for the ::NvEncEncodePicture() function to return in synchronous mode or wait\n for the flush event to be signaled by the encoder in asynchronous mode.\n The client must free all the input and output resources created using the\n NvEncodeAPI interface before destroying the encoder. If the client is operating\n in asynchronous mode, it must also unregister the completion events previously\n registered.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncDestroyEncoder(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Invalidate reference frames\n\n Invalidates reference frame based on the time stamp provided by the client.\n The encoder marks any reference frames or any frames which have been reconstructed\n using the corrupt frame as invalid for motion estimation and uses older reference\n frames for motion estimation. The encoder forces the current frame to be encoded\n as an intra frame if no reference frames are left after invalidation process.\n This is useful for low latency application for error resiliency. The client\n is recommended to set NV_ENC_CONFIG_H264::maxNumRefFrames to a large value so\n that encoder can keep a backup of older reference frames in the DPB and can use them\n for motion estimation when the newer reference frames have been invalidated.\n This API can be called multiple times.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] invalidRefFrameTimeStamp\n   Timestamp of the invalid reference frames which needs to be invalidated.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncInvalidateRefFrames(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Opens an encoding session.\n\n Opens an encoding session and returns a pointer to the encoder interface in\n the \\p **encoder parameter. The client should start encoding process by calling\n this API first.\n The client must pass a pointer to IDirect3DDevice9 device or CUDA context in the \\p *device parameter.\n For the OpenGL interface, \\p device must be NULL. An OpenGL context must be current when\n calling all NvEncodeAPI functions.\n If the creation of encoder session fails, the client must call ::NvEncDestroyEncoder API\n before exiting.\n\n \\param [in] openSessionExParams\n    Pointer to a ::NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS structure.\n \\param [out] encoder\n    Encode Session pointer to the NvEncodeAPI interface.\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_NO_ENCODE_DEVICE \\n\n ::NV_ENC_ERR_UNSUPPORTED_DEVICE \\n\n ::NV_ENC_ERR_INVALID_DEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncOpenEncodeSessionEx(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Registers a resource with the Nvidia Video Encoder Interface.\n\n Registers a resource with the Nvidia Video Encoder Interface for book keeping.\n The client is expected to pass the registered resource handle as well, while calling ::NvEncMapInputResource API.\n\n \\param [in] encoder\n   Pointer to the NVEncodeAPI interface.\n\n \\param [in] registerResParams\n   Pointer to a ::_NV_ENC_REGISTER_RESOURCE structure\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_RESOURCE_REGISTER_FAILED \\n\n ::NV_ENC_ERR_GENERIC \\n\n ::NV_ENC_ERR_UNIMPLEMENTED \\n\n"]
    pub fn NvEncRegisterResource(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Unregisters a resource previously registered with the Nvidia Video Encoder Interface.\n\n Unregisters a resource previously registered with the Nvidia Video Encoder Interface.\n The client is expected to unregister any resource that it has registered with the\n Nvidia Video Encoder Interface before destroying the resource.\n\n \\param [in] encoder\n   Pointer to the NVEncodeAPI interface.\n\n \\param [in] registeredResource\n   The registered resource pointer that was returned in ::NvEncRegisterResource.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_RESOURCE_NOT_REGISTERED \\n\n ::NV_ENC_ERR_GENERIC \\n\n ::NV_ENC_ERR_UNIMPLEMENTED \\n\n"]
    pub fn NvEncUnregisterResource(
        encoder: *mut ::std::os::raw::c_void,
        registeredResource: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Reconfigure an existing encoding session.\n\n Reconfigure an existing encoding session.\n The client should call this API to change/reconfigure the parameter passed during\n NvEncInitializeEncoder API call.\n Currently Reconfiguration of following are not supported.\n Change in GOP structure.\n Change in sync-Async mode.\n Change in MaxWidth & MaxHeight.\n Change in PTD mode.\n\n Resolution change is possible only if maxEncodeWidth & maxEncodeHeight of NV_ENC_INITIALIZE_PARAMS\n is set while creating encoder session.\n\n \\param [in] encoder\n   Pointer to the NVEncodeAPI interface.\n\n \\param [in] reInitEncodeParams\n    Pointer to a ::NV_ENC_RECONFIGURE_PARAMS structure.\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_NO_ENCODE_DEVICE \\n\n ::NV_ENC_ERR_UNSUPPORTED_DEVICE \\n\n ::NV_ENC_ERR_INVALID_DEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_GENERIC \\n\n"]
    pub fn NvEncReconfigureEncoder(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Allocates output MV buffer for ME only mode.\n\n This function is used to allocate an output MV buffer. The size of the mvBuffer is\n dependent on the frame height and width of the last ::NvEncCreateInputBuffer() call.\n The NV_ENC_OUTPUT_PTR returned by the NvEncodeAPI interface in the\n ::NV_ENC_CREATE_MV_BUFFER::mvBuffer field should be used in\n ::NvEncRunMotionEstimationOnly() API.\n Client must lock ::NV_ENC_CREATE_MV_BUFFER::mvBuffer using ::NvEncLockBitstream() API to get the motion vector data.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in,out] createMVBufferParams\n  Pointer to the ::NV_ENC_CREATE_MV_BUFFER structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncCreateMVBuffer(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Release an output MV buffer for ME only mode.\n\n This function is used to release the output MV buffer allocated using\n the ::NvEncCreateMVBuffer() function. The client must release the output\n mvBuffer using this function before destroying the encoder session.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] mvBuffer\n   Pointer to the mvBuffer being released.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncDestroyMVBuffer(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Submit an input picture and reference frame for motion estimation in ME only mode.\n\n This function is used to submit the input frame and reference frame for motion\n estimation. The ME parameters are passed using *meOnlyParams which is a pointer\n to ::_NV_ENC_MEONLY_PARAMS structure.\n Client must lock ::NV_ENC_CREATE_MV_BUFFER::mvBuffer using ::NvEncLockBitstream() API to get the motion vector data.\n to get motion vector data.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n \\param [in] meOnlyParams\n   Pointer to the ::_NV_ENC_MEONLY_PARAMS structure.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n\n ::NV_ENC_ERR_INVALID_ENCODERDEVICE \\n\n ::NV_ENC_ERR_DEVICE_NOT_EXIST \\n\n ::NV_ENC_ERR_UNSUPPORTED_PARAM \\n\n ::NV_ENC_ERR_OUT_OF_MEMORY \\n\n ::NV_ENC_ERR_INVALID_PARAM \\n\n ::NV_ENC_ERR_INVALID_VERSION \\n\n ::NV_ENC_ERR_NEED_MORE_INPUT \\n\n ::NV_ENC_ERR_ENCODER_NOT_INITIALIZED \\n\n ::NV_ENC_ERR_GENERIC \\n"]
    pub fn NvEncRunMotionEstimationOnly(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get the largest NvEncodeAPI version supported by the driver.\n\n This function can be used by clients to determine if the driver supports\n the NvEncodeAPI header the application was compiled with.\n\n \\param [out] version\n   Pointer to the requested value. The 4 least significant bits in the returned\n   indicate the minor version and the rest of the bits indicate the major\n   version of the largest supported version.\n\n \\return\n ::NV_ENC_SUCCESS \\n\n ::NV_ENC_ERR_INVALID_PTR \\n"]
    pub fn NvEncodeAPIGetMaxSupportedVersion(version: *mut u32) -> NVENCSTATUS;
}
extern "C" {
    #[doc = " \\brief Get the description of the last error reported by the API.\n\n This function returns a null-terminated string that can be used by clients to better understand the reason\n for failure of a previous API call.\n\n \\param [in] encoder\n   Pointer to the NvEncodeAPI interface.\n\n \\return\n   Pointer to buffer containing the details of the last error encountered by the API."]
    pub fn NvEncGetLastErrorString(
        encoder: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " \\cond API PFN"]
pub type PNVENCOPENENCODESESSION = ::std::option::Option<
    unsafe extern "C" fn(
        device: *mut ::std::os::raw::c_void,
        deviceType: u32,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPROFILEGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODECAPS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::std::os::raw::c_int,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCOUNT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETGUIDS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIG = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIGEX = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCINITIALIZEENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYBITSTREAMBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCENCODEPICTURE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKBITSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKINPUTBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODESTATS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERASYNCEVENT = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNMAPINPUTRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYENCODER = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> NVENCSTATUS,
>;
pub type PNVENCINVALIDATEREFFRAMES = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS,
>;
pub type PNVENCOPENENCODESESSIONEX = ::std::option::Option<
    unsafe extern "C" fn(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::std::os::raw::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERRESOURCE = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        registeredRes: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRECONFIGUREENCODER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYMVBUFFER = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRUNMOTIONESTIMATIONONLY = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETLASTERROR = ::std::option::Option<
    unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
>;
pub type PNVENCSETIOCUDASTREAMS = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMEX = ::std::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::std::os::raw::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
#[doc = " \\ingroup ENCODER_STRUCTURE\n NV_ENCODE_API_FUNCTION_LIST"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_ENCODE_API_FUNCTION_LIST {
    #[doc = "< [in]: Client should pass NV_ENCODE_API_FUNCTION_LIST_VER."]
    pub version: u32,
    #[doc = "< [in]: Reserved and should be set to 0."]
    pub reserved: u32,
    #[doc = "< [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer."]
    pub nvEncOpenEncodeSession: PNVENCOPENENCODESESSION,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeGUIDCount() API through this pointer."]
    pub nvEncGetEncodeGUIDCount: PNVENCGETENCODEGUIDCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeProfileGUIDCount() API through this pointer."]
    pub nvEncGetEncodeProfileGUIDCount: PNVENCGETENCODEPRESETCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeProfileGUIDs() API through this pointer."]
    pub nvEncGetEncodeProfileGUIDs: PNVENCGETENCODEPRESETGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeGUIDs() API through this pointer."]
    pub nvEncGetEncodeGUIDs: PNVENCGETENCODEGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetInputFormatCount() API through this pointer."]
    pub nvEncGetInputFormatCount: PNVENCGETINPUTFORMATCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetInputFormats() API through this pointer."]
    pub nvEncGetInputFormats: PNVENCGETINPUTFORMATS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeCaps() API through this pointer."]
    pub nvEncGetEncodeCaps: PNVENCGETENCODECAPS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetCount() API through this pointer."]
    pub nvEncGetEncodePresetCount: PNVENCGETENCODEPRESETCOUNT,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetGUIDs() API through this pointer."]
    pub nvEncGetEncodePresetGUIDs: PNVENCGETENCODEPRESETGUIDS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetConfig() API through this pointer."]
    pub nvEncGetEncodePresetConfig: PNVENCGETENCODEPRESETCONFIG,
    #[doc = "< [out]: Client should access ::NvEncInitializeEncoder() API through this pointer."]
    pub nvEncInitializeEncoder: PNVENCINITIALIZEENCODER,
    #[doc = "< [out]: Client should access ::NvEncCreateInputBuffer() API through this pointer."]
    pub nvEncCreateInputBuffer: PNVENCCREATEINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyInputBuffer() API through this pointer."]
    pub nvEncDestroyInputBuffer: PNVENCDESTROYINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncCreateBitstreamBuffer() API through this pointer."]
    pub nvEncCreateBitstreamBuffer: PNVENCCREATEBITSTREAMBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyBitstreamBuffer() API through this pointer."]
    pub nvEncDestroyBitstreamBuffer: PNVENCDESTROYBITSTREAMBUFFER,
    #[doc = "< [out]: Client should access ::NvEncEncodePicture() API through this pointer."]
    pub nvEncEncodePicture: PNVENCENCODEPICTURE,
    #[doc = "< [out]: Client should access ::NvEncLockBitstream() API through this pointer."]
    pub nvEncLockBitstream: PNVENCLOCKBITSTREAM,
    #[doc = "< [out]: Client should access ::NvEncUnlockBitstream() API through this pointer."]
    pub nvEncUnlockBitstream: PNVENCUNLOCKBITSTREAM,
    #[doc = "< [out]: Client should access ::NvEncLockInputBuffer() API through this pointer."]
    pub nvEncLockInputBuffer: PNVENCLOCKINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncUnlockInputBuffer() API through this pointer."]
    pub nvEncUnlockInputBuffer: PNVENCUNLOCKINPUTBUFFER,
    #[doc = "< [out]: Client should access ::NvEncGetEncodeStats() API through this pointer."]
    pub nvEncGetEncodeStats: PNVENCGETENCODESTATS,
    #[doc = "< [out]: Client should access ::NvEncGetSequenceParams() API through this pointer."]
    pub nvEncGetSequenceParams: PNVENCGETSEQUENCEPARAMS,
    #[doc = "< [out]: Client should access ::NvEncRegisterAsyncEvent() API through this pointer."]
    pub nvEncRegisterAsyncEvent: PNVENCREGISTERASYNCEVENT,
    #[doc = "< [out]: Client should access ::NvEncUnregisterAsyncEvent() API through this pointer."]
    pub nvEncUnregisterAsyncEvent: PNVENCUNREGISTERASYNCEVENT,
    #[doc = "< [out]: Client should access ::NvEncMapInputResource() API through this pointer."]
    pub nvEncMapInputResource: PNVENCMAPINPUTRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncUnmapInputResource() API through this pointer."]
    pub nvEncUnmapInputResource: PNVENCUNMAPINPUTRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncDestroyEncoder() API through this pointer."]
    pub nvEncDestroyEncoder: PNVENCDESTROYENCODER,
    #[doc = "< [out]: Client should access ::NvEncInvalidateRefFrames() API through this pointer."]
    pub nvEncInvalidateRefFrames: PNVENCINVALIDATEREFFRAMES,
    #[doc = "< [out]: Client should access ::NvEncOpenEncodeSession() API through this pointer."]
    pub nvEncOpenEncodeSessionEx: PNVENCOPENENCODESESSIONEX,
    #[doc = "< [out]: Client should access ::NvEncRegisterResource() API through this pointer."]
    pub nvEncRegisterResource: PNVENCREGISTERRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncUnregisterResource() API through this pointer."]
    pub nvEncUnregisterResource: PNVENCUNREGISTERRESOURCE,
    #[doc = "< [out]: Client should access ::NvEncReconfigureEncoder() API through this pointer."]
    pub nvEncReconfigureEncoder: PNVENCRECONFIGUREENCODER,
    pub reserved1: *mut ::std::os::raw::c_void,
    #[doc = "< [out]: Client should access ::NvEncCreateMVBuffer API through this pointer."]
    pub nvEncCreateMVBuffer: PNVENCCREATEMVBUFFER,
    #[doc = "< [out]: Client should access ::NvEncDestroyMVBuffer API through this pointer."]
    pub nvEncDestroyMVBuffer: PNVENCDESTROYMVBUFFER,
    #[doc = "< [out]: Client should access ::NvEncRunMotionEstimationOnly API through this pointer."]
    pub nvEncRunMotionEstimationOnly: PNVENCRUNMOTIONESTIMATIONONLY,
    #[doc = "< [out]: Client should access ::nvEncGetLastErrorString API through this pointer."]
    pub nvEncGetLastErrorString: PNVENCGETLASTERROR,
    #[doc = "< [out]: Client should access ::nvEncSetIOCudaStreams API through this pointer."]
    pub nvEncSetIOCudaStreams: PNVENCSETIOCUDASTREAMS,
    #[doc = "< [out]: Client should access ::NvEncGetEncodePresetConfigEx() API through this pointer."]
    pub nvEncGetEncodePresetConfigEx: PNVENCGETENCODEPRESETCONFIGEX,
    #[doc = "< [out]: Client should access ::NvEncGetSequenceParamEx() API through this pointer."]
    pub nvEncGetSequenceParamEx: PNVENCGETSEQUENCEPARAMEX,
    #[doc = "< [in]:  Reserved and must be set to NULL"]
    pub reserved2: [*mut ::std::os::raw::c_void; 277usize],
}
#[test]
fn bindgen_test_layout__NV_ENCODE_API_FUNCTION_LIST() {
    const UNINIT: ::std::mem::MaybeUninit<_NV_ENCODE_API_FUNCTION_LIST> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        2552usize,
        concat!("Size of: ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncOpenEncodeSession) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSession)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetEncodeGUIDCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDCount)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).nvEncGetEncodeProfileGUIDCount) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetEncodeProfileGUIDs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetEncodeGUIDs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetInputFormatCount) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormatCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetInputFormats) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetEncodeCaps) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeCaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetEncodePresetCount) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetEncodePresetGUIDs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetGUIDs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetEncodePresetConfig) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncInitializeEncoder) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInitializeEncoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncCreateInputBuffer) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncDestroyInputBuffer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncCreateBitstreamBuffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncDestroyBitstreamBuffer) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncEncodePicture) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncEncodePicture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncLockBitstream) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockBitstream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncUnlockBitstream) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockBitstream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncLockInputBuffer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncUnlockInputBuffer) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetEncodeStats) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeStats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetSequenceParams) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncRegisterAsyncEvent) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncUnregisterAsyncEvent) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncMapInputResource) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncMapInputResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncUnmapInputResource) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnmapInputResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncDestroyEncoder) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyEncoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncInvalidateRefFrames) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInvalidateRefFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncOpenEncodeSessionEx) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSessionEx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncRegisterResource) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncUnregisterResource) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncReconfigureEncoder) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncReconfigureEncoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncCreateMVBuffer) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateMVBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncDestroyMVBuffer) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyMVBuffer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).nvEncRunMotionEstimationOnly) as usize - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRunMotionEstimationOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetLastErrorString) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetLastErrorString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncSetIOCudaStreams) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncSetIOCudaStreams)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).nvEncGetEncodePresetConfigEx) as usize - ptr as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfigEx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvEncGetSequenceParamEx) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParamEx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved2)
        )
    );
}
#[doc = " \\ingroup ENCODER_STRUCTURE\n NV_ENCODE_API_FUNCTION_LIST"]
pub type NV_ENCODE_API_FUNCTION_LIST = _NV_ENCODE_API_FUNCTION_LIST;
extern "C" {
    #[doc = " \\ingroup ENCODE_FUNC\n Entry Point to the NvEncodeAPI interface.\n\n Creates an instance of the NvEncodeAPI interface, and populates the\n pFunctionList with function pointers to the API routines implemented by the\n NvEncodeAPI interface.\n\n \\param [out] functionList\n\n \\return\n ::NV_ENC_SUCCESS\n ::NV_ENC_ERR_INVALID_PTR"]
    pub fn NvEncodeAPICreateInstance(functionList: *mut NV_ENCODE_API_FUNCTION_LIST)
        -> NVENCSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
