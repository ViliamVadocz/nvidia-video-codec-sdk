pub const fn NVENCAPI_STRUCT_VERSION(ver: u32) -> u32 {
    super::nvEncodeAPI::NVENCAPI_VERSION | (ver << 16) | (0x7 << 28)
}
pub const NV_ENC_CAPS_PARAM_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_ENCODE_OUT_PARAMS_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_CREATE_INPUT_BUFFER_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_CREATE_BITSTREAM_BUFFER_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_CREATE_MV_BUFFER_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_RC_PARAMS_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_PIC_PARAMS_MVC_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_MEONLY_PARAMS_VER: u32 = NVENCAPI_STRUCT_VERSION(3);
pub const NV_ENC_LOCK_BITSTREAM_VER: u32 = NVENCAPI_STRUCT_VERSION(2);
pub const NV_ENC_LOCK_INPUT_BUFFER_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_MAP_INPUT_RESOURCE_VER: u32 = NVENCAPI_STRUCT_VERSION(4);
pub const NV_ENC_FENCE_POINT_D3D12_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_INPUT_RESOURCE_D3D12_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_OUTPUT_RESOURCE_D3D12_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_REGISTER_RESOURCE_VER: u32 = NVENCAPI_STRUCT_VERSION(4);
pub const NV_ENC_STAT_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_SEQUENCE_PARAM_PAYLOAD_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_EVENT_PARAMS_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS_VER: u32 = NVENCAPI_STRUCT_VERSION(1);
pub const NV_ENCODE_API_FUNCTION_LIST_VER: u32 = NVENCAPI_STRUCT_VERSION(2);
/* automatically generated by rust-bindgen 0.65.1 */

pub type GUID = _GUID;
pub type NVENC_RECT = _NVENC_RECT;
pub type NV_ENC_INPUT_PTR = *mut ::core::ffi::c_void;
pub type NV_ENC_OUTPUT_PTR = *mut ::core::ffi::c_void;
pub type NV_ENC_REGISTERED_PTR = *mut ::core::ffi::c_void;
pub type NV_ENC_CUSTREAM_PTR = *mut ::core::ffi::c_void;
pub type NV_ENC_CAPS_PARAM = _NV_ENC_CAPS_PARAM;
pub type NV_ENC_ENCODE_OUT_PARAMS = _NV_ENC_ENCODE_OUT_PARAMS;
pub type NV_ENC_CREATE_INPUT_BUFFER = _NV_ENC_CREATE_INPUT_BUFFER;
pub type NV_ENC_CREATE_BITSTREAM_BUFFER = _NV_ENC_CREATE_BITSTREAM_BUFFER;
pub type NV_ENC_MVECTOR = _NV_ENC_MVECTOR;
pub type NV_ENC_H264_MV_DATA = _NV_ENC_H264_MV_DATA;
pub type NV_ENC_HEVC_MV_DATA = _NV_ENC_HEVC_MV_DATA;
pub type NV_ENC_CREATE_MV_BUFFER = _NV_ENC_CREATE_MV_BUFFER;
pub type NV_ENC_QP = _NV_ENC_QP;
pub type NV_ENC_RC_PARAMS = _NV_ENC_RC_PARAMS;
pub type NV_ENC_CLOCK_TIMESTAMP_SET = _NV_ENC_CLOCK_TIMESTAMP_SET;
pub type NV_ENC_TIME_CODE = _NV_ENC_TIME_CODE;
pub type NV_ENC_CONFIG_H264_VUI_PARAMETERS = _NV_ENC_CONFIG_H264_VUI_PARAMETERS;
pub type NV_ENC_CONFIG_HEVC_VUI_PARAMETERS = NV_ENC_CONFIG_H264_VUI_PARAMETERS;
pub type NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE = _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE;
pub type NVENC_EXTERNAL_ME_HINT = _NVENC_EXTERNAL_ME_HINT;
pub type NVENC_EXTERNAL_ME_SB_HINT = _NVENC_EXTERNAL_ME_SB_HINT;
pub type NV_ENC_CONFIG_H264 = _NV_ENC_CONFIG_H264;
pub type NV_ENC_CONFIG_HEVC = _NV_ENC_CONFIG_HEVC;
pub type NV_ENC_FILM_GRAIN_PARAMS_AV1 = _NV_ENC_FILM_GRAIN_PARAMS_AV1;
pub type NV_ENC_CONFIG_AV1 = _NV_ENC_CONFIG_AV1;
pub type NV_ENC_CONFIG_H264_MEONLY = _NV_ENC_CONFIG_H264_MEONLY;
pub type NV_ENC_CONFIG_HEVC_MEONLY = _NV_ENC_CONFIG_HEVC_MEONLY;
pub type NV_ENC_CODEC_CONFIG = _NV_ENC_CODEC_CONFIG;
pub type NV_ENC_CONFIG = _NV_ENC_CONFIG;
pub type NV_ENC_INITIALIZE_PARAMS = _NV_ENC_INITIALIZE_PARAMS;
pub type NV_ENC_RECONFIGURE_PARAMS = _NV_ENC_RECONFIGURE_PARAMS;
pub type NV_ENC_PRESET_CONFIG = _NV_ENC_PRESET_CONFIG;
pub type NV_ENC_PIC_PARAMS_MVC = _NV_ENC_PIC_PARAMS_MVC;
pub type NV_ENC_PIC_PARAMS_H264_EXT = _NV_ENC_PIC_PARAMS_H264_EXT;
pub type NV_ENC_SEI_PAYLOAD = _NV_ENC_SEI_PAYLOAD;
pub type NV_ENC_PIC_PARAMS_H264 = _NV_ENC_PIC_PARAMS_H264;
pub type NV_ENC_PIC_PARAMS_HEVC = _NV_ENC_PIC_PARAMS_HEVC;
pub type NV_ENC_PIC_PARAMS_AV1 = _NV_ENC_PIC_PARAMS_AV1;
pub type NV_ENC_CODEC_PIC_PARAMS = _NV_ENC_CODEC_PIC_PARAMS;
pub type NV_ENC_PIC_PARAMS = _NV_ENC_PIC_PARAMS;
pub type NV_ENC_MEONLY_PARAMS = _NV_ENC_MEONLY_PARAMS;
pub type NV_ENC_LOCK_BITSTREAM = _NV_ENC_LOCK_BITSTREAM;
pub type NV_ENC_LOCK_INPUT_BUFFER = _NV_ENC_LOCK_INPUT_BUFFER;
pub type NV_ENC_MAP_INPUT_RESOURCE = _NV_ENC_MAP_INPUT_RESOURCE;
pub type NV_ENC_INPUT_RESOURCE_OPENGL_TEX = _NV_ENC_INPUT_RESOURCE_OPENGL_TEX;
pub type NV_ENC_FENCE_POINT_D3D12 = _NV_ENC_FENCE_POINT_D3D12;
pub type NV_ENC_INPUT_RESOURCE_D3D12 = _NV_ENC_INPUT_RESOURCE_D3D12;
pub type NV_ENC_OUTPUT_RESOURCE_D3D12 = _NV_ENC_OUTPUT_RESOURCE_D3D12;
pub type NV_ENC_REGISTER_RESOURCE = _NV_ENC_REGISTER_RESOURCE;
pub type NV_ENC_STAT = _NV_ENC_STAT;
pub type NV_ENC_SEQUENCE_PARAM_PAYLOAD = _NV_ENC_SEQUENCE_PARAM_PAYLOAD;
pub type NV_ENC_EVENT_PARAMS = _NV_ENC_EVENT_PARAMS;
pub type NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS = _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS;
pub type PNVENCOPENENCODESESSION = ::core::option::Option<
    unsafe extern "C" fn(
        device: *mut ::core::ffi::c_void,
        deviceType: u32,
        encoder: *mut *mut ::core::ffi::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDCOUNT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEGUIDS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATCOUNT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETINPUTFORMATS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODECAPS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::core::ffi::c_int,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCOUNT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETGUIDS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIG = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODEPRESETCONFIGEX = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS,
>;
pub type PNVENCINITIALIZEENCODER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEINPUTBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYINPUTBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEBITSTREAMBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYBITSTREAMBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCENCODEPICTURE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKBITSTREAM = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKBITSTREAM = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCLOCKINPUTBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNLOCKINPUTBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETENCODESTATS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERASYNCEVENT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERASYNCEVENT = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCMAPINPUTRESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNMAPINPUTRESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYENCODER =
    ::core::option::Option<unsafe extern "C" fn(encoder: *mut ::core::ffi::c_void) -> NVENCSTATUS>;
pub type PNVENCINVALIDATEREFFRAMES = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS,
>;
pub type PNVENCOPENENCODESESSIONEX = ::core::option::Option<
    unsafe extern "C" fn(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::core::ffi::c_void,
    ) -> NVENCSTATUS,
>;
pub type PNVENCREGISTERRESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS,
>;
pub type PNVENCUNREGISTERRESOURCE = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        registeredRes: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRECONFIGUREENCODER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCCREATEMVBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS,
>;
pub type PNVENCDESTROYMVBUFFER = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCRUNMOTIONESTIMATIONONLY = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETLASTERROR = ::core::option::Option<
    unsafe extern "C" fn(encoder: *mut ::core::ffi::c_void) -> *const ::core::ffi::c_char,
>;
pub type PNVENCSETIOCUDASTREAMS = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS,
>;
pub type PNVENCGETSEQUENCEPARAMEX = ::core::option::Option<
    unsafe extern "C" fn(
        encoder: *mut ::core::ffi::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS,
>;
pub type NV_ENCODE_API_FUNCTION_LIST = _NV_ENCODE_API_FUNCTION_LIST;
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _GUID {
    pub Data1: u32,
    pub Data2: u16,
    pub Data3: u16,
    pub Data4: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_RECT {
    pub left: u32,
    pub top: u32,
    pub right: u32,
    pub bottom: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CAPS_PARAM {
    pub version: u32,
    pub capsToQuery: NV_ENC_CAPS,
    pub reserved: [u32; 62usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_ENCODE_OUT_PARAMS {
    pub version: u32,
    pub bitstreamSizeInBytes: u32,
    pub reserved: [u32; 62usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_INPUT_BUFFER {
    pub version: u32,
    pub width: u32,
    pub height: u32,
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub reserved: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub pSysMemBuffer: *mut ::core::ffi::c_void,
    pub reserved1: [u32; 57usize],
    pub reserved2: [*mut ::core::ffi::c_void; 63usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_BITSTREAM_BUFFER {
    pub version: u32,
    pub size: u32,
    pub memoryHeap: NV_ENC_MEMORY_HEAP,
    pub reserved: u32,
    pub bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    pub bitstreamBufferPtr: *mut ::core::ffi::c_void,
    pub reserved1: [u32; 58usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MVECTOR {
    pub mvx: i16,
    pub mvy: i16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_H264_MV_DATA {
    pub mv: [NV_ENC_MVECTOR; 4usize],
    pub mbType: u8,
    pub partitionType: u8,
    pub reserved: u16,
    pub mbCost: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_HEVC_MV_DATA {
    pub mv: [NV_ENC_MVECTOR; 4usize],
    pub cuType: u8,
    pub cuSize: u8,
    pub partitionMode: u8,
    pub lastCUInCTB: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CREATE_MV_BUFFER {
    pub version: u32,
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    pub reserved1: [u32; 255usize],
    pub reserved2: [*mut ::core::ffi::c_void; 63usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_QP {
    pub qpInterP: u32,
    pub qpInterB: u32,
    pub qpIntra: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_RC_PARAMS {
    pub version: u32,
    pub rateControlMode: NV_ENC_PARAMS_RC_MODE,
    pub constQP: NV_ENC_QP,
    pub averageBitRate: u32,
    pub maxBitRate: u32,
    pub vbvBufferSize: u32,
    pub vbvInitialDelay: u32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub minQP: NV_ENC_QP,
    pub maxQP: NV_ENC_QP,
    pub initialRCQP: NV_ENC_QP,
    pub temporallayerIdxMask: u32,
    pub temporalLayerQP: [u8; 8usize],
    pub targetQuality: u8,
    pub targetQualityLSB: u8,
    pub lookaheadDepth: u16,
    pub lowDelayKeyFrameScale: u8,
    pub yDcQPIndexOffset: i8,
    pub uDcQPIndexOffset: i8,
    pub vDcQPIndexOffset: i8,
    pub qpMapMode: NV_ENC_QP_MAP_MODE,
    pub multiPass: NV_ENC_MULTI_PASS,
    pub alphaLayerBitrateRatio: u32,
    pub cbQPIndexOffset: i8,
    pub crQPIndexOffset: i8,
    pub reserved2: u16,
    pub reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CLOCK_TIMESTAMP_SET {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub timeOffset: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_TIME_CODE {
    pub displayPicStruct: NV_ENC_DISPLAY_PIC_STRUCT,
    pub clockTimestamp: [NV_ENC_CLOCK_TIMESTAMP_SET; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    pub overscanInfoPresentFlag: u32,
    pub overscanInfo: u32,
    pub videoSignalTypePresentFlag: u32,
    pub videoFormat: NV_ENC_VUI_VIDEO_FORMAT,
    pub videoFullRangeFlag: u32,
    pub colourDescriptionPresentFlag: u32,
    pub colourPrimaries: NV_ENC_VUI_COLOR_PRIMARIES,
    pub transferCharacteristics: NV_ENC_VUI_TRANSFER_CHARACTERISTIC,
    pub colourMatrix: NV_ENC_VUI_MATRIX_COEFFS,
    pub chromaSampleLocationFlag: u32,
    pub chromaSampleLocationTop: u32,
    pub chromaSampleLocationBot: u32,
    pub bitstreamRestrictionFlag: u32,
    pub timingInfoPresentFlag: u32,
    pub numUnitInTicks: u32,
    pub timeScale: u32,
    pub reserved: [u32; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 3usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NVENC_EXTERNAL_ME_SB_HINT {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub level: u32,
    pub idrPeriod: u32,
    pub separateColourPlaneFlag: u32,
    pub disableDeblockingFilterIDC: u32,
    pub numTemporalLayers: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub adaptiveTransformMode: NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE,
    pub fmoMode: NV_ENC_H264_FMO_MODE,
    pub bdirectMode: NV_ENC_H264_BDIRECT_MODE,
    pub entropyCodingMode: NV_ENC_H264_ENTROPY_CODING_MODE,
    pub stereoMode: NV_ENC_STEREO_PACKING_MODE,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFrames: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub h264VUIParameters: NV_ENC_CONFIG_H264_VUI_PARAMETERS,
    pub ltrNumFrames: u32,
    pub ltrTrustMode: u32,
    pub chromaFormatIDC: u32,
    pub maxTemporalLayers: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    pub reserved1: [u32; 267usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC {
    pub level: u32,
    pub tier: u32,
    pub minCUSize: NV_ENC_HEVC_CUSIZE,
    pub maxCUSize: NV_ENC_HEVC_CUSIZE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub idrPeriod: u32,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFramesInDPB: u32,
    pub ltrNumFrames: u32,
    pub vpsId: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub maxTemporalLayersMinus1: u32,
    pub hevcVUIParameters: NV_ENC_CONFIG_HEVC_VUI_PARAMETERS,
    pub ltrTrustMode: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub numRefL0: NV_ENC_NUM_REF_FRAMES,
    pub numRefL1: NV_ENC_NUM_REF_FRAMES,
    pub reserved1: [u32; 214usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_FILM_GRAIN_PARAMS_AV1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pointYValue: [u8; 14usize],
    pub pointYScaling: [u8; 14usize],
    pub pointCbValue: [u8; 10usize],
    pub pointCbScaling: [u8; 10usize],
    pub pointCrValue: [u8; 10usize],
    pub pointCrScaling: [u8; 10usize],
    pub arCoeffsYPlus128: [u8; 24usize],
    pub arCoeffsCbPlus128: [u8; 25usize],
    pub arCoeffsCrPlus128: [u8; 25usize],
    pub reserved2: [u8; 2usize],
    pub cbMult: u8,
    pub cbLumaMult: u8,
    pub cbOffset: u16,
    pub crMult: u8,
    pub crLumaMult: u8,
    pub crOffset: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_AV1 {
    pub level: u32,
    pub tier: u32,
    pub minPartSize: NV_ENC_AV1_PART_SIZE,
    pub maxPartSize: NV_ENC_AV1_PART_SIZE,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub idrPeriod: u32,
    pub intraRefreshPeriod: u32,
    pub intraRefreshCnt: u32,
    pub maxNumRefFramesInDPB: u32,
    pub numTileColumns: u32,
    pub numTileRows: u32,
    pub tileWidths: *mut u32,
    pub tileHeights: *mut u32,
    pub maxTemporalLayersMinus1: u32,
    pub colorPrimaries: NV_ENC_VUI_COLOR_PRIMARIES,
    pub transferCharacteristics: NV_ENC_VUI_TRANSFER_CHARACTERISTIC,
    pub matrixCoefficients: NV_ENC_VUI_MATRIX_COEFFS,
    pub colorRange: u32,
    pub chromaSamplePosition: u32,
    pub useBFramesAsRef: NV_ENC_BFRAME_REF_MODE,
    pub filmGrainParams: *mut NV_ENC_FILM_GRAIN_PARAMS_AV1,
    pub numFwdRefs: NV_ENC_NUM_REF_FRAMES,
    pub numBwdRefs: NV_ENC_NUM_REF_FRAMES,
    pub reserved1: [u32; 235usize],
    pub reserved2: [*mut ::core::ffi::c_void; 62usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_H264_MEONLY {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 255usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_CONFIG_HEVC_MEONLY {
    pub reserved: [u32; 256usize],
    pub reserved1: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_CONFIG {
    pub version: u32,
    pub profileGUID: GUID,
    pub gopLength: u32,
    pub frameIntervalP: i32,
    pub monoChromeEncoding: u32,
    pub frameFieldMode: NV_ENC_PARAMS_FRAME_FIELD_MODE,
    pub mvPrecision: NV_ENC_MV_PRECISION,
    pub rcParams: NV_ENC_RC_PARAMS,
    pub encodeCodecConfig: NV_ENC_CODEC_CONFIG,
    pub reserved: [u32; 278usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INITIALIZE_PARAMS {
    pub version: u32,
    pub encodeGUID: GUID,
    pub presetGUID: GUID,
    pub encodeWidth: u32,
    pub encodeHeight: u32,
    pub darWidth: u32,
    pub darHeight: u32,
    pub frameRateNum: u32,
    pub frameRateDen: u32,
    pub enableEncodeAsync: u32,
    pub enablePTD: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub privDataSize: u32,
    pub privData: *mut ::core::ffi::c_void,
    pub encodeConfig: *mut NV_ENC_CONFIG,
    pub maxEncodeWidth: u32,
    pub maxEncodeHeight: u32,
    pub maxMEHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub tuningInfo: NV_ENC_TUNING_INFO,
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    pub reserved: [u32; 287usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_RECONFIGURE_PARAMS {
    pub version: u32,
    pub reInitEncodeParams: NV_ENC_INITIALIZE_PARAMS,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PRESET_CONFIG {
    pub version: u32,
    pub presetCfg: NV_ENC_CONFIG,
    pub reserved1: [u32; 255usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_MVC {
    pub version: u32,
    pub viewID: u32,
    pub temporalID: u32,
    pub priorityID: u32,
    pub reserved1: [u32; 12usize],
    pub reserved2: [*mut ::core::ffi::c_void; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_SEI_PAYLOAD {
    pub payloadSize: u32,
    pub payloadType: u32,
    pub payload: *mut u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS_H264 {
    pub displayPOCSyntax: u32,
    pub reserved3: u32,
    pub refPicFlag: u32,
    pub colourPlaneId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sliceTypeData: *mut u8,
    pub sliceTypeArrayCnt: u32,
    pub seiPayloadArrayCnt: u32,
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub ltrUsageMode: u32,
    pub forceIntraSliceCount: u32,
    pub forceIntraSliceIdx: *mut u32,
    pub h264ExtPicParams: NV_ENC_PIC_PARAMS_H264_EXT,
    pub timeCode: NV_ENC_TIME_CODE,
    pub reserved: [u32; 203usize],
    pub reserved2: [*mut ::core::ffi::c_void; 61usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_HEVC {
    pub displayPOCSyntax: u32,
    pub refPicFlag: u32,
    pub temporalId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sliceTypeData: *mut u8,
    pub sliceTypeArrayCnt: u32,
    pub sliceMode: u32,
    pub sliceModeData: u32,
    pub ltrMarkFrameIdx: u32,
    pub ltrUseFrameBitmap: u32,
    pub ltrUsageMode: u32,
    pub seiPayloadArrayCnt: u32,
    pub reserved: u32,
    pub seiPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub timeCode: NV_ENC_TIME_CODE,
    pub reserved2: [u32; 237usize],
    pub reserved3: [*mut ::core::ffi::c_void; 61usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_PIC_PARAMS_AV1 {
    pub displayPOCSyntax: u32,
    pub refPicFlag: u32,
    pub temporalId: u32,
    pub forceIntraRefreshWithFrameCnt: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub numTileColumns: u32,
    pub numTileRows: u32,
    pub tileWidths: *mut u32,
    pub tileHeights: *mut u32,
    pub obuPayloadArrayCnt: u32,
    pub reserved: u32,
    pub obuPayloadArray: *mut NV_ENC_SEI_PAYLOAD,
    pub filmGrainParams: *mut NV_ENC_FILM_GRAIN_PARAMS_AV1,
    pub reserved2: [u32; 247usize],
    pub reserved3: [*mut ::core::ffi::c_void; 61usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NV_ENC_PIC_PARAMS {
    pub version: u32,
    pub inputWidth: u32,
    pub inputHeight: u32,
    pub inputPitch: u32,
    pub encodePicFlags: u32,
    pub frameIdx: u32,
    pub inputTimeStamp: u64,
    pub inputDuration: u64,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub outputBitstream: NV_ENC_OUTPUT_PTR,
    pub completionEvent: *mut ::core::ffi::c_void,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub codecPicParams: NV_ENC_CODEC_PIC_PARAMS,
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    pub reserved1: [u32; 6usize],
    pub reserved2: [*mut ::core::ffi::c_void; 2usize],
    pub qpDeltaMap: *mut i8,
    pub qpDeltaMapSize: u32,
    pub reservedBitFields: u32,
    pub meHintRefPicDist: [u16; 2usize],
    pub alphaBuffer: NV_ENC_INPUT_PTR,
    pub meExternalSbHints: *mut NVENC_EXTERNAL_ME_SB_HINT,
    pub meSbHintsCount: u32,
    pub reserved3: [u32; 285usize],
    pub reserved4: [*mut ::core::ffi::c_void; 58usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MEONLY_PARAMS {
    pub version: u32,
    pub inputWidth: u32,
    pub inputHeight: u32,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub referenceFrame: NV_ENC_INPUT_PTR,
    pub mvBuffer: NV_ENC_OUTPUT_PTR,
    pub bufferFmt: NV_ENC_BUFFER_FORMAT,
    pub completionEvent: *mut ::core::ffi::c_void,
    pub viewID: u32,
    pub meHintCountsPerBlock: [NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE; 2usize],
    pub meExternalHints: *mut NVENC_EXTERNAL_ME_HINT,
    pub reserved1: [u32; 243usize],
    pub reserved2: [*mut ::core::ffi::c_void; 59usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_BITSTREAM {
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub outputBitstream: *mut ::core::ffi::c_void,
    pub sliceOffsets: *mut u32,
    pub frameIdx: u32,
    pub hwEncodeStatus: u32,
    pub numSlices: u32,
    pub bitstreamSizeInBytes: u32,
    pub outputTimeStamp: u64,
    pub outputDuration: u64,
    pub bitstreamBufferPtr: *mut ::core::ffi::c_void,
    pub pictureType: NV_ENC_PIC_TYPE,
    pub pictureStruct: NV_ENC_PIC_STRUCT,
    pub frameAvgQP: u32,
    pub frameSatd: u32,
    pub ltrFrameIdx: u32,
    pub ltrFrameBitmap: u32,
    pub temporalId: u32,
    pub reserved: [u32; 12usize],
    pub intraMBCount: u32,
    pub interMBCount: u32,
    pub averageMVX: i32,
    pub averageMVY: i32,
    pub alphaLayerSizeInBytes: u32,
    pub reserved1: [u32; 218usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_LOCK_INPUT_BUFFER {
    pub version: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub inputBuffer: NV_ENC_INPUT_PTR,
    pub bufferDataPtr: *mut ::core::ffi::c_void,
    pub pitch: u32,
    pub reserved1: [u32; 251usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_MAP_INPUT_RESOURCE {
    pub version: u32,
    pub subResourceIndex: u32,
    pub inputResource: *mut ::core::ffi::c_void,
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    pub mappedResource: NV_ENC_INPUT_PTR,
    pub mappedBufferFmt: NV_ENC_BUFFER_FORMAT,
    pub reserved1: [u32; 251usize],
    pub reserved2: [*mut ::core::ffi::c_void; 63usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_OPENGL_TEX {
    pub texture: u32,
    pub target: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_FENCE_POINT_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pFence: *mut ::core::ffi::c_void,
    pub waitValue: u64,
    pub signalValue: u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: [u32; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_INPUT_RESOURCE_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pInputBuffer: NV_ENC_INPUT_PTR,
    pub inputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    pub reserved1: [u32; 16usize],
    pub reserved2: [*mut ::core::ffi::c_void; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    pub version: u32,
    pub reserved: u32,
    pub pOutputBuffer: NV_ENC_INPUT_PTR,
    pub outputFencePoint: NV_ENC_FENCE_POINT_D3D12,
    pub reserved1: [u32; 16usize],
    pub reserved2: [*mut ::core::ffi::c_void; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_REGISTER_RESOURCE {
    pub version: u32,
    pub resourceType: NV_ENC_INPUT_RESOURCE_TYPE,
    pub width: u32,
    pub height: u32,
    pub pitch: u32,
    pub subResourceIndex: u32,
    pub resourceToRegister: *mut ::core::ffi::c_void,
    pub registeredResource: NV_ENC_REGISTERED_PTR,
    pub bufferFormat: NV_ENC_BUFFER_FORMAT,
    pub bufferUsage: NV_ENC_BUFFER_USAGE,
    pub pInputFencePoint: *mut NV_ENC_FENCE_POINT_D3D12,
    pub reserved1: [u32; 247usize],
    pub reserved2: [*mut ::core::ffi::c_void; 61usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_STAT {
    pub version: u32,
    pub reserved: u32,
    pub outputBitStream: NV_ENC_OUTPUT_PTR,
    pub bitStreamSize: u32,
    pub picType: u32,
    pub lastValidByteOffset: u32,
    pub sliceOffsets: [u32; 16usize],
    pub picIdx: u32,
    pub frameAvgQP: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ltrFrameIdx: u32,
    pub intraMBCount: u32,
    pub interMBCount: u32,
    pub averageMVX: i32,
    pub averageMVY: i32,
    pub reserved1: [u32; 226usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    pub version: u32,
    pub inBufferSize: u32,
    pub spsId: u32,
    pub ppsId: u32,
    pub spsppsBuffer: *mut ::core::ffi::c_void,
    pub outSPSPPSPayloadSize: *mut u32,
    pub reserved: [u32; 250usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_EVENT_PARAMS {
    pub version: u32,
    pub reserved: u32,
    pub completionEvent: *mut ::core::ffi::c_void,
    pub reserved1: [u32; 253usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    pub version: u32,
    pub deviceType: NV_ENC_DEVICE_TYPE,
    pub device: *mut ::core::ffi::c_void,
    pub reserved: *mut ::core::ffi::c_void,
    pub apiVersion: u32,
    pub reserved1: [u32; 253usize],
    pub reserved2: [*mut ::core::ffi::c_void; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _NV_ENCODE_API_FUNCTION_LIST {
    pub version: u32,
    pub reserved: u32,
    pub nvEncOpenEncodeSession: PNVENCOPENENCODESESSION,
    pub nvEncGetEncodeGUIDCount: PNVENCGETENCODEGUIDCOUNT,
    pub nvEncGetEncodeProfileGUIDCount: PNVENCGETENCODEPRESETCOUNT,
    pub nvEncGetEncodeProfileGUIDs: PNVENCGETENCODEPRESETGUIDS,
    pub nvEncGetEncodeGUIDs: PNVENCGETENCODEGUIDS,
    pub nvEncGetInputFormatCount: PNVENCGETINPUTFORMATCOUNT,
    pub nvEncGetInputFormats: PNVENCGETINPUTFORMATS,
    pub nvEncGetEncodeCaps: PNVENCGETENCODECAPS,
    pub nvEncGetEncodePresetCount: PNVENCGETENCODEPRESETCOUNT,
    pub nvEncGetEncodePresetGUIDs: PNVENCGETENCODEPRESETGUIDS,
    pub nvEncGetEncodePresetConfig: PNVENCGETENCODEPRESETCONFIG,
    pub nvEncInitializeEncoder: PNVENCINITIALIZEENCODER,
    pub nvEncCreateInputBuffer: PNVENCCREATEINPUTBUFFER,
    pub nvEncDestroyInputBuffer: PNVENCDESTROYINPUTBUFFER,
    pub nvEncCreateBitstreamBuffer: PNVENCCREATEBITSTREAMBUFFER,
    pub nvEncDestroyBitstreamBuffer: PNVENCDESTROYBITSTREAMBUFFER,
    pub nvEncEncodePicture: PNVENCENCODEPICTURE,
    pub nvEncLockBitstream: PNVENCLOCKBITSTREAM,
    pub nvEncUnlockBitstream: PNVENCUNLOCKBITSTREAM,
    pub nvEncLockInputBuffer: PNVENCLOCKINPUTBUFFER,
    pub nvEncUnlockInputBuffer: PNVENCUNLOCKINPUTBUFFER,
    pub nvEncGetEncodeStats: PNVENCGETENCODESTATS,
    pub nvEncGetSequenceParams: PNVENCGETSEQUENCEPARAMS,
    pub nvEncRegisterAsyncEvent: PNVENCREGISTERASYNCEVENT,
    pub nvEncUnregisterAsyncEvent: PNVENCUNREGISTERASYNCEVENT,
    pub nvEncMapInputResource: PNVENCMAPINPUTRESOURCE,
    pub nvEncUnmapInputResource: PNVENCUNMAPINPUTRESOURCE,
    pub nvEncDestroyEncoder: PNVENCDESTROYENCODER,
    pub nvEncInvalidateRefFrames: PNVENCINVALIDATEREFFRAMES,
    pub nvEncOpenEncodeSessionEx: PNVENCOPENENCODESESSIONEX,
    pub nvEncRegisterResource: PNVENCREGISTERRESOURCE,
    pub nvEncUnregisterResource: PNVENCUNREGISTERRESOURCE,
    pub nvEncReconfigureEncoder: PNVENCRECONFIGUREENCODER,
    pub reserved1: *mut ::core::ffi::c_void,
    pub nvEncCreateMVBuffer: PNVENCCREATEMVBUFFER,
    pub nvEncDestroyMVBuffer: PNVENCDESTROYMVBUFFER,
    pub nvEncRunMotionEstimationOnly: PNVENCRUNMOTIONESTIMATIONONLY,
    pub nvEncGetLastErrorString: PNVENCGETLASTERROR,
    pub nvEncSetIOCudaStreams: PNVENCSETIOCUDASTREAMS,
    pub nvEncGetEncodePresetConfigEx: PNVENCGETENCODEPRESETCONFIGEX,
    pub nvEncGetSequenceParamEx: PNVENCGETSEQUENCEPARAMEX,
    pub reserved2: [*mut ::core::ffi::c_void; 277usize],
}
pub const NVENCAPI_MAJOR_VERSION: u32 = 12;
pub const NVENCAPI_MINOR_VERSION: u32 = 0;
pub const NVENCAPI_VERSION: u32 = 12;
pub const NVENC_INFINITE_GOPLENGTH: u32 = 4294967295;
pub const NV_MAX_SEQ_HDR_LEN: u32 = 512;
pub const NV_MAX_TILE_COLS_AV1: u32 = 64;
pub const NV_MAX_TILE_ROWS_AV1: u32 = 64;
#[test]
fn bindgen_test_layout__GUID() {
    const UNINIT: ::core::mem::MaybeUninit<_GUID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::core::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data4)
        )
    );
}
#[test]
fn bindgen_test_layout__NVENC_RECT() {
    const UNINIT: ::core::mem::MaybeUninit<_NVENC_RECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NVENC_RECT>(),
        16usize,
        concat!("Size of: ", stringify!(_NVENC_RECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_NVENC_RECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVENC_RECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_RECT),
            "::",
            stringify!(bottom)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CAPS_PARAM() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CAPS_PARAM> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CAPS_PARAM>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CAPS_PARAM>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CAPS_PARAM))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capsToQuery) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(capsToQuery)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CAPS_PARAM),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_ENCODE_OUT_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_ENCODE_OUT_PARAMS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_ENCODE_OUT_PARAMS>(),
        256usize,
        concat!("Size of: ", stringify!(_NV_ENC_ENCODE_OUT_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_ENCODE_OUT_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_ENCODE_OUT_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitstreamSizeInBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_ENCODE_OUT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_INPUT_BUFFER() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CREATE_INPUT_BUFFER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CREATE_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memoryHeap) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferFmt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pSysMemBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(pSysMemBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_BITSTREAM_BUFFER() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CREATE_BITSTREAM_BUFFER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        776usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CREATE_BITSTREAM_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memoryHeap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(memoryHeap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitstreamBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitstreamBufferPtr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_BITSTREAM_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_MVECTOR() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_MVECTOR> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_MVECTOR>(),
        4usize,
        concat!("Size of: ", stringify!(_NV_ENC_MVECTOR))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_MVECTOR>(),
        2usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MVECTOR))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mvx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MVECTOR),
            "::",
            stringify!(mvx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mvy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MVECTOR),
            "::",
            stringify!(mvy)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_H264_MV_DATA() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_H264_MV_DATA> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_H264_MV_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(_NV_ENC_H264_MV_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_H264_MV_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_H264_MV_DATA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mbType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mbType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partitionType) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(partitionType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mbCost) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_H264_MV_DATA),
            "::",
            stringify!(mbCost)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_HEVC_MV_DATA() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_HEVC_MV_DATA> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_HEVC_MV_DATA>(),
        20usize,
        concat!("Size of: ", stringify!(_NV_ENC_HEVC_MV_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_HEVC_MV_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(_NV_ENC_HEVC_MV_DATA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cuType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(cuType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cuSize) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(cuSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partitionMode) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(partitionMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lastCUInCTB) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_HEVC_MV_DATA),
            "::",
            stringify!(lastCUInCTB)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CREATE_MV_BUFFER() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CREATE_MV_BUFFER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CREATE_MV_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CREATE_MV_BUFFER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mvBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CREATE_MV_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_QP() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_QP> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_QP>(),
        12usize,
        concat!("Size of: ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_QP>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_QP))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpInterP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpInterB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpInterB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpIntra) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_QP),
            "::",
            stringify!(qpIntra)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_RC_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_RC_PARAMS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_RC_PARAMS>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_RC_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RC_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rateControlMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(rateControlMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).constQP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(constQP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).averageBitRate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(averageBitRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxBitRate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxBitRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vbvBufferSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vbvInitialDelay) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vbvInitialDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minQP) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(minQP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxQP) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(maxQP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initialRCQP) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(initialRCQP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temporallayerIdxMask) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporallayerIdxMask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temporalLayerQP) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(temporalLayerQP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).targetQuality) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQuality)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).targetQualityLSB) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(targetQualityLSB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lookaheadDepth) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lookaheadDepth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lowDelayKeyFrameScale) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(lowDelayKeyFrameScale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yDcQPIndexOffset) as usize - ptr as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(yDcQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uDcQPIndexOffset) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(uDcQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vDcQPIndexOffset) as usize - ptr as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(vDcQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpMapMode) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(qpMapMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multiPass) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(multiPass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alphaLayerBitrateRatio) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(alphaLayerBitrateRatio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbQPIndexOffset) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(cbQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crQPIndexOffset) as usize - ptr as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(crQPIndexOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CLOCK_TIMESTAMP_SET() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CLOCK_TIMESTAMP_SET> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CLOCK_TIMESTAMP_SET>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_ENC_CLOCK_TIMESTAMP_SET))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CLOCK_TIMESTAMP_SET>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CLOCK_TIMESTAMP_SET))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CLOCK_TIMESTAMP_SET),
            "::",
            stringify!(timeOffset)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_TIME_CODE() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_TIME_CODE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_TIME_CODE>(),
        28usize,
        concat!("Size of: ", stringify!(_NV_ENC_TIME_CODE))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_TIME_CODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_TIME_CODE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).displayPicStruct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_TIME_CODE),
            "::",
            stringify!(displayPicStruct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clockTimestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_TIME_CODE),
            "::",
            stringify!(clockTimestamp)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_VUI_PARAMETERS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CONFIG_H264_VUI_PARAMETERS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        112usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CONFIG_H264_VUI_PARAMETERS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overscanInfoPresentFlag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfoPresentFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overscanInfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(overscanInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).videoSignalTypePresentFlag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoSignalTypePresentFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).videoFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).videoFullRangeFlag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(videoFullRangeFlag)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).colourDescriptionPresentFlag) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourDescriptionPresentFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colourPrimaries) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourPrimaries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transferCharacteristics) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(transferCharacteristics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colourMatrix) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(colourMatrix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chromaSampleLocationFlag) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chromaSampleLocationTop) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationTop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chromaSampleLocationBot) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(chromaSampleLocationBot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitstreamRestrictionFlag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(bitstreamRestrictionFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timingInfoPresentFlag) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(timingInfoPresentFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numUnitInTicks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(numUnitInTicks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeScale) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(timeScale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_VUI_PARAMETERS),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE() {
    const UNINIT: ::core::mem::MaybeUninit<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE),
            "::",
            stringify!(reserved1)
        )
    );
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_HINT() {
    assert_eq!(
        ::core::mem::size_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Size of: ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
    assert_eq!(
        ::core::mem::align_of::<_NVENC_EXTERNAL_ME_HINT>(),
        4usize,
        concat!("Alignment of ", stringify!(_NVENC_EXTERNAL_ME_HINT))
    );
}
#[test]
fn bindgen_test_layout__NVENC_EXTERNAL_ME_SB_HINT() {
    assert_eq!(
        ::core::mem::size_of::<_NVENC_EXTERNAL_ME_SB_HINT>(),
        6usize,
        concat!("Size of: ", stringify!(_NVENC_EXTERNAL_ME_SB_HINT))
    );
    assert_eq!(
        ::core::mem::align_of::<_NVENC_EXTERNAL_ME_SB_HINT>(),
        2usize,
        concat!("Alignment of ", stringify!(_NVENC_EXTERNAL_ME_SB_HINT))
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CONFIG_H264> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CONFIG_H264>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CONFIG_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idrPeriod) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).separateColourPlaneFlag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(separateColourPlaneFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disableDeblockingFilterIDC) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(disableDeblockingFilterIDC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTemporalLayers) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numTemporalLayers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spsId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ppsId) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adaptiveTransformMode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(adaptiveTransformMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fmoMode) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(fmoMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bdirectMode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(bdirectMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entropyCodingMode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(entropyCodingMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stereoMode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(stereoMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intraRefreshPeriod) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intraRefreshCnt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxNumRefFrames) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxNumRefFrames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceMode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceModeData) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h264VUIParameters) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(h264VUIParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrNumFrames) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrTrustMode) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chromaFormatIDC) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(chromaFormatIDC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxTemporalLayers) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(maxTemporalLayers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).useBFramesAsRef) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRefL0) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRefL1) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CONFIG_HEVC> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CONFIG_HEVC>(),
        1560usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CONFIG_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(tier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minCUSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(minCUSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxCUSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxCUSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idrPeriod) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intraRefreshPeriod) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intraRefreshCnt) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxNumRefFramesInDPB) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxNumRefFramesInDPB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrNumFrames) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrNumFrames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vpsId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(vpsId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spsId) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ppsId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceMode) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceModeData) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxTemporalLayersMinus1) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(maxTemporalLayersMinus1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hevcVUIParameters) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(hevcVUIParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrTrustMode) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(ltrTrustMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).useBFramesAsRef) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRefL0) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRefL1) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(numRefL1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_FILM_GRAIN_PARAMS_AV1() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_FILM_GRAIN_PARAMS_AV1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_FILM_GRAIN_PARAMS_AV1>(),
        156usize,
        concat!("Size of: ", stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_FILM_GRAIN_PARAMS_AV1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pointYValue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointYValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pointYScaling) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointYScaling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pointCbValue) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointCbValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pointCbScaling) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointCbScaling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pointCrValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointCrValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pointCrScaling) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(pointCrScaling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arCoeffsYPlus128) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(arCoeffsYPlus128)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arCoeffsCbPlus128) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(arCoeffsCbPlus128)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arCoeffsCrPlus128) as usize - ptr as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(arCoeffsCrPlus128)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbMult) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(cbMult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbLumaMult) as usize - ptr as usize },
        149usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(cbLumaMult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbOffset) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(cbOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crMult) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(crMult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crLumaMult) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(crLumaMult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crOffset) as usize - ptr as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FILM_GRAIN_PARAMS_AV1),
            "::",
            stringify!(crOffset)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_AV1() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CONFIG_AV1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CONFIG_AV1>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_AV1))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CONFIG_AV1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_AV1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(tier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minPartSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(minPartSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxPartSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(maxPartSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idrPeriod) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(idrPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intraRefreshPeriod) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(intraRefreshPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intraRefreshCnt) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(intraRefreshCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxNumRefFramesInDPB) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(maxNumRefFramesInDPB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTileColumns) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(numTileColumns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTileRows) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(numTileRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tileWidths) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(tileWidths)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tileHeights) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(tileHeights)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxTemporalLayersMinus1) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(maxTemporalLayersMinus1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colorPrimaries) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(colorPrimaries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transferCharacteristics) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(transferCharacteristics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrixCoefficients) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(matrixCoefficients)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colorRange) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(colorRange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chromaSamplePosition) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(chromaSamplePosition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).useBFramesAsRef) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(useBFramesAsRef)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filmGrainParams) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(filmGrainParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numFwdRefs) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(numFwdRefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numBwdRefs) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(numBwdRefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_AV1),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_H264_MEONLY() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CONFIG_H264_MEONLY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CONFIG_H264_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_H264_MEONLY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_H264_MEONLY),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG_HEVC_MEONLY() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CONFIG_HEVC_MEONLY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CONFIG_HEVC_MEONLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG_HEVC_MEONLY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG_HEVC_MEONLY),
            "::",
            stringify!(reserved1)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_CONFIG() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CODEC_CONFIG> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CODEC_CONFIG>(),
        1792usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CODEC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_CONFIG))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h264Config) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264Config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hevcConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).av1Config) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(av1Config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h264MeOnlyConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(h264MeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hevcMeOnlyConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(hevcMeOnlyConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CONFIG() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CONFIG> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CONFIG>(),
        3584usize,
        concat!("Size of: ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CONFIG))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).profileGUID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(profileGUID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gopLength) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(gopLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameIntervalP) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameIntervalP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).monoChromeEncoding) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(monoChromeEncoding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameFieldMode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(frameFieldMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mvPrecision) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(mvPrecision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(rcParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encodeCodecConfig) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(encodeCodecConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_INITIALIZE_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_INITIALIZE_PARAMS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        1808usize,
        concat!("Size of: ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_INITIALIZE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_INITIALIZE_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encodeGUID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeGUID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).presetGUID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(presetGUID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encodeWidth) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encodeHeight) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).darWidth) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).darHeight) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(darHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameRateNum) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateNum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameRateDen) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(frameRateDen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enableEncodeAsync) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enableEncodeAsync)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enablePTD) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(enablePTD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).privDataSize) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privDataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).privData) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(privData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encodeConfig) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(encodeConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxEncodeWidth) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxEncodeHeight) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxEncodeHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxMEHintCountsPerBlock) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(maxMEHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tuningInfo) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(tuningInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferFormat) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INITIALIZE_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_RECONFIGURE_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_RECONFIGURE_PARAMS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        1824usize,
        concat!("Size of: ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_RECONFIGURE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_RECONFIGURE_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reInitEncodeParams) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_RECONFIGURE_PARAMS),
            "::",
            stringify!(reInitEncodeParams)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_PRESET_CONFIG() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_PRESET_CONFIG> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_PRESET_CONFIG>(),
        5128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_PRESET_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PRESET_CONFIG))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).presetCfg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(presetCfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        3592usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        4616usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PRESET_CONFIG),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_MVC() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_MVC> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_PIC_PARAMS_MVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_MVC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).viewID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temporalID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(temporalID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priorityID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(priorityID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_MVC),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264_EXT() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_H264_EXT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        128usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_PIC_PARAMS_H264_EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264_EXT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mvcPicParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(mvcPicParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264_EXT),
            "::",
            stringify!(reserved1)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_SEI_PAYLOAD() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_SEI_PAYLOAD> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_SEI_PAYLOAD>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_SEI_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEI_PAYLOAD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payloadSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payloadType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payloadType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEI_PAYLOAD),
            "::",
            stringify!(payload)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_H264() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_H264> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_PIC_PARAMS_H264>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_PIC_PARAMS_H264>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_H264))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).displayPOCSyntax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refPicFlag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colourPlaneId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(colourPlaneId)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).forceIntraRefreshWithFrameCnt) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceTypeData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceTypeArrayCnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seiPayloadArrayCnt) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seiPayloadArray) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceMode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceModeData) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrMarkFrameIdx) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrUseFrameBitmap) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrUsageMode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).forceIntraSliceCount) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).forceIntraSliceIdx) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(forceIntraSliceIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h264ExtPicParams) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(h264ExtPicParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeCode) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(timeCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_H264),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_HEVC() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_HEVC> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_PIC_PARAMS_HEVC>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_HEVC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).displayPOCSyntax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refPicFlag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temporalId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).forceIntraRefreshWithFrameCnt) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceTypeData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceTypeArrayCnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceTypeArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceMode) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceModeData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(sliceModeData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrMarkFrameIdx) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrMarkFrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrUseFrameBitmap) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUseFrameBitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrUsageMode) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(ltrUsageMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seiPayloadArrayCnt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seiPayloadArray) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(seiPayloadArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeCode) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(timeCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_HEVC),
            "::",
            stringify!(reserved3)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS_AV1() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_PIC_PARAMS_AV1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_PIC_PARAMS_AV1>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS_AV1))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_PIC_PARAMS_AV1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS_AV1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).displayPOCSyntax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(displayPOCSyntax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refPicFlag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(refPicFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temporalId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).forceIntraRefreshWithFrameCnt) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(forceIntraRefreshWithFrameCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTileColumns) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(numTileColumns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTileRows) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(numTileRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tileWidths) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(tileWidths)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tileHeights) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(tileHeights)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obuPayloadArrayCnt) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(obuPayloadArrayCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obuPayloadArray) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(obuPayloadArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filmGrainParams) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(filmGrainParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS_AV1),
            "::",
            stringify!(reserved3)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_CODEC_PIC_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_CODEC_PIC_PARAMS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_CODEC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_CODEC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h264PicParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(h264PicParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hevcPicParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(hevcPicParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).av1PicParams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(av1PicParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_CODEC_PIC_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_PIC_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_PIC_PARAMS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_PIC_PARAMS>(),
        3360usize,
        concat!("Size of: ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_PIC_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_PIC_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputHeight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputPitch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encodePicFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(encodePicFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameIdx) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputTimeStamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputDuration) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputDuration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputBitstream) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).completionEvent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferFmt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pictureStruct) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pictureType) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).codecPicParams) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(codecPicParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meHintCountsPerBlock) as usize - ptr as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meExternalHints) as usize - ptr as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpDeltaMap) as usize - ptr as usize },
        1712usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpDeltaMapSize) as usize - ptr as usize },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(qpDeltaMapSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reservedBitFields) as usize - ptr as usize },
        1724usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reservedBitFields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meHintRefPicDist) as usize - ptr as usize },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meHintRefPicDist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alphaBuffer) as usize - ptr as usize },
        1736usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(alphaBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meExternalSbHints) as usize - ptr as usize },
        1744usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meExternalSbHints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meSbHintsCount) as usize - ptr as usize },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(meSbHintsCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        1756usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        2896usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_PIC_PARAMS),
            "::",
            stringify!(reserved4)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_MEONLY_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_MEONLY_PARAMS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_MEONLY_PARAMS>(),
        1552usize,
        concat!("Size of: ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_MEONLY_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MEONLY_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputHeight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).referenceFrame) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(referenceFrame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mvBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(mvBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferFmt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(bufferFmt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).completionEvent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).viewID) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(viewID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meHintCountsPerBlock) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meHintCountsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meExternalHints) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(meExternalHints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MEONLY_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_BITSTREAM() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_LOCK_BITSTREAM> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_LOCK_BITSTREAM>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_LOCK_BITSTREAM>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_BITSTREAM))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputBitstream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputBitstream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceOffsets) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameIdx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwEncodeStatus) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(hwEncodeStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numSlices) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitstreamSizeInBytes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputTimeStamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputDuration) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(outputDuration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitstreamBufferPtr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(bitstreamBufferPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pictureType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pictureStruct) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(pictureStruct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameAvgQP) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameSatd) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(frameSatd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrFrameIdx) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrFrameBitmap) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(ltrFrameBitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temporalId) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(temporalId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intraMBCount) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interMBCount) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).averageMVX) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).averageMVY) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alphaLayerSizeInBytes) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(alphaLayerSizeInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_BITSTREAM),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_LOCK_INPUT_BUFFER() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_LOCK_INPUT_BUFFER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_LOCK_INPUT_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_LOCK_INPUT_BUFFER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(inputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferDataPtr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(bufferDataPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_LOCK_INPUT_BUFFER),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_MAP_INPUT_RESOURCE() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_MAP_INPUT_RESOURCE> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_MAP_INPUT_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_MAP_INPUT_RESOURCE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subResourceIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputResource) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(inputResource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).registeredResource) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mappedResource) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedResource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mappedBufferFmt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(mappedBufferFmt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_MAP_INPUT_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_INPUT_RESOURCE_OPENGL_TEX() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>(),
        8usize,
        concat!("Size of: ", stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_INPUT_RESOURCE_OPENGL_TEX>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).texture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_OPENGL_TEX),
            "::",
            stringify!(target)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_FENCE_POINT_D3D12() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_FENCE_POINT_D3D12> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_FENCE_POINT_D3D12>(),
        64usize,
        concat!("Size of: ", stringify!(_NV_ENC_FENCE_POINT_D3D12))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_FENCE_POINT_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_FENCE_POINT_D3D12))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pFence) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(pFence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waitValue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(waitValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signalValue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(signalValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_FENCE_POINT_D3D12),
            "::",
            stringify!(reserved1)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_INPUT_RESOURCE_D3D12() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_INPUT_RESOURCE_D3D12> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_INPUT_RESOURCE_D3D12>(),
        272usize,
        concat!("Size of: ", stringify!(_NV_ENC_INPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_INPUT_RESOURCE_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_INPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pInputBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(pInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inputFencePoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(inputFencePoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_INPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_OUTPUT_RESOURCE_D3D12() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_OUTPUT_RESOURCE_D3D12> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_OUTPUT_RESOURCE_D3D12>(),
        272usize,
        concat!("Size of: ", stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_OUTPUT_RESOURCE_D3D12>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pOutputBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(pOutputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputFencePoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(outputFencePoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OUTPUT_RESOURCE_D3D12),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_REGISTER_RESOURCE() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_REGISTER_RESOURCE> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_REGISTER_RESOURCE>(),
        1536usize,
        concat!("Size of: ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_REGISTER_RESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_REGISTER_RESOURCE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resourceType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subResourceIndex) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(subResourceIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resourceToRegister) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(resourceToRegister)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).registeredResource) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(registeredResource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferFormat) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferUsage) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(bufferUsage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pInputFencePoint) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(pInputFencePoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_REGISTER_RESOURCE),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_STAT() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_STAT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_STAT>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_STAT>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_STAT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputBitStream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(outputBitStream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitStreamSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(bitStreamSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).picType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lastValidByteOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(lastValidByteOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sliceOffsets) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(sliceOffsets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).picIdx) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(picIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frameAvgQP) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(frameAvgQP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ltrFrameIdx) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(ltrFrameIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intraMBCount) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(intraMBCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interMBCount) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(interMBCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).averageMVX) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(averageMVX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).averageMVY) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(averageMVY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_STAT),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_SEQUENCE_PARAM_PAYLOAD() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_SEQUENCE_PARAM_PAYLOAD> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_SEQUENCE_PARAM_PAYLOAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inBufferSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(inBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spsId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ppsId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(ppsId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spsppsBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(spsppsBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outSPSPPSPayloadSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(outSPSPPSPayloadSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_SEQUENCE_PARAM_PAYLOAD),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_EVENT_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_EVENT_PARAMS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_EVENT_PARAMS>(),
        1544usize,
        concat!("Size of: ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_EVENT_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENC_EVENT_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).completionEvent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(completionEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_EVENT_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        1552usize,
        concat!(
            "Size of: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deviceType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).apiVersion) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(apiVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout__NV_ENCODE_API_FUNCTION_LIST() {
    const UNINIT: ::core::mem::MaybeUninit<_NV_ENCODE_API_FUNCTION_LIST> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        2552usize,
        concat!("Size of: ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        ::core::mem::align_of::<_NV_ENCODE_API_FUNCTION_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_ENCODE_API_FUNCTION_LIST))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncOpenEncodeSession) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSession)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetEncodeGUIDCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDCount)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nvEncGetEncodeProfileGUIDCount) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetEncodeProfileGUIDs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeProfileGUIDs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetEncodeGUIDs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeGUIDs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetInputFormatCount) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormatCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetInputFormats) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetInputFormats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetEncodeCaps) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeCaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetEncodePresetCount) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetEncodePresetGUIDs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetGUIDs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetEncodePresetConfig) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncInitializeEncoder) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInitializeEncoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncCreateInputBuffer) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncDestroyInputBuffer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncCreateBitstreamBuffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nvEncDestroyBitstreamBuffer) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyBitstreamBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncEncodePicture) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncEncodePicture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncLockBitstream) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockBitstream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncUnlockBitstream) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockBitstream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncLockInputBuffer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncLockInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncUnlockInputBuffer) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnlockInputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetEncodeStats) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodeStats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetSequenceParams) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncRegisterAsyncEvent) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncUnregisterAsyncEvent) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterAsyncEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncMapInputResource) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncMapInputResource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncUnmapInputResource) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnmapInputResource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncDestroyEncoder) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyEncoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncInvalidateRefFrames) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncInvalidateRefFrames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncOpenEncodeSessionEx) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncOpenEncodeSessionEx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncRegisterResource) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRegisterResource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncUnregisterResource) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncUnregisterResource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncReconfigureEncoder) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncReconfigureEncoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncCreateMVBuffer) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncCreateMVBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncDestroyMVBuffer) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncDestroyMVBuffer)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nvEncRunMotionEstimationOnly) as usize - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncRunMotionEstimationOnly)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetLastErrorString) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetLastErrorString)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncSetIOCudaStreams) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncSetIOCudaStreams)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nvEncGetEncodePresetConfigEx) as usize - ptr as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetEncodePresetConfigEx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvEncGetSequenceParamEx) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(nvEncGetSequenceParamEx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_ENCODE_API_FUNCTION_LIST),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_FRAME_FIELD_MODE {
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FRAME = 1,
    NV_ENC_PARAMS_FRAME_FIELD_MODE_FIELD = 2,
    NV_ENC_PARAMS_FRAME_FIELD_MODE_MBAFF = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PARAMS_RC_MODE {
    NV_ENC_PARAMS_RC_CONSTQP = 0,
    NV_ENC_PARAMS_RC_VBR = 1,
    NV_ENC_PARAMS_RC_CBR = 2,
    NV_ENC_PARAMS_RC_CBR_LOWDELAY_HQ = 8,
    NV_ENC_PARAMS_RC_CBR_HQ = 16,
    NV_ENC_PARAMS_RC_VBR_HQ = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MULTI_PASS {
    NV_ENC_MULTI_PASS_DISABLED = 0,
    NV_ENC_TWO_PASS_QUARTER_RESOLUTION = 1,
    NV_ENC_TWO_PASS_FULL_RESOLUTION = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_EMPHASIS_MAP_LEVEL {
    NV_ENC_EMPHASIS_MAP_LEVEL_0 = 0,
    NV_ENC_EMPHASIS_MAP_LEVEL_1 = 1,
    NV_ENC_EMPHASIS_MAP_LEVEL_2 = 2,
    NV_ENC_EMPHASIS_MAP_LEVEL_3 = 3,
    NV_ENC_EMPHASIS_MAP_LEVEL_4 = 4,
    NV_ENC_EMPHASIS_MAP_LEVEL_5 = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_QP_MAP_MODE {
    NV_ENC_QP_MAP_DISABLED = 0,
    NV_ENC_QP_MAP_EMPHASIS = 1,
    NV_ENC_QP_MAP_DELTA = 2,
    NV_ENC_QP_MAP = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_STRUCT {
    NV_ENC_PIC_STRUCT_FRAME = 1,
    NV_ENC_PIC_STRUCT_FIELD_TOP_BOTTOM = 2,
    NV_ENC_PIC_STRUCT_FIELD_BOTTOM_TOP = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_DISPLAY_PIC_STRUCT {
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME = 0,
    NV_ENC_PIC_STRUCT_DISPLAY_FIELD_TOP_BOTTOM = 1,
    NV_ENC_PIC_STRUCT_DISPLAY_FIELD_BOTTOM_TOP = 2,
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME_DOUBLING = 3,
    NV_ENC_PIC_STRUCT_DISPLAY_FRAME_TRIPLING = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_TYPE {
    NV_ENC_PIC_TYPE_P = 0,
    NV_ENC_PIC_TYPE_B = 1,
    NV_ENC_PIC_TYPE_I = 2,
    NV_ENC_PIC_TYPE_IDR = 3,
    NV_ENC_PIC_TYPE_BI = 4,
    NV_ENC_PIC_TYPE_SKIPPED = 5,
    NV_ENC_PIC_TYPE_INTRA_REFRESH = 6,
    NV_ENC_PIC_TYPE_NONREF_P = 7,
    NV_ENC_PIC_TYPE_UNKNOWN = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MV_PRECISION {
    NV_ENC_MV_PRECISION_DEFAULT = 0,
    NV_ENC_MV_PRECISION_FULL_PEL = 1,
    NV_ENC_MV_PRECISION_HALF_PEL = 2,
    NV_ENC_MV_PRECISION_QUARTER_PEL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_FORMAT {
    NV_ENC_BUFFER_FORMAT_UNDEFINED = 0,
    NV_ENC_BUFFER_FORMAT_NV12 = 1,
    NV_ENC_BUFFER_FORMAT_YV12 = 16,
    NV_ENC_BUFFER_FORMAT_IYUV = 256,
    NV_ENC_BUFFER_FORMAT_YUV444 = 4096,
    NV_ENC_BUFFER_FORMAT_YUV420_10BIT = 65536,
    NV_ENC_BUFFER_FORMAT_YUV444_10BIT = 1048576,
    NV_ENC_BUFFER_FORMAT_ARGB = 16777216,
    NV_ENC_BUFFER_FORMAT_ARGB10 = 33554432,
    NV_ENC_BUFFER_FORMAT_AYUV = 67108864,
    NV_ENC_BUFFER_FORMAT_ABGR = 268435456,
    NV_ENC_BUFFER_FORMAT_ABGR10 = 536870912,
    NV_ENC_BUFFER_FORMAT_U8 = 1073741824,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_LEVEL {
    NV_ENC_LEVEL_AUTOSELECT = 0,
    NV_ENC_LEVEL_H264_1 = 10,
    NV_ENC_LEVEL_H264_1b = 9,
    NV_ENC_LEVEL_H264_11 = 11,
    NV_ENC_LEVEL_H264_12 = 12,
    NV_ENC_LEVEL_H264_13 = 13,
    NV_ENC_LEVEL_H264_2 = 20,
    NV_ENC_LEVEL_H264_21 = 21,
    NV_ENC_LEVEL_H264_22 = 22,
    NV_ENC_LEVEL_H264_3 = 30,
    NV_ENC_LEVEL_H264_31 = 31,
    NV_ENC_LEVEL_H264_32 = 32,
    NV_ENC_LEVEL_H264_4 = 40,
    NV_ENC_LEVEL_H264_41 = 41,
    NV_ENC_LEVEL_H264_42 = 42,
    NV_ENC_LEVEL_H264_5 = 50,
    NV_ENC_LEVEL_H264_51 = 51,
    NV_ENC_LEVEL_H264_52 = 52,
    NV_ENC_LEVEL_H264_60 = 60,
    NV_ENC_LEVEL_H264_61 = 61,
    NV_ENC_LEVEL_H264_62 = 62,
    NV_ENC_LEVEL_HEVC_21 = 63,
    NV_ENC_LEVEL_HEVC_3 = 90,
    NV_ENC_LEVEL_HEVC_31 = 93,
    NV_ENC_LEVEL_HEVC_4 = 120,
    NV_ENC_LEVEL_HEVC_41 = 123,
    NV_ENC_LEVEL_HEVC_5 = 150,
    NV_ENC_LEVEL_HEVC_51 = 153,
    NV_ENC_LEVEL_HEVC_52 = 156,
    NV_ENC_LEVEL_HEVC_6 = 180,
    NV_ENC_LEVEL_HEVC_61 = 183,
    NV_ENC_LEVEL_HEVC_62 = 186,
    NV_ENC_TIER_HEVC_HIGH = 1,
    NV_ENC_LEVEL_AV1_22 = 2,
    NV_ENC_LEVEL_AV1_23 = 3,
    NV_ENC_LEVEL_AV1_3 = 4,
    NV_ENC_LEVEL_AV1_31 = 5,
    NV_ENC_LEVEL_AV1_32 = 6,
    NV_ENC_LEVEL_AV1_33 = 7,
    NV_ENC_LEVEL_AV1_4 = 8,
    NV_ENC_LEVEL_AV1_52 = 14,
    NV_ENC_LEVEL_AV1_53 = 15,
    NV_ENC_LEVEL_AV1_6 = 16,
    NV_ENC_LEVEL_AV1_61 = 17,
    NV_ENC_LEVEL_AV1_62 = 18,
    NV_ENC_LEVEL_AV1_63 = 19,
    NV_ENC_LEVEL_AV1_73 = 23,
    NV_ENC_LEVEL_AV1_AUTOSELECT = 24,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NVENCSTATUS {
    NV_ENC_SUCCESS = 0,
    NV_ENC_ERR_NO_ENCODE_DEVICE = 1,
    NV_ENC_ERR_UNSUPPORTED_DEVICE = 2,
    NV_ENC_ERR_INVALID_ENCODERDEVICE = 3,
    NV_ENC_ERR_INVALID_DEVICE = 4,
    NV_ENC_ERR_DEVICE_NOT_EXIST = 5,
    NV_ENC_ERR_INVALID_PTR = 6,
    NV_ENC_ERR_INVALID_EVENT = 7,
    NV_ENC_ERR_INVALID_PARAM = 8,
    NV_ENC_ERR_INVALID_CALL = 9,
    NV_ENC_ERR_OUT_OF_MEMORY = 10,
    NV_ENC_ERR_ENCODER_NOT_INITIALIZED = 11,
    NV_ENC_ERR_UNSUPPORTED_PARAM = 12,
    NV_ENC_ERR_LOCK_BUSY = 13,
    NV_ENC_ERR_NOT_ENOUGH_BUFFER = 14,
    NV_ENC_ERR_INVALID_VERSION = 15,
    NV_ENC_ERR_MAP_FAILED = 16,
    NV_ENC_ERR_NEED_MORE_INPUT = 17,
    NV_ENC_ERR_ENCODER_BUSY = 18,
    NV_ENC_ERR_EVENT_NOT_REGISTERD = 19,
    NV_ENC_ERR_GENERIC = 20,
    NV_ENC_ERR_INCOMPATIBLE_CLIENT_KEY = 21,
    NV_ENC_ERR_UNIMPLEMENTED = 22,
    NV_ENC_ERR_RESOURCE_REGISTER_FAILED = 23,
    NV_ENC_ERR_RESOURCE_NOT_REGISTERED = 24,
    NV_ENC_ERR_RESOURCE_NOT_MAPPED = 25,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_PIC_FLAGS {
    NV_ENC_PIC_FLAG_FORCEINTRA = 1,
    NV_ENC_PIC_FLAG_FORCEIDR = 2,
    NV_ENC_PIC_FLAG_OUTPUT_SPSPPS = 4,
    NV_ENC_PIC_FLAG_EOS = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_MEMORY_HEAP {
    NV_ENC_MEMORY_HEAP_AUTOSELECT = 0,
    NV_ENC_MEMORY_HEAP_VID = 1,
    NV_ENC_MEMORY_HEAP_SYSMEM_CACHED = 2,
    NV_ENC_MEMORY_HEAP_SYSMEM_UNCACHED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BFRAME_REF_MODE {
    NV_ENC_BFRAME_REF_MODE_DISABLED = 0,
    NV_ENC_BFRAME_REF_MODE_EACH = 1,
    NV_ENC_BFRAME_REF_MODE_MIDDLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_ENTROPY_CODING_MODE {
    NV_ENC_H264_ENTROPY_CODING_MODE_AUTOSELECT = 0,
    NV_ENC_H264_ENTROPY_CODING_MODE_CABAC = 1,
    NV_ENC_H264_ENTROPY_CODING_MODE_CAVLC = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_BDIRECT_MODE {
    NV_ENC_H264_BDIRECT_MODE_AUTOSELECT = 0,
    NV_ENC_H264_BDIRECT_MODE_DISABLE = 1,
    NV_ENC_H264_BDIRECT_MODE_TEMPORAL = 2,
    NV_ENC_H264_BDIRECT_MODE_SPATIAL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_FMO_MODE {
    NV_ENC_H264_FMO_AUTOSELECT = 0,
    NV_ENC_H264_FMO_ENABLE = 1,
    NV_ENC_H264_FMO_DISABLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE {
    NV_ENC_H264_ADAPTIVE_TRANSFORM_AUTOSELECT = 0,
    NV_ENC_H264_ADAPTIVE_TRANSFORM_DISABLE = 1,
    NV_ENC_H264_ADAPTIVE_TRANSFORM_ENABLE = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_STEREO_PACKING_MODE {
    NV_ENC_STEREO_PACKING_MODE_NONE = 0,
    NV_ENC_STEREO_PACKING_MODE_CHECKERBOARD = 1,
    NV_ENC_STEREO_PACKING_MODE_COLINTERLEAVE = 2,
    NV_ENC_STEREO_PACKING_MODE_ROWINTERLEAVE = 3,
    NV_ENC_STEREO_PACKING_MODE_SIDEBYSIDE = 4,
    NV_ENC_STEREO_PACKING_MODE_TOPBOTTOM = 5,
    NV_ENC_STEREO_PACKING_MODE_FRAMESEQ = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_INPUT_RESOURCE_TYPE {
    NV_ENC_INPUT_RESOURCE_TYPE_DIRECTX = 0,
    NV_ENC_INPUT_RESOURCE_TYPE_CUDADEVICEPTR = 1,
    NV_ENC_INPUT_RESOURCE_TYPE_CUDAARRAY = 2,
    NV_ENC_INPUT_RESOURCE_TYPE_OPENGL_TEX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_BUFFER_USAGE {
    NV_ENC_INPUT_IMAGE = 0,
    NV_ENC_OUTPUT_MOTION_VECTOR = 1,
    NV_ENC_OUTPUT_BITSTREAM = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_DEVICE_TYPE {
    NV_ENC_DEVICE_TYPE_DIRECTX = 0,
    NV_ENC_DEVICE_TYPE_CUDA = 1,
    NV_ENC_DEVICE_TYPE_OPENGL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_NUM_REF_FRAMES {
    NV_ENC_NUM_REF_FRAMES_AUTOSELECT = 0,
    NV_ENC_NUM_REF_FRAMES_1 = 1,
    NV_ENC_NUM_REF_FRAMES_2 = 2,
    NV_ENC_NUM_REF_FRAMES_3 = 3,
    NV_ENC_NUM_REF_FRAMES_4 = 4,
    NV_ENC_NUM_REF_FRAMES_5 = 5,
    NV_ENC_NUM_REF_FRAMES_6 = 6,
    NV_ENC_NUM_REF_FRAMES_7 = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_CAPS {
    NV_ENC_CAPS_NUM_MAX_BFRAMES = 0,
    NV_ENC_CAPS_SUPPORTED_RATECONTROL_MODES = 1,
    NV_ENC_CAPS_SUPPORT_FIELD_ENCODING = 2,
    NV_ENC_CAPS_SUPPORT_MONOCHROME = 3,
    NV_ENC_CAPS_SUPPORT_FMO = 4,
    NV_ENC_CAPS_SUPPORT_QPELMV = 5,
    NV_ENC_CAPS_SUPPORT_BDIRECT_MODE = 6,
    NV_ENC_CAPS_SUPPORT_CABAC = 7,
    NV_ENC_CAPS_SUPPORT_ADAPTIVE_TRANSFORM = 8,
    NV_ENC_CAPS_SUPPORT_STEREO_MVC = 9,
    NV_ENC_CAPS_NUM_MAX_TEMPORAL_LAYERS = 10,
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_PFRAMES = 11,
    NV_ENC_CAPS_SUPPORT_HIERARCHICAL_BFRAMES = 12,
    NV_ENC_CAPS_LEVEL_MAX = 13,
    NV_ENC_CAPS_LEVEL_MIN = 14,
    NV_ENC_CAPS_SEPARATE_COLOUR_PLANE = 15,
    NV_ENC_CAPS_WIDTH_MAX = 16,
    NV_ENC_CAPS_HEIGHT_MAX = 17,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_SVC = 18,
    NV_ENC_CAPS_SUPPORT_DYN_RES_CHANGE = 19,
    NV_ENC_CAPS_SUPPORT_DYN_BITRATE_CHANGE = 20,
    NV_ENC_CAPS_SUPPORT_DYN_FORCE_CONSTQP = 21,
    NV_ENC_CAPS_SUPPORT_DYN_RCMODE_CHANGE = 22,
    NV_ENC_CAPS_SUPPORT_SUBFRAME_READBACK = 23,
    NV_ENC_CAPS_SUPPORT_CONSTRAINED_ENCODING = 24,
    NV_ENC_CAPS_SUPPORT_INTRA_REFRESH = 25,
    NV_ENC_CAPS_SUPPORT_CUSTOM_VBV_BUF_SIZE = 26,
    NV_ENC_CAPS_SUPPORT_DYNAMIC_SLICE_MODE = 27,
    NV_ENC_CAPS_SUPPORT_REF_PIC_INVALIDATION = 28,
    NV_ENC_CAPS_PREPROC_SUPPORT = 29,
    NV_ENC_CAPS_ASYNC_ENCODE_SUPPORT = 30,
    NV_ENC_CAPS_MB_NUM_MAX = 31,
    NV_ENC_CAPS_MB_PER_SEC_MAX = 32,
    NV_ENC_CAPS_SUPPORT_YUV444_ENCODE = 33,
    NV_ENC_CAPS_SUPPORT_LOSSLESS_ENCODE = 34,
    NV_ENC_CAPS_SUPPORT_SAO = 35,
    NV_ENC_CAPS_SUPPORT_MEONLY_MODE = 36,
    NV_ENC_CAPS_SUPPORT_LOOKAHEAD = 37,
    NV_ENC_CAPS_SUPPORT_TEMPORAL_AQ = 38,
    NV_ENC_CAPS_SUPPORT_10BIT_ENCODE = 39,
    NV_ENC_CAPS_NUM_MAX_LTR_FRAMES = 40,
    NV_ENC_CAPS_SUPPORT_WEIGHTED_PREDICTION = 41,
    NV_ENC_CAPS_DYNAMIC_QUERY_ENCODER_CAPACITY = 42,
    NV_ENC_CAPS_SUPPORT_BFRAME_REF_MODE = 43,
    NV_ENC_CAPS_SUPPORT_EMPHASIS_LEVEL_MAP = 44,
    NV_ENC_CAPS_WIDTH_MIN = 45,
    NV_ENC_CAPS_HEIGHT_MIN = 46,
    NV_ENC_CAPS_SUPPORT_MULTIPLE_REF_FRAMES = 47,
    NV_ENC_CAPS_SUPPORT_ALPHA_LAYER_ENCODING = 48,
    NV_ENC_CAPS_NUM_ENCODER_ENGINES = 49,
    NV_ENC_CAPS_SINGLE_SLICE_INTRA_REFRESH = 50,
    NV_ENC_CAPS_EXPOSED_COUNT = 51,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_HEVC_CUSIZE {
    NV_ENC_HEVC_CUSIZE_AUTOSELECT = 0,
    NV_ENC_HEVC_CUSIZE_8x8 = 1,
    NV_ENC_HEVC_CUSIZE_16x16 = 2,
    NV_ENC_HEVC_CUSIZE_32x32 = 3,
    NV_ENC_HEVC_CUSIZE_64x64 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_AV1_PART_SIZE {
    NV_ENC_AV1_PART_SIZE_AUTOSELECT = 0,
    NV_ENC_AV1_PART_SIZE_4x4 = 1,
    NV_ENC_AV1_PART_SIZE_8x8 = 2,
    NV_ENC_AV1_PART_SIZE_16x16 = 3,
    NV_ENC_AV1_PART_SIZE_32x32 = 4,
    NV_ENC_AV1_PART_SIZE_64x64 = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_VUI_VIDEO_FORMAT {
    NV_ENC_VUI_VIDEO_FORMAT_COMPONENT = 0,
    NV_ENC_VUI_VIDEO_FORMAT_PAL = 1,
    NV_ENC_VUI_VIDEO_FORMAT_NTSC = 2,
    NV_ENC_VUI_VIDEO_FORMAT_SECAM = 3,
    NV_ENC_VUI_VIDEO_FORMAT_MAC = 4,
    NV_ENC_VUI_VIDEO_FORMAT_UNSPECIFIED = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_VUI_COLOR_PRIMARIES {
    NV_ENC_VUI_COLOR_PRIMARIES_UNDEFINED = 0,
    NV_ENC_VUI_COLOR_PRIMARIES_BT709 = 1,
    NV_ENC_VUI_COLOR_PRIMARIES_UNSPECIFIED = 2,
    NV_ENC_VUI_COLOR_PRIMARIES_RESERVED = 3,
    NV_ENC_VUI_COLOR_PRIMARIES_BT470M = 4,
    NV_ENC_VUI_COLOR_PRIMARIES_BT470BG = 5,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE170M = 6,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE240M = 7,
    NV_ENC_VUI_COLOR_PRIMARIES_FILM = 8,
    NV_ENC_VUI_COLOR_PRIMARIES_BT2020 = 9,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE428 = 10,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE431 = 11,
    NV_ENC_VUI_COLOR_PRIMARIES_SMPTE432 = 12,
    NV_ENC_VUI_COLOR_PRIMARIES_JEDEC_P22 = 22,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_VUI_TRANSFER_CHARACTERISTIC {
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_UNDEFINED = 0,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT709 = 1,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_UNSPECIFIED = 2,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_RESERVED = 3,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT470M = 4,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT470BG = 5,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE170M = 6,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE240M = 7,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LINEAR = 8,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LOG = 9,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_LOG_SQRT = 10,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_IEC61966_2_4 = 11,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT1361_ECG = 12,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SRGB = 13,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT2020_10 = 14,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_BT2020_12 = 15,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE2084 = 16,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_SMPTE428 = 17,
    NV_ENC_VUI_TRANSFER_CHARACTERISTIC_ARIB_STD_B67 = 18,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum _NV_ENC_VUI_MATRIX_COEFFS {
    NV_ENC_VUI_MATRIX_COEFFS_RGB = 0,
    NV_ENC_VUI_MATRIX_COEFFS_BT709 = 1,
    NV_ENC_VUI_MATRIX_COEFFS_UNSPECIFIED = 2,
    NV_ENC_VUI_MATRIX_COEFFS_RESERVED = 3,
    NV_ENC_VUI_MATRIX_COEFFS_FCC = 4,
    NV_ENC_VUI_MATRIX_COEFFS_BT470BG = 5,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE170M = 6,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE240M = 7,
    NV_ENC_VUI_MATRIX_COEFFS_YCGCO = 8,
    NV_ENC_VUI_MATRIX_COEFFS_BT2020_NCL = 9,
    NV_ENC_VUI_MATRIX_COEFFS_BT2020_CL = 10,
    NV_ENC_VUI_MATRIX_COEFFS_SMPTE2085 = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum NV_ENC_TUNING_INFO {
    NV_ENC_TUNING_INFO_UNDEFINED = 0,
    NV_ENC_TUNING_INFO_HIGH_QUALITY = 1,
    NV_ENC_TUNING_INFO_LOW_LATENCY = 2,
    NV_ENC_TUNING_INFO_ULTRA_LOW_LATENCY = 3,
    NV_ENC_TUNING_INFO_LOSSLESS = 4,
    NV_ENC_TUNING_INFO_COUNT = 5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_CONFIG {
    pub h264Config: NV_ENC_CONFIG_H264,
    pub hevcConfig: NV_ENC_CONFIG_HEVC,
    pub av1Config: NV_ENC_CONFIG_AV1,
    pub h264MeOnlyConfig: NV_ENC_CONFIG_H264_MEONLY,
    pub hevcMeOnlyConfig: NV_ENC_CONFIG_HEVC_MEONLY,
    pub reserved: [u32; 320usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_PIC_PARAMS_H264_EXT {
    pub mvcPicParams: NV_ENC_PIC_PARAMS_MVC,
    pub reserved1: [u32; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NV_ENC_CODEC_PIC_PARAMS {
    pub h264PicParams: NV_ENC_PIC_PARAMS_H264,
    pub hevcPicParams: NV_ENC_PIC_PARAMS_HEVC,
    pub av1PicParams: NV_ENC_PIC_PARAMS_AV1,
    pub reserved: [u32; 256usize],
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_1: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_3;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_HEVC_2: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_60;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_HEVC_MAIN: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_2: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_21: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_41: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1b;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_42: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_1;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_43: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_11;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_5: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_12;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_51: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_13;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_7: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_2;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_71: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_21;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_LEVEL_AV1_72: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_H264_22;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_AV1_0: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_LEVEL_AUTOSELECT;
}
impl _NV_ENC_LEVEL {
    pub const NV_ENC_TIER_AV1_1: _NV_ENC_LEVEL = _NV_ENC_LEVEL::NV_ENC_TIER_HEVC_HIGH;
}
impl Default for _NV_ENC_CAPS_PARAM {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_ENCODE_OUT_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CREATE_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CREATE_BITSTREAM_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CREATE_MV_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_RC_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RC_PARAMS {
    #[inline]
    pub fn enableMinQP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMinQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMaxQP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMaxQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableInitialRCQP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableInitialRCQP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAQ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitField1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLookahead(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLookahead(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIadapt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableBadapt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableBadapt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTemporalAQ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalAQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zeroReorderDelay(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zeroReorderDelay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNonRefP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableNonRefP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strictGOPTarget(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strictGOPTarget(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aqStrength(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aqStrength(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableMinQP: u32,
        enableMaxQP: u32,
        enableInitialRCQP: u32,
        enableAQ: u32,
        reservedBitField1: u32,
        enableLookahead: u32,
        disableIadapt: u32,
        disableBadapt: u32,
        enableTemporalAQ: u32,
        zeroReorderDelay: u32,
        enableNonRefP: u32,
        strictGOPTarget: u32,
        aqStrength: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableMinQP: u32 = unsafe { ::core::mem::transmute(enableMinQP) };
            enableMinQP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableMaxQP: u32 = unsafe { ::core::mem::transmute(enableMaxQP) };
            enableMaxQP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableInitialRCQP: u32 = unsafe { ::core::mem::transmute(enableInitialRCQP) };
            enableInitialRCQP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableAQ: u32 = unsafe { ::core::mem::transmute(enableAQ) };
            enableAQ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reservedBitField1: u32 = unsafe { ::core::mem::transmute(reservedBitField1) };
            reservedBitField1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLookahead: u32 = unsafe { ::core::mem::transmute(enableLookahead) };
            enableLookahead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableIadapt: u32 = unsafe { ::core::mem::transmute(disableIadapt) };
            disableIadapt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableBadapt: u32 = unsafe { ::core::mem::transmute(disableBadapt) };
            disableBadapt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableTemporalAQ: u32 = unsafe { ::core::mem::transmute(enableTemporalAQ) };
            enableTemporalAQ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zeroReorderDelay: u32 = unsafe { ::core::mem::transmute(zeroReorderDelay) };
            zeroReorderDelay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableNonRefP: u32 = unsafe { ::core::mem::transmute(enableNonRefP) };
            enableNonRefP as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strictGOPTarget: u32 = unsafe { ::core::mem::transmute(strictGOPTarget) };
            strictGOPTarget as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let aqStrength: u32 = unsafe { ::core::mem::transmute(aqStrength) };
            aqStrength as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NV_ENC_CLOCK_TIMESTAMP_SET {
    #[inline]
    pub fn countingType(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_countingType(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn discontinuityFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discontinuityFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cntDroppedFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cntDroppedFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn secondsValue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_secondsValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn minutesValue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_minutesValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn hoursValue(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hoursValue(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        countingType: u32,
        discontinuityFlag: u32,
        cntDroppedFrames: u32,
        nFrames: u32,
        secondsValue: u32,
        minutesValue: u32,
        hoursValue: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let countingType: u32 = unsafe { ::core::mem::transmute(countingType) };
            countingType as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let discontinuityFlag: u32 = unsafe { ::core::mem::transmute(discontinuityFlag) };
            discontinuityFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cntDroppedFrames: u32 = unsafe { ::core::mem::transmute(cntDroppedFrames) };
            cntDroppedFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let nFrames: u32 = unsafe { ::core::mem::transmute(nFrames) };
            nFrames as u64
        });
        __bindgen_bitfield_unit.set(11usize, 6u8, {
            let secondsValue: u32 = unsafe { ::core::mem::transmute(secondsValue) };
            secondsValue as u64
        });
        __bindgen_bitfield_unit.set(17usize, 6u8, {
            let minutesValue: u32 = unsafe { ::core::mem::transmute(minutesValue) };
            minutesValue as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let hoursValue: u32 = unsafe { ::core::mem::transmute(hoursValue) };
            hoursValue as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_TIME_CODE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CONFIG_H264_VUI_PARAMETERS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NVENC_EXTERNAL_ME_HINT_COUNTS_PER_BLOCKTYPE {
    #[inline]
    pub fn numCandsPerBlk16x16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk16x8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerBlk8x8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerBlk8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCandsPerSb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_numCandsPerSb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        numCandsPerBlk16x16: u32,
        numCandsPerBlk16x8: u32,
        numCandsPerBlk8x16: u32,
        numCandsPerBlk8x8: u32,
        numCandsPerSb: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let numCandsPerBlk16x16: u32 = unsafe { ::core::mem::transmute(numCandsPerBlk16x16) };
            numCandsPerBlk16x16 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let numCandsPerBlk16x8: u32 = unsafe { ::core::mem::transmute(numCandsPerBlk16x8) };
            numCandsPerBlk16x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numCandsPerBlk8x16: u32 = unsafe { ::core::mem::transmute(numCandsPerBlk8x16) };
            numCandsPerBlk8x16 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCandsPerBlk8x8: u32 = unsafe { ::core::mem::transmute(numCandsPerBlk8x8) };
            numCandsPerBlk8x8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let numCandsPerSb: u32 = unsafe { ::core::mem::transmute(numCandsPerSb) };
            numCandsPerSb as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NVENC_EXTERNAL_ME_HINT {
    #[inline]
    pub fn mvx(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn mvy(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn refidx(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn partType(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_partType(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lastofPart(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastofPart(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lastOfMB(&self) -> i32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lastOfMB(&mut self, val: i32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mvx: i32,
        mvy: i32,
        refidx: i32,
        dir: i32,
        partType: i32,
        lastofPart: i32,
        lastOfMB: i32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let mvx: u32 = unsafe { ::core::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(12usize, 10u8, {
            let mvy: u32 = unsafe { ::core::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let refidx: u32 = unsafe { ::core::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let dir: u32 = unsafe { ::core::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let partType: u32 = unsafe { ::core::mem::transmute(partType) };
            partType as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let lastofPart: u32 = unsafe { ::core::mem::transmute(lastofPart) };
            lastofPart as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lastOfMB: u32 = unsafe { ::core::mem::transmute(lastOfMB) };
            lastOfMB as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NVENC_EXTERNAL_ME_SB_HINT {
    #[inline]
    pub fn refidx(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_refidx(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn direction(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_direction(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bi(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_bi(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn partition_type(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_partition_type(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn x8(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_x8(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn last_of_cu(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_last_of_cu(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_of_sb(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_last_of_sb(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mvx(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_mvx(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn cu_size(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cu_size(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mvy(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_mvy(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn y8(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_y8(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        refidx: i16,
        direction: i16,
        bi: i16,
        partition_type: i16,
        x8: i16,
        last_of_cu: i16,
        last_of_sb: i16,
        reserved0: i16,
        mvx: i16,
        cu_size: i16,
        mvy: i16,
        y8: i16,
        reserved1: i16,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let refidx: u16 = unsafe { ::core::mem::transmute(refidx) };
            refidx as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let direction: u16 = unsafe { ::core::mem::transmute(direction) };
            direction as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bi: u16 = unsafe { ::core::mem::transmute(bi) };
            bi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let partition_type: u16 = unsafe { ::core::mem::transmute(partition_type) };
            partition_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let x8: u16 = unsafe { ::core::mem::transmute(x8) };
            x8 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let last_of_cu: u16 = unsafe { ::core::mem::transmute(last_of_cu) };
            last_of_cu as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let last_of_sb: u16 = unsafe { ::core::mem::transmute(last_of_sb) };
            last_of_sb as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved0: u16 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 14u8, {
            let mvx: u16 = unsafe { ::core::mem::transmute(mvx) };
            mvx as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cu_size: u16 = unsafe { ::core::mem::transmute(cu_size) };
            cu_size as u64
        });
        __bindgen_bitfield_unit.set(32usize, 12u8, {
            let mvy: u16 = unsafe { ::core::mem::transmute(mvy) };
            mvy as u64
        });
        __bindgen_bitfield_unit.set(44usize, 3u8, {
            let y8: u16 = unsafe { ::core::mem::transmute(y8) };
            y8 as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let reserved1: u16 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_H264 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264 {
    #[inline]
    pub fn enableTemporalSVC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTemporalSVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableStereoMVC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableStereoMVC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalPFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalPFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hierarchicalBFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hierarchicalBFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputFramePackingSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputFramePackingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableVFR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableVFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qpPrimeYZeroTransformBypassFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_qpPrimeYZeroTransformBypassFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSVCPrefixNalu(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSVCPrefixNalu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableScalabilityInfoSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableScalabilityInfoSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTimeCode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTimeCode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enableTemporalSVC: u32,
        enableStereoMVC: u32,
        hierarchicalPFrames: u32,
        hierarchicalBFrames: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        disableSPSPPS: u32,
        outputFramePackingSEI: u32,
        outputRecoveryPointSEI: u32,
        enableIntraRefresh: u32,
        enableConstrainedEncoding: u32,
        repeatSPSPPS: u32,
        enableVFR: u32,
        enableLTR: u32,
        qpPrimeYZeroTransformBypassFlag: u32,
        useConstrainedIntraPred: u32,
        enableFillerDataInsertion: u32,
        disableSVCPrefixNalu: u32,
        enableScalabilityInfoSEI: u32,
        singleSliceIntraRefresh: u32,
        enableTimeCode: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enableTemporalSVC: u32 = unsafe { ::core::mem::transmute(enableTemporalSVC) };
            enableTemporalSVC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableStereoMVC: u32 = unsafe { ::core::mem::transmute(enableStereoMVC) };
            enableStereoMVC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hierarchicalPFrames: u32 = unsafe { ::core::mem::transmute(hierarchicalPFrames) };
            hierarchicalPFrames as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hierarchicalBFrames: u32 = unsafe { ::core::mem::transmute(hierarchicalBFrames) };
            hierarchicalBFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::core::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::core::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outputAUD: u32 = unsafe { ::core::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::core::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let outputFramePackingSEI: u32 =
                unsafe { ::core::mem::transmute(outputFramePackingSEI) };
            outputFramePackingSEI as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::core::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::core::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::core::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::core::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let enableVFR: u32 = unsafe { ::core::mem::transmute(enableVFR) };
            enableVFR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableLTR: u32 = unsafe { ::core::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let qpPrimeYZeroTransformBypassFlag: u32 =
                unsafe { ::core::mem::transmute(qpPrimeYZeroTransformBypassFlag) };
            qpPrimeYZeroTransformBypassFlag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::core::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::core::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let disableSVCPrefixNalu: u32 = unsafe { ::core::mem::transmute(disableSVCPrefixNalu) };
            disableSVCPrefixNalu as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let enableScalabilityInfoSEI: u32 =
                unsafe { ::core::mem::transmute(enableScalabilityInfoSEI) };
            enableScalabilityInfoSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::core::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let enableTimeCode: u32 = unsafe { ::core::mem::transmute(enableTimeCode) };
            enableTimeCode as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_HEVC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_HEVC {
    #[inline]
    pub fn useConstrainedIntraPred(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useConstrainedIntraPred(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableDeblockAcrossSliceBoundary(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableDeblockAcrossSliceBoundary(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputBufferingPeriodSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputBufferingPeriodSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputPictureTimingSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputPictureTimingSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputAUD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableLTR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableLTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSPSPPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSPSPPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSPSPPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFillerDataInsertion(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFillerDataInsertion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableConstrainedEncoding(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableConstrainedEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableAlphaLayerEncoding(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableAlphaLayerEncoding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn singleSliceIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_singleSliceIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputRecoveryPointSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputRecoveryPointSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outputTimeCodeSEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputTimeCodeSEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        useConstrainedIntraPred: u32,
        disableDeblockAcrossSliceBoundary: u32,
        outputBufferingPeriodSEI: u32,
        outputPictureTimingSEI: u32,
        outputAUD: u32,
        enableLTR: u32,
        disableSPSPPS: u32,
        repeatSPSPPS: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        pixelBitDepthMinus8: u32,
        enableFillerDataInsertion: u32,
        enableConstrainedEncoding: u32,
        enableAlphaLayerEncoding: u32,
        singleSliceIntraRefresh: u32,
        outputRecoveryPointSEI: u32,
        outputTimeCodeSEI: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let useConstrainedIntraPred: u32 =
                unsafe { ::core::mem::transmute(useConstrainedIntraPred) };
            useConstrainedIntraPred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disableDeblockAcrossSliceBoundary: u32 =
                unsafe { ::core::mem::transmute(disableDeblockAcrossSliceBoundary) };
            disableDeblockAcrossSliceBoundary as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let outputBufferingPeriodSEI: u32 =
                unsafe { ::core::mem::transmute(outputBufferingPeriodSEI) };
            outputBufferingPeriodSEI as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let outputPictureTimingSEI: u32 =
                unsafe { ::core::mem::transmute(outputPictureTimingSEI) };
            outputPictureTimingSEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outputAUD: u32 = unsafe { ::core::mem::transmute(outputAUD) };
            outputAUD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableLTR: u32 = unsafe { ::core::mem::transmute(enableLTR) };
            enableLTR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disableSPSPPS: u32 = unsafe { ::core::mem::transmute(disableSPSPPS) };
            disableSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let repeatSPSPPS: u32 = unsafe { ::core::mem::transmute(repeatSPSPPS) };
            repeatSPSPPS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::core::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::core::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let pixelBitDepthMinus8: u32 = unsafe { ::core::mem::transmute(pixelBitDepthMinus8) };
            pixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let enableFillerDataInsertion: u32 =
                unsafe { ::core::mem::transmute(enableFillerDataInsertion) };
            enableFillerDataInsertion as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableConstrainedEncoding: u32 =
                unsafe { ::core::mem::transmute(enableConstrainedEncoding) };
            enableConstrainedEncoding as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let enableAlphaLayerEncoding: u32 =
                unsafe { ::core::mem::transmute(enableAlphaLayerEncoding) };
            enableAlphaLayerEncoding as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let singleSliceIntraRefresh: u32 =
                unsafe { ::core::mem::transmute(singleSliceIntraRefresh) };
            singleSliceIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let outputRecoveryPointSEI: u32 =
                unsafe { ::core::mem::transmute(outputRecoveryPointSEI) };
            outputRecoveryPointSEI as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let outputTimeCodeSEI: u32 = unsafe { ::core::mem::transmute(outputTimeCodeSEI) };
            outputTimeCodeSEI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl _NV_ENC_FILM_GRAIN_PARAMS_AV1 {
    #[inline]
    pub fn applyGrain(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_applyGrain(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaScalingFromLuma(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chromaScalingFromLuma(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlapFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlapFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clipToRestrictedRange(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clipToRestrictedRange(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn grainScalingMinus8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grainScalingMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn arCoeffLag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arCoeffLag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn numYPoints(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numYPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCbPoints(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCbPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn numCrPoints(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_numCrPoints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn arCoeffShiftMinus6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_arCoeffShiftMinus6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn grainScaleShift(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_grainScaleShift(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        applyGrain: u32,
        chromaScalingFromLuma: u32,
        overlapFlag: u32,
        clipToRestrictedRange: u32,
        grainScalingMinus8: u32,
        arCoeffLag: u32,
        numYPoints: u32,
        numCbPoints: u32,
        numCrPoints: u32,
        arCoeffShiftMinus6: u32,
        grainScaleShift: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let applyGrain: u32 = unsafe { ::core::mem::transmute(applyGrain) };
            applyGrain as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chromaScalingFromLuma: u32 =
                unsafe { ::core::mem::transmute(chromaScalingFromLuma) };
            chromaScalingFromLuma as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let overlapFlag: u32 = unsafe { ::core::mem::transmute(overlapFlag) };
            overlapFlag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let clipToRestrictedRange: u32 =
                unsafe { ::core::mem::transmute(clipToRestrictedRange) };
            clipToRestrictedRange as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let grainScalingMinus8: u32 = unsafe { ::core::mem::transmute(grainScalingMinus8) };
            grainScalingMinus8 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let arCoeffLag: u32 = unsafe { ::core::mem::transmute(arCoeffLag) };
            arCoeffLag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let numYPoints: u32 = unsafe { ::core::mem::transmute(numYPoints) };
            numYPoints as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let numCbPoints: u32 = unsafe { ::core::mem::transmute(numCbPoints) };
            numCbPoints as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let numCrPoints: u32 = unsafe { ::core::mem::transmute(numCrPoints) };
            numCrPoints as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let arCoeffShiftMinus6: u32 = unsafe { ::core::mem::transmute(arCoeffShiftMinus6) };
            arCoeffShiftMinus6 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let grainScaleShift: u32 = unsafe { ::core::mem::transmute(grainScaleShift) };
            grainScaleShift as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_AV1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_AV1 {
    #[inline]
    pub fn outputAnnexBFormat(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outputAnnexBFormat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableTimingInfo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableTimingInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableDecoderModelInfo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableDecoderModelInfo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFrameIdNumbers(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFrameIdNumbers(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableSeqHdr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableSeqHdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeatSeqHdr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeatSeqHdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableIntraRefresh(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableIntraRefresh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chromaFormatIDC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chromaFormatIDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn enableBitstreamPadding(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableBitstreamPadding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableCustomTileConfig(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableCustomTileConfig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableFilmGrainParams(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableFilmGrainParams(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inputPixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_inputPixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pixelBitDepthMinus8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixelBitDepthMinus8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        outputAnnexBFormat: u32,
        enableTimingInfo: u32,
        enableDecoderModelInfo: u32,
        enableFrameIdNumbers: u32,
        disableSeqHdr: u32,
        repeatSeqHdr: u32,
        enableIntraRefresh: u32,
        chromaFormatIDC: u32,
        enableBitstreamPadding: u32,
        enableCustomTileConfig: u32,
        enableFilmGrainParams: u32,
        inputPixelBitDepthMinus8: u32,
        pixelBitDepthMinus8: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let outputAnnexBFormat: u32 = unsafe { ::core::mem::transmute(outputAnnexBFormat) };
            outputAnnexBFormat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableTimingInfo: u32 = unsafe { ::core::mem::transmute(enableTimingInfo) };
            enableTimingInfo as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableDecoderModelInfo: u32 =
                unsafe { ::core::mem::transmute(enableDecoderModelInfo) };
            enableDecoderModelInfo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableFrameIdNumbers: u32 = unsafe { ::core::mem::transmute(enableFrameIdNumbers) };
            enableFrameIdNumbers as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableSeqHdr: u32 = unsafe { ::core::mem::transmute(disableSeqHdr) };
            disableSeqHdr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let repeatSeqHdr: u32 = unsafe { ::core::mem::transmute(repeatSeqHdr) };
            repeatSeqHdr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let enableIntraRefresh: u32 = unsafe { ::core::mem::transmute(enableIntraRefresh) };
            enableIntraRefresh as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let chromaFormatIDC: u32 = unsafe { ::core::mem::transmute(chromaFormatIDC) };
            chromaFormatIDC as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let enableBitstreamPadding: u32 =
                unsafe { ::core::mem::transmute(enableBitstreamPadding) };
            enableBitstreamPadding as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enableCustomTileConfig: u32 =
                unsafe { ::core::mem::transmute(enableCustomTileConfig) };
            enableCustomTileConfig as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let enableFilmGrainParams: u32 =
                unsafe { ::core::mem::transmute(enableFilmGrainParams) };
            enableFilmGrainParams as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let inputPixelBitDepthMinus8: u32 =
                unsafe { ::core::mem::transmute(inputPixelBitDepthMinus8) };
            inputPixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let pixelBitDepthMinus8: u32 = unsafe { ::core::mem::transmute(pixelBitDepthMinus8) };
            pixelBitDepthMinus8 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_H264_MEONLY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_CONFIG_H264_MEONLY {
    #[inline]
    pub fn disablePartition16x16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition16x8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition16x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disablePartition8x8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disablePartition8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disableIntraSearch(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disableIntraSearch(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bStereoEnable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bStereoEnable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disablePartition16x16: u32,
        disablePartition8x16: u32,
        disablePartition16x8: u32,
        disablePartition8x8: u32,
        disableIntraSearch: u32,
        bStereoEnable: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disablePartition16x16: u32 =
                unsafe { ::core::mem::transmute(disablePartition16x16) };
            disablePartition16x16 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disablePartition8x16: u32 = unsafe { ::core::mem::transmute(disablePartition8x16) };
            disablePartition8x16 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disablePartition16x8: u32 = unsafe { ::core::mem::transmute(disablePartition16x8) };
            disablePartition16x8 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disablePartition8x8: u32 = unsafe { ::core::mem::transmute(disablePartition8x8) };
            disablePartition8x8 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disableIntraSearch: u32 = unsafe { ::core::mem::transmute(disableIntraSearch) };
            disableIntraSearch as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bStereoEnable: u32 = unsafe { ::core::mem::transmute(bStereoEnable) };
            bStereoEnable as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CONFIG_HEVC_MEONLY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CODEC_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_INITIALIZE_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_INITIALIZE_PARAMS {
    #[inline]
    pub fn reportSliceOffsets(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reportSliceOffsets(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableSubFrameWrite(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableSubFrameWrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableExternalMEHints(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableExternalMEHints(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableMEOnlyMode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableMEOnlyMode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableWeightedPrediction(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableWeightedPrediction(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableOutputInVidmem(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableOutputInVidmem(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reportSliceOffsets: u32,
        enableSubFrameWrite: u32,
        enableExternalMEHints: u32,
        enableMEOnlyMode: u32,
        enableWeightedPrediction: u32,
        enableOutputInVidmem: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reportSliceOffsets: u32 = unsafe { ::core::mem::transmute(reportSliceOffsets) };
            reportSliceOffsets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enableSubFrameWrite: u32 = unsafe { ::core::mem::transmute(enableSubFrameWrite) };
            enableSubFrameWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enableExternalMEHints: u32 =
                unsafe { ::core::mem::transmute(enableExternalMEHints) };
            enableExternalMEHints as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enableMEOnlyMode: u32 = unsafe { ::core::mem::transmute(enableMEOnlyMode) };
            enableMEOnlyMode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enableWeightedPrediction: u32 =
                unsafe { ::core::mem::transmute(enableWeightedPrediction) };
            enableWeightedPrediction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enableOutputInVidmem: u32 = unsafe { ::core::mem::transmute(enableOutputInVidmem) };
            enableOutputInVidmem as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_RECONFIGURE_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_RECONFIGURE_PARAMS {
    #[inline]
    pub fn resetEncoder(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resetEncoder(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceIDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceIDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resetEncoder: u32,
        forceIDR: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resetEncoder: u32 = unsafe { ::core::mem::transmute(resetEncoder) };
            resetEncoder as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceIDR: u32 = unsafe { ::core::mem::transmute(forceIDR) };
            forceIDR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_PRESET_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_PIC_PARAMS_MVC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_PIC_PARAMS_H264_EXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_SEI_PAYLOAD {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_PIC_PARAMS_H264 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_H264 {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::core::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::core::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::core::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::core::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_PIC_PARAMS_HEVC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_HEVC {
    #[inline]
    pub fn constrainedFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrainedFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sliceModeDataUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sliceModeDataUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrMarkFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrMarkFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrUseFrames(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrUseFrames(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constrainedFrame: u32,
        sliceModeDataUpdate: u32,
        ltrMarkFrame: u32,
        ltrUseFrames: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constrainedFrame: u32 = unsafe { ::core::mem::transmute(constrainedFrame) };
            constrainedFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sliceModeDataUpdate: u32 = unsafe { ::core::mem::transmute(sliceModeDataUpdate) };
            sliceModeDataUpdate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ltrMarkFrame: u32 = unsafe { ::core::mem::transmute(ltrMarkFrame) };
            ltrMarkFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ltrUseFrames: u32 = unsafe { ::core::mem::transmute(ltrUseFrames) };
            ltrUseFrames as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_PIC_PARAMS_AV1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_PIC_PARAMS_AV1 {
    #[inline]
    pub fn goldenFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_goldenFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn arfFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arfFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn arf2FrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arf2FrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bwdFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bwdFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlayFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overlayFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn showExistingFrameFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_showExistingFrameFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errorResilientModeFlag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_errorResilientModeFlag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tileConfigUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tileConfigUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableCustomTileConfig(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enableCustomTileConfig(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filmGrainParamsUpdate(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filmGrainParamsUpdate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        goldenFrameFlag: u32,
        arfFrameFlag: u32,
        arf2FrameFlag: u32,
        bwdFrameFlag: u32,
        overlayFrameFlag: u32,
        showExistingFrameFlag: u32,
        errorResilientModeFlag: u32,
        tileConfigUpdate: u32,
        enableCustomTileConfig: u32,
        filmGrainParamsUpdate: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let goldenFrameFlag: u32 = unsafe { ::core::mem::transmute(goldenFrameFlag) };
            goldenFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let arfFrameFlag: u32 = unsafe { ::core::mem::transmute(arfFrameFlag) };
            arfFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let arf2FrameFlag: u32 = unsafe { ::core::mem::transmute(arf2FrameFlag) };
            arf2FrameFlag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bwdFrameFlag: u32 = unsafe { ::core::mem::transmute(bwdFrameFlag) };
            bwdFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let overlayFrameFlag: u32 = unsafe { ::core::mem::transmute(overlayFrameFlag) };
            overlayFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let showExistingFrameFlag: u32 =
                unsafe { ::core::mem::transmute(showExistingFrameFlag) };
            showExistingFrameFlag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let errorResilientModeFlag: u32 =
                unsafe { ::core::mem::transmute(errorResilientModeFlag) };
            errorResilientModeFlag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tileConfigUpdate: u32 = unsafe { ::core::mem::transmute(tileConfigUpdate) };
            tileConfigUpdate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enableCustomTileConfig: u32 =
                unsafe { ::core::mem::transmute(enableCustomTileConfig) };
            enableCustomTileConfig as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let filmGrainParamsUpdate: u32 =
                unsafe { ::core::mem::transmute(filmGrainParamsUpdate) };
            filmGrainParamsUpdate as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_CODEC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_PIC_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_MEONLY_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_LOCK_BITSTREAM {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_BITSTREAM {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn getRCStats(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_getRCStats(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        ltrFrame: u32,
        getRCStats: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::core::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::core::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let getRCStats: u32 = unsafe { ::core::mem::transmute(getRCStats) };
            getRCStats as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_LOCK_INPUT_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_LOCK_INPUT_BUFFER {
    #[inline]
    pub fn doNotWait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_doNotWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doNotWait: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let doNotWait: u32 = unsafe { ::core::mem::transmute(doNotWait) };
            doNotWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_MAP_INPUT_RESOURCE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_FENCE_POINT_D3D12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_FENCE_POINT_D3D12 {
    #[inline]
    pub fn bWait(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bWait(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bSignal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bSignal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitField(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitField(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bWait: u32,
        bSignal: u32,
        reservedBitField: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bWait: u32 = unsafe { ::core::mem::transmute(bWait) };
            bWait as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bSignal: u32 = unsafe { ::core::mem::transmute(bSignal) };
            bSignal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reservedBitField: u32 = unsafe { ::core::mem::transmute(reservedBitField) };
            reservedBitField as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_INPUT_RESOURCE_D3D12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_OUTPUT_RESOURCE_D3D12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_REGISTER_RESOURCE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_STAT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _NV_ENC_STAT {
    #[inline]
    pub fn ltrFrame(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrFrame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservedBitFields(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reservedBitFields(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ltrFrame: u32,
        reservedBitFields: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ltrFrame: u32 = unsafe { ::core::mem::transmute(ltrFrame) };
            ltrFrame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reservedBitFields: u32 = unsafe { ::core::mem::transmute(reservedBitFields) };
            reservedBitFields as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _NV_ENC_SEQUENCE_PARAM_PAYLOAD {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_EVENT_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENC_OPEN_ENCODE_SESSIONEX_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _NV_ENCODE_API_FUNCTION_LIST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub use self::_NVENCSTATUS as NVENCSTATUS;
pub use self::_NV_ENC_AV1_PART_SIZE as NV_ENC_AV1_PART_SIZE;
pub use self::_NV_ENC_BFRAME_REF_MODE as NV_ENC_BFRAME_REF_MODE;
pub use self::_NV_ENC_BUFFER_FORMAT as NV_ENC_BUFFER_FORMAT;
pub use self::_NV_ENC_BUFFER_USAGE as NV_ENC_BUFFER_USAGE;
pub use self::_NV_ENC_CAPS as NV_ENC_CAPS;
pub use self::_NV_ENC_DEVICE_TYPE as NV_ENC_DEVICE_TYPE;
pub use self::_NV_ENC_DISPLAY_PIC_STRUCT as NV_ENC_DISPLAY_PIC_STRUCT;
pub use self::_NV_ENC_EMPHASIS_MAP_LEVEL as NV_ENC_EMPHASIS_MAP_LEVEL;
pub use self::_NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE as NV_ENC_H264_ADAPTIVE_TRANSFORM_MODE;
pub use self::_NV_ENC_H264_BDIRECT_MODE as NV_ENC_H264_BDIRECT_MODE;
pub use self::_NV_ENC_H264_ENTROPY_CODING_MODE as NV_ENC_H264_ENTROPY_CODING_MODE;
pub use self::_NV_ENC_H264_FMO_MODE as NV_ENC_H264_FMO_MODE;
pub use self::_NV_ENC_HEVC_CUSIZE as NV_ENC_HEVC_CUSIZE;
pub use self::_NV_ENC_INPUT_RESOURCE_TYPE as NV_ENC_INPUT_RESOURCE_TYPE;
pub use self::_NV_ENC_LEVEL as NV_ENC_LEVEL;
pub use self::_NV_ENC_MEMORY_HEAP as NV_ENC_MEMORY_HEAP;
pub use self::_NV_ENC_MULTI_PASS as NV_ENC_MULTI_PASS;
pub use self::_NV_ENC_MV_PRECISION as NV_ENC_MV_PRECISION;
pub use self::_NV_ENC_NUM_REF_FRAMES as NV_ENC_NUM_REF_FRAMES;
pub use self::_NV_ENC_PARAMS_FRAME_FIELD_MODE as NV_ENC_PARAMS_FRAME_FIELD_MODE;
pub use self::_NV_ENC_PARAMS_RC_MODE as NV_ENC_PARAMS_RC_MODE;
pub use self::_NV_ENC_PIC_FLAGS as NV_ENC_PIC_FLAGS;
pub use self::_NV_ENC_PIC_STRUCT as NV_ENC_PIC_STRUCT;
pub use self::_NV_ENC_PIC_TYPE as NV_ENC_PIC_TYPE;
pub use self::_NV_ENC_QP_MAP_MODE as NV_ENC_QP_MAP_MODE;
pub use self::_NV_ENC_STEREO_PACKING_MODE as NV_ENC_STEREO_PACKING_MODE;
pub use self::_NV_ENC_VUI_COLOR_PRIMARIES as NV_ENC_VUI_COLOR_PRIMARIES;
pub use self::_NV_ENC_VUI_MATRIX_COEFFS as NV_ENC_VUI_MATRIX_COEFFS;
pub use self::_NV_ENC_VUI_TRANSFER_CHARACTERISTIC as NV_ENC_VUI_TRANSFER_CHARACTERISTIC;
pub use self::_NV_ENC_VUI_VIDEO_FORMAT as NV_ENC_VUI_VIDEO_FORMAT;
extern "C" {
    pub static NV_ENC_CODEC_H264_GUID: GUID;
    pub static NV_ENC_CODEC_HEVC_GUID: GUID;
    pub static NV_ENC_CODEC_AV1_GUID: GUID;
    pub static NV_ENC_CODEC_PROFILE_AUTOSELECT_GUID: GUID;
    pub static NV_ENC_H264_PROFILE_BASELINE_GUID: GUID;
    pub static NV_ENC_H264_PROFILE_MAIN_GUID: GUID;
    pub static NV_ENC_H264_PROFILE_HIGH_GUID: GUID;
    pub static NV_ENC_H264_PROFILE_HIGH_444_GUID: GUID;
    pub static NV_ENC_H264_PROFILE_STEREO_GUID: GUID;
    pub static NV_ENC_H264_PROFILE_PROGRESSIVE_HIGH_GUID: GUID;
    pub static NV_ENC_H264_PROFILE_CONSTRAINED_HIGH_GUID: GUID;
    pub static NV_ENC_HEVC_PROFILE_MAIN_GUID: GUID;
    pub static NV_ENC_HEVC_PROFILE_MAIN10_GUID: GUID;
    pub static NV_ENC_HEVC_PROFILE_FREXT_GUID: GUID;
    pub static NV_ENC_AV1_PROFILE_MAIN_GUID: GUID;
    pub static NV_ENC_PRESET_DEFAULT_GUID: GUID;
    pub static NV_ENC_PRESET_HP_GUID: GUID;
    pub static NV_ENC_PRESET_HQ_GUID: GUID;
    pub static NV_ENC_PRESET_BD_GUID: GUID;
    pub static NV_ENC_PRESET_LOW_LATENCY_DEFAULT_GUID: GUID;
    pub static NV_ENC_PRESET_LOW_LATENCY_HQ_GUID: GUID;
    pub static NV_ENC_PRESET_LOW_LATENCY_HP_GUID: GUID;
    pub static NV_ENC_PRESET_LOSSLESS_DEFAULT_GUID: GUID;
    pub static NV_ENC_PRESET_LOSSLESS_HP_GUID: GUID;
    pub static NV_ENC_PRESET_P1_GUID: GUID;
    pub static NV_ENC_PRESET_P2_GUID: GUID;
    pub static NV_ENC_PRESET_P3_GUID: GUID;
    pub static NV_ENC_PRESET_P4_GUID: GUID;
    pub static NV_ENC_PRESET_P5_GUID: GUID;
    pub static NV_ENC_PRESET_P6_GUID: GUID;
    pub static NV_ENC_PRESET_P7_GUID: GUID;
    #[must_use]
    pub fn NvEncOpenEncodeSession(
        device: *mut ::core::ffi::c_void,
        deviceType: u32,
        encoder: *mut *mut ::core::ffi::c_void,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeGUIDCount(
        encoder: *mut ::core::ffi::c_void,
        encodeGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeGUIDs(
        encoder: *mut ::core::ffi::c_void,
        GUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeProfileGUIDCount(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        encodeProfileGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeProfileGUIDs(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        profileGUIDs: *mut GUID,
        guidArraySize: u32,
        GUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetInputFormatCount(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetInputFormats(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        inputFmts: *mut NV_ENC_BUFFER_FORMAT,
        inputFmtArraySize: u32,
        inputFmtCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeCaps(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        capsParam: *mut NV_ENC_CAPS_PARAM,
        capsVal: *mut ::core::ffi::c_int,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodePresetCount(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodePresetGUIDs(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUIDs: *mut GUID,
        guidArraySize: u32,
        encodePresetGUIDCount: *mut u32,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodePresetConfig(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodePresetConfigEx(
        encoder: *mut ::core::ffi::c_void,
        encodeGUID: GUID,
        presetGUID: GUID,
        tuningInfo: NV_ENC_TUNING_INFO,
        presetConfig: *mut NV_ENC_PRESET_CONFIG,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncInitializeEncoder(
        encoder: *mut ::core::ffi::c_void,
        createEncodeParams: *mut NV_ENC_INITIALIZE_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncCreateInputBuffer(
        encoder: *mut ::core::ffi::c_void,
        createInputBufferParams: *mut NV_ENC_CREATE_INPUT_BUFFER,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncDestroyInputBuffer(
        encoder: *mut ::core::ffi::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncSetIOCudaStreams(
        encoder: *mut ::core::ffi::c_void,
        inputStream: NV_ENC_CUSTREAM_PTR,
        outputStream: NV_ENC_CUSTREAM_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncCreateBitstreamBuffer(
        encoder: *mut ::core::ffi::c_void,
        createBitstreamBufferParams: *mut NV_ENC_CREATE_BITSTREAM_BUFFER,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncDestroyBitstreamBuffer(
        encoder: *mut ::core::ffi::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncEncodePicture(
        encoder: *mut ::core::ffi::c_void,
        encodePicParams: *mut NV_ENC_PIC_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncLockBitstream(
        encoder: *mut ::core::ffi::c_void,
        lockBitstreamBufferParams: *mut NV_ENC_LOCK_BITSTREAM,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnlockBitstream(
        encoder: *mut ::core::ffi::c_void,
        bitstreamBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncLockInputBuffer(
        encoder: *mut ::core::ffi::c_void,
        lockInputBufferParams: *mut NV_ENC_LOCK_INPUT_BUFFER,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnlockInputBuffer(
        encoder: *mut ::core::ffi::c_void,
        inputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetEncodeStats(
        encoder: *mut ::core::ffi::c_void,
        encodeStats: *mut NV_ENC_STAT,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetSequenceParams(
        encoder: *mut ::core::ffi::c_void,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncGetSequenceParamEx(
        encoder: *mut ::core::ffi::c_void,
        encInitParams: *mut NV_ENC_INITIALIZE_PARAMS,
        sequenceParamPayload: *mut NV_ENC_SEQUENCE_PARAM_PAYLOAD,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncRegisterAsyncEvent(
        encoder: *mut ::core::ffi::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnregisterAsyncEvent(
        encoder: *mut ::core::ffi::c_void,
        eventParams: *mut NV_ENC_EVENT_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncMapInputResource(
        encoder: *mut ::core::ffi::c_void,
        mapInputResParams: *mut NV_ENC_MAP_INPUT_RESOURCE,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnmapInputResource(
        encoder: *mut ::core::ffi::c_void,
        mappedInputBuffer: NV_ENC_INPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncDestroyEncoder(encoder: *mut ::core::ffi::c_void) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncInvalidateRefFrames(
        encoder: *mut ::core::ffi::c_void,
        invalidRefFrameTimeStamp: u64,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncOpenEncodeSessionEx(
        openSessionExParams: *mut NV_ENC_OPEN_ENCODE_SESSION_EX_PARAMS,
        encoder: *mut *mut ::core::ffi::c_void,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncRegisterResource(
        encoder: *mut ::core::ffi::c_void,
        registerResParams: *mut NV_ENC_REGISTER_RESOURCE,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncUnregisterResource(
        encoder: *mut ::core::ffi::c_void,
        registeredResource: NV_ENC_REGISTERED_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncReconfigureEncoder(
        encoder: *mut ::core::ffi::c_void,
        reInitEncodeParams: *mut NV_ENC_RECONFIGURE_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncCreateMVBuffer(
        encoder: *mut ::core::ffi::c_void,
        createMVBufferParams: *mut NV_ENC_CREATE_MV_BUFFER,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncDestroyMVBuffer(
        encoder: *mut ::core::ffi::c_void,
        mvBuffer: NV_ENC_OUTPUT_PTR,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncRunMotionEstimationOnly(
        encoder: *mut ::core::ffi::c_void,
        meOnlyParams: *mut NV_ENC_MEONLY_PARAMS,
    ) -> NVENCSTATUS;
    #[must_use]
    pub fn NvEncodeAPIGetMaxSupportedVersion(version: *mut u32) -> NVENCSTATUS;
    pub fn NvEncGetLastErrorString(encoder: *mut ::core::ffi::c_void)
        -> *const ::core::ffi::c_char;
    #[must_use]
    pub fn NvEncodeAPICreateInstance(functionList: *mut NV_ENCODE_API_FUNCTION_LIST)
        -> NVENCSTATUS;
}
