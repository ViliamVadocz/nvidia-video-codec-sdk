/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MAX_CLOCK_TS: u32 = 3;
pub type CUvideosource = *mut ::core::ffi::c_void;
pub type CUvideoparser = *mut ::core::ffi::c_void;
pub type CUvideotimestamp = ::core::ffi::c_longlong;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum cudaVideoState {
    cudaVideoState_Error = -1,
    cudaVideoState_Stopped = 0,
    cudaVideoState_Started = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum cudaAudioCodec {
    cudaAudioCodec_MPEG1 = 0,
    cudaAudioCodec_MPEG2 = 1,
    cudaAudioCodec_MP3 = 2,
    cudaAudioCodec_AC3 = 3,
    cudaAudioCodec_LPCM = 4,
    cudaAudioCodec_AAC = 5,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEVCTIMECODESET {
    pub time_offset_value: ::core::ffi::c_uint,
    pub n_frames: ::core::ffi::c_ushort,
    pub clock_timestamp_flag: ::core::ffi::c_uchar,
    pub units_field_based_flag: ::core::ffi::c_uchar,
    pub counting_type: ::core::ffi::c_uchar,
    pub full_timestamp_flag: ::core::ffi::c_uchar,
    pub discontinuity_flag: ::core::ffi::c_uchar,
    pub cnt_dropped_flag: ::core::ffi::c_uchar,
    pub seconds_value: ::core::ffi::c_uchar,
    pub minutes_value: ::core::ffi::c_uchar,
    pub hours_value: ::core::ffi::c_uchar,
    pub seconds_flag: ::core::ffi::c_uchar,
    pub minutes_flag: ::core::ffi::c_uchar,
    pub hours_flag: ::core::ffi::c_uchar,
    pub time_offset_length: ::core::ffi::c_uchar,
    pub reserved: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout__HEVCTIMECODESET() {
    const UNINIT: ::core::mem::MaybeUninit<_HEVCTIMECODESET> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_HEVCTIMECODESET>(),
        20usize,
        concat!("Size of: ", stringify!(_HEVCTIMECODESET))
    );
    assert_eq!(
        ::core::mem::align_of::<_HEVCTIMECODESET>(),
        4usize,
        concat!("Alignment of ", stringify!(_HEVCTIMECODESET))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_offset_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(time_offset_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_frames) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(n_frames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock_timestamp_flag) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(clock_timestamp_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).units_field_based_flag) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(units_field_based_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counting_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(counting_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).full_timestamp_flag) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(full_timestamp_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).discontinuity_flag) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(discontinuity_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cnt_dropped_flag) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(cnt_dropped_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seconds_value) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(seconds_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minutes_value) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(minutes_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hours_value) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(hours_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seconds_flag) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(seconds_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minutes_flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(minutes_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hours_flag) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(hours_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_offset_length) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(time_offset_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCTIMECODESET),
            "::",
            stringify!(reserved)
        )
    );
}
pub type HEVCTIMECODESET = _HEVCTIMECODESET;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _HEVCSEITIMECODE {
    pub time_code_set: [HEVCTIMECODESET; 3usize],
    pub num_clock_ts: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout__HEVCSEITIMECODE() {
    const UNINIT: ::core::mem::MaybeUninit<_HEVCSEITIMECODE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_HEVCSEITIMECODE>(),
        64usize,
        concat!("Size of: ", stringify!(_HEVCSEITIMECODE))
    );
    assert_eq!(
        ::core::mem::align_of::<_HEVCSEITIMECODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_HEVCSEITIMECODE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_code_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCSEITIMECODE),
            "::",
            stringify!(time_code_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_clock_ts) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEVCSEITIMECODE),
            "::",
            stringify!(num_clock_ts)
        )
    );
}
pub type HEVCSEITIMECODE = _HEVCSEITIMECODE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUSEIMESSAGE {
    pub sei_message_type: ::core::ffi::c_uchar,
    pub reserved: [::core::ffi::c_uchar; 3usize],
    pub sei_message_size: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout__CUSEIMESSAGE() {
    const UNINIT: ::core::mem::MaybeUninit<_CUSEIMESSAGE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CUSEIMESSAGE>(),
        8usize,
        concat!("Size of: ", stringify!(_CUSEIMESSAGE))
    );
    assert_eq!(
        ::core::mem::align_of::<_CUSEIMESSAGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_CUSEIMESSAGE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sei_message_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUSEIMESSAGE),
            "::",
            stringify!(sei_message_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUSEIMESSAGE),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sei_message_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUSEIMESSAGE),
            "::",
            stringify!(sei_message_size)
        )
    );
}
pub type CUSEIMESSAGE = _CUSEIMESSAGE;
#[repr(C)]
pub struct CUVIDEOFORMAT {
    pub codec: cudaVideoCodec,
    pub frame_rate: CUVIDEOFORMAT__bindgen_ty_1,
    pub progressive_sequence: ::core::ffi::c_uchar,
    pub bit_depth_luma_minus8: ::core::ffi::c_uchar,
    pub bit_depth_chroma_minus8: ::core::ffi::c_uchar,
    pub min_num_decode_surfaces: ::core::ffi::c_uchar,
    pub coded_width: ::core::ffi::c_uint,
    pub coded_height: ::core::ffi::c_uint,
    pub display_area: CUVIDEOFORMAT__bindgen_ty_2,
    pub chroma_format: cudaVideoChromaFormat,
    pub bitrate: ::core::ffi::c_uint,
    pub display_aspect_ratio: CUVIDEOFORMAT__bindgen_ty_3,
    pub video_signal_description: CUVIDEOFORMAT__bindgen_ty_4,
    pub seqhdr_data_length: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_1 {
    pub numerator: ::core::ffi::c_uint,
    pub denominator: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDEOFORMAT__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_1),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_1),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_2 {
    pub left: ::core::ffi::c_int,
    pub top: ::core::ffi::c_int,
    pub right: ::core::ffi::c_int,
    pub bottom: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDEOFORMAT__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_2),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_2),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_2),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_2),
            "::",
            stringify!(bottom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_3 {
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDEOFORMAT__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_3),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDEOFORMAT__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub color_primaries: ::core::ffi::c_uchar,
    pub transfer_characteristics: ::core::ffi::c_uchar,
    pub matrix_coefficients: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDEOFORMAT__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDEOFORMAT__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDEOFORMAT__bindgen_ty_4>(),
        1usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_4),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transfer_characteristics) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_4),
            "::",
            stringify!(transfer_characteristics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix_coefficients) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT__bindgen_ty_4),
            "::",
            stringify!(matrix_coefficients)
        )
    );
}
impl CUVIDEOFORMAT__bindgen_ty_4 {
    #[inline]
    pub fn video_format(&self) -> ::core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_video_format(&mut self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn video_full_range_flag(&self) -> ::core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_video_full_range_flag(&mut self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_zero_bits(&self) -> ::core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved_zero_bits(&mut self, val: ::core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        video_format: ::core::ffi::c_uchar,
        video_full_range_flag: ::core::ffi::c_uchar,
        reserved_zero_bits: ::core::ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let video_format: u8 = unsafe { ::core::mem::transmute(video_format) };
            video_format as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let video_full_range_flag: u8 =
                unsafe { ::core::mem::transmute(video_full_range_flag) };
            video_full_range_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved_zero_bits: u8 = unsafe { ::core::mem::transmute(reserved_zero_bits) };
            reserved_zero_bits as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMAT() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDEOFORMAT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDEOFORMAT>(),
        64usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMAT))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDEOFORMAT>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMAT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).progressive_sequence) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(progressive_sequence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_depth_luma_minus8) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(bit_depth_luma_minus8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_depth_chroma_minus8) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(bit_depth_chroma_minus8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_num_decode_surfaces) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(min_num_decode_surfaces)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coded_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coded_height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display_area) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(display_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chroma_format) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(chroma_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display_aspect_ratio) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(display_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).video_signal_description) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(video_signal_description)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seqhdr_data_length) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMAT),
            "::",
            stringify!(seqhdr_data_length)
        )
    );
}
impl Default for CUVIDEOFORMAT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct CUVIDOPERATINGPOINTINFO {
    pub codec: cudaVideoCodec,
    pub __bindgen_anon_1: CUVIDOPERATINGPOINTINFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUVIDOPERATINGPOINTINFO__bindgen_ty_1 {
    pub av1: CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1,
    pub CodecReserved: [::core::ffi::c_uchar; 1024usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1 {
    pub operating_points_cnt: ::core::ffi::c_uchar,
    pub reserved24_bits: [::core::ffi::c_uchar; 3usize],
    pub operating_points_idc: [::core::ffi::c_ushort; 32usize],
}
#[test]
fn bindgen_test_layout_CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1>(),
        68usize,
        concat!(
            "Size of: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operating_points_cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(operating_points_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved24_bits) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reserved24_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operating_points_idc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(operating_points_idc)
        )
    );
}
#[test]
fn bindgen_test_layout_CUVIDOPERATINGPOINTINFO__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDOPERATINGPOINTINFO__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1>(),
        1024usize,
        concat!(
            "Size of: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDOPERATINGPOINTINFO__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).av1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1),
            "::",
            stringify!(av1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CodecReserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO__bindgen_ty_1),
            "::",
            stringify!(CodecReserved)
        )
    );
}
impl Default for CUVIDOPERATINGPOINTINFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUVIDOPERATINGPOINTINFO() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDOPERATINGPOINTINFO> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDOPERATINGPOINTINFO>(),
        1028usize,
        concat!("Size of: ", stringify!(CUVIDOPERATINGPOINTINFO))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDOPERATINGPOINTINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDOPERATINGPOINTINFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDOPERATINGPOINTINFO),
            "::",
            stringify!(codec)
        )
    );
}
impl Default for CUVIDOPERATINGPOINTINFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUVIDSEIMESSAGEINFO {
    pub pSEIData: *mut ::core::ffi::c_void,
    pub pSEIMessage: *mut CUSEIMESSAGE,
    pub sei_message_count: ::core::ffi::c_uint,
    pub picIdx: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout__CUVIDSEIMESSAGEINFO() {
    const UNINIT: ::core::mem::MaybeUninit<_CUVIDSEIMESSAGEINFO> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CUVIDSEIMESSAGEINFO>(),
        24usize,
        concat!("Size of: ", stringify!(_CUVIDSEIMESSAGEINFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_CUVIDSEIMESSAGEINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDSEIMESSAGEINFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pSEIData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSEIMESSAGEINFO),
            "::",
            stringify!(pSEIData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pSEIMessage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSEIMESSAGEINFO),
            "::",
            stringify!(pSEIMessage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sei_message_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSEIMESSAGEINFO),
            "::",
            stringify!(sei_message_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).picIdx) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSEIMESSAGEINFO),
            "::",
            stringify!(picIdx)
        )
    );
}
impl Default for _CUVIDSEIMESSAGEINFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDSEIMESSAGEINFO = _CUVIDSEIMESSAGEINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUVIDAV1SEQHDR {
    pub max_width: ::core::ffi::c_uint,
    pub max_height: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uchar; 1016usize],
}
#[test]
fn bindgen_test_layout_CUVIDAV1SEQHDR() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDAV1SEQHDR> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDAV1SEQHDR>(),
        1024usize,
        concat!("Size of: ", stringify!(CUVIDAV1SEQHDR))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDAV1SEQHDR>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDAV1SEQHDR))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDAV1SEQHDR),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDAV1SEQHDR),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDAV1SEQHDR),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUVIDAV1SEQHDR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct CUVIDEOFORMATEX {
    pub format: CUVIDEOFORMAT,
    pub __bindgen_anon_1: CUVIDEOFORMATEX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUVIDEOFORMATEX__bindgen_ty_1 {
    pub av1: CUVIDAV1SEQHDR,
    pub raw_seqhdr_data: [::core::ffi::c_uchar; 1024usize],
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMATEX__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDEOFORMATEX__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDEOFORMATEX__bindgen_ty_1>(),
        1024usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMATEX__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDEOFORMATEX__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMATEX__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).av1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMATEX__bindgen_ty_1),
            "::",
            stringify!(av1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw_seqhdr_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMATEX__bindgen_ty_1),
            "::",
            stringify!(raw_seqhdr_data)
        )
    );
}
impl Default for CUVIDEOFORMATEX__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUVIDEOFORMATEX() {
    const UNINIT: ::core::mem::MaybeUninit<CUVIDEOFORMATEX> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUVIDEOFORMATEX>(),
        1088usize,
        concat!("Size of: ", stringify!(CUVIDEOFORMATEX))
    );
    assert_eq!(
        ::core::mem::align_of::<CUVIDEOFORMATEX>(),
        4usize,
        concat!("Alignment of ", stringify!(CUVIDEOFORMATEX))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUVIDEOFORMATEX),
            "::",
            stringify!(format)
        )
    );
}
impl Default for CUVIDEOFORMATEX {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUAUDIOFORMAT {
    pub codec: cudaAudioCodec,
    pub channels: ::core::ffi::c_uint,
    pub samplespersec: ::core::ffi::c_uint,
    pub bitrate: ::core::ffi::c_uint,
    pub reserved1: ::core::ffi::c_uint,
    pub reserved2: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUAUDIOFORMAT() {
    const UNINIT: ::core::mem::MaybeUninit<CUAUDIOFORMAT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUAUDIOFORMAT>(),
        24usize,
        concat!("Size of: ", stringify!(CUAUDIOFORMAT))
    );
    assert_eq!(
        ::core::mem::align_of::<CUAUDIOFORMAT>(),
        4usize,
        concat!("Alignment of ", stringify!(CUAUDIOFORMAT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).samplespersec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(samplespersec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUAUDIOFORMAT),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for CUAUDIOFORMAT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUvideopacketflags {
    CUVID_PKT_ENDOFSTREAM = 1,
    CUVID_PKT_TIMESTAMP = 2,
    CUVID_PKT_DISCONTINUITY = 4,
    CUVID_PKT_ENDOFPICTURE = 8,
    CUVID_PKT_NOTIFY_EOS = 16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUVIDSOURCEDATAPACKET {
    pub flags: ::core::ffi::c_ulong,
    pub payload_size: ::core::ffi::c_ulong,
    pub payload: *const ::core::ffi::c_uchar,
    pub timestamp: CUvideotimestamp,
}
#[test]
fn bindgen_test_layout__CUVIDSOURCEDATAPACKET() {
    const UNINIT: ::core::mem::MaybeUninit<_CUVIDSOURCEDATAPACKET> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CUVIDSOURCEDATAPACKET>(),
        32usize,
        concat!("Size of: ", stringify!(_CUVIDSOURCEDATAPACKET))
    );
    assert_eq!(
        ::core::mem::align_of::<_CUVIDSOURCEDATAPACKET>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDSOURCEDATAPACKET))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEDATAPACKET),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEDATAPACKET),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEDATAPACKET),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEDATAPACKET),
            "::",
            stringify!(timestamp)
        )
    );
}
impl Default for _CUVIDSOURCEDATAPACKET {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUVIDSOURCEDATAPACKET = _CUVIDSOURCEDATAPACKET;
pub type PFNVIDSOURCECALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDSOURCEDATAPACKET,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUVIDSOURCEPARAMS {
    pub ulClockRate: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub uReserved1: [::core::ffi::c_uint; 6usize],
    pub pUserData: *mut ::core::ffi::c_void,
    pub pfnVideoDataHandler: PFNVIDSOURCECALLBACK,
    pub pfnAudioDataHandler: PFNVIDSOURCECALLBACK,
    pub pvReserved2: [*mut ::core::ffi::c_void; 8usize],
}
#[test]
fn bindgen_test_layout__CUVIDSOURCEPARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_CUVIDSOURCEPARAMS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CUVIDSOURCEPARAMS>(),
        120usize,
        concat!("Size of: ", stringify!(_CUVIDSOURCEPARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_CUVIDSOURCEPARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDSOURCEPARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ulClockRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(ulClockRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uReserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(uReserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnVideoDataHandler) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(pfnVideoDataHandler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnAudioDataHandler) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(pfnAudioDataHandler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReserved2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDSOURCEPARAMS),
            "::",
            stringify!(pvReserved2)
        )
    );
}
impl Default for _CUVIDSOURCEPARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CUVIDSOURCEPARAMS {
    #[inline]
    pub fn bAnnexb(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bAnnexb(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uReserved(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_uReserved(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAnnexb: ::core::ffi::c_uint,
        uReserved: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bAnnexb: u32 = unsafe { ::core::mem::transmute(bAnnexb) };
            bAnnexb as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let uReserved: u32 = unsafe { ::core::mem::transmute(uReserved) };
            uReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type CUVIDSOURCEPARAMS = _CUVIDSOURCEPARAMS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUvideosourceformat_flags {
    CUVID_FMT_EXTFORMATINFO = 256,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _CUVIDPARSERDISPINFO {
    pub picture_index: ::core::ffi::c_int,
    pub progressive_frame: ::core::ffi::c_int,
    pub top_field_first: ::core::ffi::c_int,
    pub repeat_first_field: ::core::ffi::c_int,
    pub timestamp: CUvideotimestamp,
}
#[test]
fn bindgen_test_layout__CUVIDPARSERDISPINFO() {
    const UNINIT: ::core::mem::MaybeUninit<_CUVIDPARSERDISPINFO> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CUVIDPARSERDISPINFO>(),
        24usize,
        concat!("Size of: ", stringify!(_CUVIDPARSERDISPINFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_CUVIDPARSERDISPINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDPARSERDISPINFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).picture_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(picture_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).progressive_frame) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(progressive_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top_field_first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).repeat_first_field) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(repeat_first_field)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERDISPINFO),
            "::",
            stringify!(timestamp)
        )
    );
}
pub type CUVIDPARSERDISPINFO = _CUVIDPARSERDISPINFO;
pub type PFNVIDSEQUENCECALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDEOFORMAT,
    ) -> ::core::ffi::c_int,
>;
pub type PFNVIDDECODECALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDPICPARAMS,
    ) -> ::core::ffi::c_int,
>;
pub type PFNVIDDISPLAYCALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDPARSERDISPINFO,
    ) -> ::core::ffi::c_int,
>;
pub type PFNVIDOPPOINTCALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDOPERATINGPOINTINFO,
    ) -> ::core::ffi::c_int,
>;
pub type PFNVIDSEIMSGCALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut CUVIDSEIMESSAGEINFO,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
pub struct _CUVIDPARSERPARAMS {
    pub CodecType: cudaVideoCodec,
    pub ulMaxNumDecodeSurfaces: ::core::ffi::c_uint,
    pub ulClockRate: ::core::ffi::c_uint,
    pub ulErrorThreshold: ::core::ffi::c_uint,
    pub ulMaxDisplayDelay: ::core::ffi::c_uint,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub uReserved1: [::core::ffi::c_uint; 4usize],
    pub pUserData: *mut ::core::ffi::c_void,
    pub pfnSequenceCallback: PFNVIDSEQUENCECALLBACK,
    pub pfnDecodePicture: PFNVIDDECODECALLBACK,
    pub pfnDisplayPicture: PFNVIDDISPLAYCALLBACK,
    pub pfnGetOperatingPoint: PFNVIDOPPOINTCALLBACK,
    pub pfnGetSEIMsg: PFNVIDSEIMSGCALLBACK,
    pub pvReserved2: [*mut ::core::ffi::c_void; 5usize],
    pub pExtVideoInfo: *mut CUVIDEOFORMATEX,
}
#[test]
fn bindgen_test_layout__CUVIDPARSERPARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<_CUVIDPARSERPARAMS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CUVIDPARSERPARAMS>(),
        136usize,
        concat!("Size of: ", stringify!(_CUVIDPARSERPARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<_CUVIDPARSERPARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_CUVIDPARSERPARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CodecType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(CodecType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ulMaxNumDecodeSurfaces) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(ulMaxNumDecodeSurfaces)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ulClockRate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(ulClockRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ulErrorThreshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(ulErrorThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ulMaxDisplayDelay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(ulMaxDisplayDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uReserved1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(uReserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSequenceCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnSequenceCallback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnDecodePicture) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnDecodePicture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnDisplayPicture) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnDisplayPicture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnGetOperatingPoint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnGetOperatingPoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnGetSEIMsg) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pfnGetSEIMsg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReserved2) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pvReserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pExtVideoInfo) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUVIDPARSERPARAMS),
            "::",
            stringify!(pExtVideoInfo)
        )
    );
}
impl Default for _CUVIDPARSERPARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _CUVIDPARSERPARAMS {
    #[inline]
    pub fn bAnnexb(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bAnnexb(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uReserved(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_uReserved(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bAnnexb: ::core::ffi::c_uint,
        uReserved: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bAnnexb: u32 = unsafe { ::core::mem::transmute(bAnnexb) };
            bAnnexb as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let uReserved: u32 = unsafe { ::core::mem::transmute(uReserved) };
            uReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type CUVIDPARSERPARAMS = _CUVIDPARSERPARAMS;
extern "C" {
    #[must_use]
    pub fn cuvidCreateVideoSource(
        pObj: *mut CUvideosource,
        pszFileName: *const ::core::ffi::c_char,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidCreateVideoSourceW(
        pObj: *mut CUvideosource,
        pwszFileName: *const wchar_t,
        pParams: *mut CUVIDSOURCEPARAMS,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidDestroyVideoSource(obj: CUvideosource) -> CUresult;
    #[must_use]
    pub fn cuvidSetVideoSourceState(obj: CUvideosource, state: cudaVideoState) -> CUresult;
    pub fn cuvidGetVideoSourceState(obj: CUvideosource) -> cudaVideoState;
    #[must_use]
    pub fn cuvidGetSourceVideoFormat(
        obj: CUvideosource,
        pvidfmt: *mut CUVIDEOFORMAT,
        flags: ::core::ffi::c_uint,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidGetSourceAudioFormat(
        obj: CUvideosource,
        paudfmt: *mut CUAUDIOFORMAT,
        flags: ::core::ffi::c_uint,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidCreateVideoParser(
        pObj: *mut CUvideoparser,
        pParams: *mut CUVIDPARSERPARAMS,
    ) -> CUresult;
    #[must_use]
    pub fn cuvidParseVideoData(obj: CUvideoparser, pPacket: *mut CUVIDSOURCEDATAPACKET)
        -> CUresult;
    #[must_use]
    pub fn cuvidDestroyVideoParser(obj: CUvideoparser) -> CUresult;
}
